/*
   Copyright (c) 2015, GEM Foundation.

      This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU Affero General Public License as
      published by the Free Software Foundation, either version 3 of the
      License, or (at your option) any later version.

      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU Affero General Public License for more details.

      You should have received a copy of the GNU Affero General Public License
      along with this program.  If not, see <https://www.gnu.org/licenses/agpl.html>.
*/

var vTable;
var vHeader = [];
var vActiveTablesObj = {};
var vLimitStates;

$('#outputVFDiv').hide();

$('#addVfsDiscrete').click(function() {
    var vFormat = 'discrete';
    updatevfsTable(vFormat);
});

$('#addVfsContinuous').click(function() {
    var vFormat = 'continuous';
    updatevfsTable(vFormat);
    //$('#outputVFDiv').css('display', 'none');
});

var vCount = 0;
function updatevfsTable (vFormat) {
    var colWidth;
    // disable the fragility function form
    $('#vLimitStates').prop('disabled', true);

    // Setup the header
    if (vFormat == 'discrete') {
        vHeader = ['damage state', 'poes'];
        colWidth = 150;
    } else if (vFormat == 'continuous') {
        vHeader = ['damage state', 'mean', 'stddev'];
        colWidth = 100;
    }

    var vHeaderLength = vHeader.length;

    // Get info from the form and build the table header
    vLimitStates = $('#vLimitStates').val();
    vLimitStates = vLimitStates.split(',');
    var limitStateLength = vLimitStates.length;

    // Create the table containers, as many as the user wants
    vCount += 1;

    var imls;
    // Imls value needs to be an array for discrete functions,
    // and minIML & maxIML for continuous
    if (vFormat == 'discrete') {
        imls =
            '<label>IML: </label>' +
            '<input id="'+vCount+'" class="imls vfsTable" placeholder="imls array" type="text">';
    } else if (vFormat == 'continuous') {
        imls =
            '<label> MinIML: </label>' +
            '<input id="'+vCount+'" class="minImls vfsTable" type="text"><br>' +
            '<label> MaxIML: </label>' +
            '<input id="'+vCount+'" class="maxImls vfsTable" type="text">';
    }

    // Create the fragility function set (vfs)
    $('#vTables').append(
        '<div id="vTable'+vCount+'" class="vfsTableDiv panel panel-default">' +
        '<strong class="vfsTitle">'+vFormat.toUpperCase()+'</strong><button id="'+vCount+'" class="btn-danger btn destroyTable">Remove</button><br>' +
            '<div class="vfsForm" >' +
                '<label> IMT: </label>' +
                '<input id="'+vCount+'" class="imt vfsTable" type="text"><br>' +
                '<label> DamageLimit: </label>' +
                '<input id="'+vCount+'" class="noDamageLimit vfsTable" type="text"><br>' +
                imls +
                '<input id="'+vCount+'" type="hidden" class="vFormat vfsTable" value="'+vFormat+'" >' +
                '<br>' +
            '</div>'+
            '<div id="vTableDiv'+vCount+'" class="theTable"></div><br><br>' +
            '<br><br>' +
        '</div>'
    );

    // force bootstrap style
    $('.btn-danger').css({'background-color': '#da4f49'});

    var container = document.getElementById('vTableDiv'+vCount);


    //////////////////////
    /// Table Settings ///
    //////////////////////

    vTable = new Handsontable(container, {
        colHeaders: header,
        startCols: vHeaderLength,
        maxCols: vHeaderLength,
        startRows: limitStateLength,
        colWidths: colWidth,
    });

    // Populate the table with limit states
    for (var i = 0; i < vLimitStates.length; i++) {
        vTable.setDataAtCell(i, 0, vLimitStates[i]);
    }

    vActiveTablesObj[vCount] = vTable;

    $('#outPutVF').empty();
    $('#saveBtnVF').css('display', 'block');

    // Logic to remove a table
    $('.destroyTable').click(function() {
        $('#vTable'+this.id).remove();
        var removedTable = this.id;
        delete vActiveTablesObj[removedTable];
    });

    // Increase the vfs panel when many limit states are defined
    if (limitStateLength > 5) {
        $('.vfsTableDiv').height(240 + (limitStateLength * limitStateLength));
    }

}

$('#saveBtnVF').click(function() {

    // Get the vFormat types
    var vFormatObj = {};
    $(".vFormat").each(function() {
        vFormatObj[this.id] = ($(this).val());
    });

    // Get all the imt values
    var imtObj = {};
    $(".imt").each(function() {
        imtObj[this.id] = ($(this).val());
    });

    // Get all the noDamageLimit values
    var noDamageLimitObj = {};
    $(".noDamageLimit").each(function() {
        noDamageLimitObj[this.id] = ($(this).val());
    });

    // Loop through the function format object and get discrete and continuous values
    for(var k in vFormatObj) {
        if (vFormatObj[k] == 'discrete') {
            // Get all the imls values
            var imlsObj = {};
            $(".imls").each(function() {
                imlsObj[this.id] = ($(this).val());
            });
        } else if (vFormatObj[k] == 'continuous') {
            // Get all the minIML values
            var minImlObj = {};
            $(".minImls").each(function() {
                minImlObj[this.id] = ($(this).val());
            });
            // Get all the maxIML values
            var maxImlObj = {};
            $(".maxImls").each(function() {
                maxImlObj[this.id] = ($(this).val());
            });
        }
    }

    var dataVF = {};
    console.log('vActiveTablesObj:');
    console.log(vActiveTablesObj);
    // get the data for each table
    for(var k in vActiveTablesObj) {
        dataVF[k] = vActiveTablesObj[k].getData();
    }
    console.log('dataVF:');
    console.log(dataVF);

    // Check for null values
    for(var k in dataVF) {
        for (var i = 0; i < dataVF[k].length; i++) {
            for (var j = 0; j < dataVF[k][i].length; j++) {
                if (dataVF[k][i][j] === null) {
                    alert("whoops, there seem to be some empty cells");
                    return;
                }
            }
        }
    }

    var functionId = $('#vFunctionId').val();
    var assetCategory = $('#vAssetCategory').val();
    var lossCategory = $('#vLossCategory').val();
    var functionDescription = $('#vFunctionDescription').val();

    /////////////////////////////
    // Create limit state list //
    /////////////////////////////

    // Opening limit state tag
    var vLimitStatesXML = '\t\t<limitStates> ';

    for (var i = 0; i < vLimitStates.length; i++) {
        // Dynamic limit state tag(s)
        vLimitStatesXML += vLimitStates[i];
    }

    // Closing limit state tag
    vLimitStatesXML += '</limitStates> \n';

    ////////////////
    // Create vfs //
    ////////////////

    var vulnFunction = '';
    // Create the vfs elements
    for (var k in dataVF) {
        var vfs;
        // Opening vfs tag
        if (vFormatObj[k] == 'discrete') {
            vfs = '\t\t<vulnFunction id="vf'+k+'" format="'+vFormatObj[k]+'">\n';
        } else if (vFormatObj[k] == 'continuous') {
            vfs = '\t\t<vulnFunction id="vf'+k+'" format="'+vFormatObj[k]+'" shape="logncdf">\n';
        }
        // Create the imls tag
        var imlsTag;
        if (vFormatObj[k] == 'discrete') {
            imlsTag = '\t\t\t<imls imt="'+imtObj[k]+'" noDamageLimit="'+noDamageLimitObj[k]+'">'+imlsObj[k]+'</imls>\n';
        } else if (vFormatObj[k] == 'continuous') {
            imlsTag = '\t\t\t<imls imt="'+imtObj[k]+'" noDamageLimit="'+noDamageLimitObj[k]+'" minIML="'+minImlObj[k]+'" maxIML="'+maxImlObj[k]+'">\n';
        }
        // Dynamic imls tag
        vfs += imlsTag;

        // Loop through the table rows and create the poes tags
        for (var i = 0; i < dataVF[k].length; i++) {
            // Dynamic vfs tag(s)
            if (vFormatObj[k] == 'discrete') {
                vfs += '\t\t\t<poes ls="'+vLimitStates[i]+'">'+dataVF[k][i][1]+'</poes>\n';
            } else if (vFormatObj[k] == 'continuous') {
                vfs += '\t\t\t<params ls="'+vLimitStates[i]+'" mean="'+dataVF[k][i][1]+'" stddev="'+dataVF[k][i][2]+'"/>\n';
            }
        }
        // Closing vfs tags
        vfs += '\t\t</vulnFunction>\n';
        vulnFunction += vfs;
    }

    // Create a NRML element
    var NRML =
        '<?xml version="1.0" encoding="UTF-8"?> \n' +
        '<nrml xmlns="http://openquake.org/xmlns/nrml/0.5"> \n' +
            '\t<vulnerabilityFunction id="'+functionId+'" assetCategory="'+assetCategory+'" lossCategory="'+lossCategory+'"> \n' +
                '\t\t<description>'+functionDescription+'</description> \n' +
                vLimitStatesXML +
                vulnFunction +
            '\t</vulnerabilityFunction> \n' +
        '</nrml>';

    // Provide the user with the xml output
    $('#outPutVF').empty();
    $('#outPutVF').append('<textarea id="textarea" style="width: 600px;  height: 700px;>'+NRML+'</textarea>');
    $('#outputVFDiv').css('display', 'block');
    selectAllVFText();
});

$('#selectAllVF').click(function() {
    var textBox = document.getElementById("textarea");
    textBox.select();
});

function selectAllVFText () {
    var textBox = document.getElementById("textarea");
    textBox.onfocus = function() {
        textBox.select();

        // Work around Chrome's little problem
        textBox.onmouseup = function() {
            // Prevent further mouseup intervention
            textBox.onmouseup = null;
            return false;
        };
    };
}

