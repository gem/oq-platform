/*
   Copyright (c) 2015-2016, GEM Foundation.

      This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU Affero General Public License as
      published by the Free Software Foundation, either version 3 of the
      License, or (at your option) any later version.

      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU Affero General Public License for more details.

      You should have received a copy of the GNU Affero General Public License
      along with this program.  If not, see <https://www.gnu.org/licenses/agpl.html>.
*/

var vf_obj = { tbl: {},
               tbl_idx: 0,
               nrml: ""
             };

function vf_sh2long(funcType)
{
    if (funcType == "prob_mass")
        return "probability mass function";
    else if (funcType == "discr")
        return "discrete function";
}

/* acceptable values for funcType are "prob_mass" and "discr" */
function vf_updateTable(funcType)
{
    var table = null;
    var colWidth, maxRows;
    var format_name = vf_sh2long(funcType);
    var tab_header = [];

    // Setup the header
    if (funcType == 'prob_mass') {
        tab_header = ['loss ratio', 'probabilities'];
        colWidth = 80;
        maxRows = "Infinity";
    } else if (funcType == 'discr') {
        tab_header = ['IML', 'meanLRs', 'covLRs'];
        colWidth = 80;
        maxRows = "Infinity";
    }
    else {
        return false;
    }
    // Create the table containers, as many as the user wants
    vf_obj.tbl_idx += 1;

    var imls;
    // Imls value needs to be an array for probability mass function functions,
    // and minIML & maxIML for discrete
    if (funcType == 'prob_mass') {
        imls =
            '<label>IML: </label>' +
            '<input name="imls" class="vfsTable" placeholder="imls array" type="text">' +
            '<input name="distribution_select" type="hidden" class="distributionSelect" value="PM" >';
    } else if (funcType == 'discr') {
        imls =
            '<label>IML: </label>' +
            '<input name="imls" class="vfsTable" placeholder="imls array" type="text"><br>' +
            '<label> Dist: </label>' +
            '<select name="distribution_select" class="vfsTable distributionSelect">' +
                '<option value="LN">LN</option>' +
                '<option value="BT">BT</option>' +
            '</select><br>';
    }

    // Create the fragility function set (vfs)
    $('.vf_gid [name="tables"]').append(
        '<div id="table'+vf_obj.tbl_idx+'" class="tables_gid table'+vf_obj.tbl_idx+'_id'+
          ' vfsTableDiv panel panel-default" data-gem-func-type="'+ funcType + '">' +
          '<strong class="vfsTitle">' + format_name.toUpperCase() + '</strong><button name="destroy_table" class="destroyTable btn-danger btn">Remove Function</button><br>' +
          '<div class="vfsForm" >' +
            '<label> ID: </label>' +
            '<input name="id" class="vfsTable" type="text"><br>' +
            '<label> IMT: </label>' +
            '<input name="imt" class="imt_id imt vfsTable" type="text" placeholder="PGA"><br>' +
            imls + '<br>' +
          '</div>'+
          '<div class="theVTableWrapper">' +
            '<div name="tableDiv'+vf_obj.tbl_idx+'" class="theVTable"></div>' +
          '</div>' +
        '</div>'
    );

    // force bootstrap style
    $('.btn-danger').css({'background-color': '#da4f49'});

    var container = document.getElementById;
    //////////////////////
    /// Table Settings ///
    //////////////////////

    var ht_params = {
        colHeaders: tab_header,
        startCols: tab_header.length,
        colWidths: colWidth,
        startRows: 3,
        maxRows: "Infinity",
        rowHeaders: false,
        contextMenu: true,

        cells: function(r,c, prop) {
            var cellProperties = {};
            if (r===0) cellProperties.readOnly = true;
            return cellProperties;
        }

    };

    $('.vf_gid [name="tableDiv'+vf_obj.tbl_idx+'"]').handsontable(ht_params);
    table = $('.vf_gid [name="tableDiv'+vf_obj.tbl_idx+'"]').handsontable('getInstance');

    vf_obj.tbl[vf_obj.tbl_idx] = table;

    $('.vf_gid #outputText').empty();
    $('.vf_gid #convertBtn').show();

    // use tbl_idx to fix with a closure the idx value inside click and change callbacks
    var tbl_idx = vf_obj.tbl_idx;

    // Logic to remove a table
    $('.vf_gid .table' + tbl_idx + '_id [name="destroy_table"]').click(function() {
        $('.vf_gid #table' + tbl_idx).remove();
        delete vf_obj.tbl[tbl_idx];
        if (Object.keys(vf_obj.tbl).length == 0) {
            $('.vf_gid #convertBtn').hide();
        }
    });

    if (funcType == 'prob_mass') {
        $('.vf_gid #table' + vf_obj.tbl_idx + ' [name="imls"]').change(function () {
            var el = row_split(this.value);
            var cols_cur, cols_n = el.length + 1;
            var table;

            table = $('.vf_gid [name="tableDiv'+tbl_idx+'"]').handsontable('getInstance');

            cols_cur = table.countCols();

            var colHeader = ['loss ratio'];
            for (var i = 1 ; i < cols_n ; i++) {
                colHeader[i] = el[i-1];
            }

            // increment columns number
            if (cols_cur < cols_n) {
                table.alter('insert_col', cols_cur, cols_n - cols_cur);
                table.updateSettings({colHeaders: colHeader, cells: null});
            }
            // reduce columns number
            else {
                table.alter('remove_col', cols_n, cols_cur - cols_n);
                table.updateSettings({colHeaders: colHeader});
            }
        });
    }
    else if (funcType == 'discr') {
        $('.vf_gid #table' + vf_obj.tbl_idx + ' [name="imls"]').change(function () {
            var el = row_split(this.value);

            var rows_cur, rows_n = el.length;
            var table;

            table = $('.vf_gid [name="tableDiv'+tbl_idx+'"]').handsontable('getInstance');
            rows_cur = table.countRows();

            if (rows_cur < rows_n) { // increment rows number
                table.updateSettings({maxRows: rows_n});
                table.alter('insert_row', rows_cur, rows_n - rows_cur);
                table.updateSettings({
                    cells: function(r,c, prop) {
                        var cellProperties = {};
                        if (c===0)
                            cellProperties.readOnly = true;
                        return cellProperties;
                    }});
            }
            else { // reduce columns number
                table.alter('remove_row', rows_n, rows_cur - rows_n);
                table.updateSettings({rowHeaders: rowHeader, maxRows: rows_cur});
            }
            for (var i = 0 ; i < rows_n ; i++) {
                for (var i = 0; i < el.length; i++) {
                    table.setDataAtCell(i, 0, el[i]);
                }
            }

        });
    }
}

$('.vf_gid #downloadBtn').click(function() {
    sendbackNRML(vf_obj.nrml, 'vf');
});

$('.vf_gid #convertBtn').click(function() {
    var tabs_data = {};

    // get the data for each table
    for (var k in vf_obj.tbl) {
        tabs_data[k] = vf_obj.tbl[k].getData();
    }

    // Check for null values
    for (var k in tabs_data) {
        var pfx = '.vf_gid .table'+k+'_id';
        var tab_data = tabs_data[k];

        for (var i = 0; i < tab_data.length; i++) {
            for (var j = 0; j < tab_data[i].length; j++) {
                if (tab_data[i][j] === null || tab_data[i][j].toString().trim() == "") {
                    var funcType = $(pfx).attr('data-gem-func-type');
                    var funcId = $(pfx+' [name="id"]').val();
                    var error_msg = "empty cell detected at coords (" + (i+1) + ", " + (j+1) + ") of " +
                        vf_sh2long(funcType)+ " with ID " + funcId;

                    output_manager('vf', error_msg, null, null);
                    return;
                }
            }
        }
    }

    var functionId = $('.vf_gid #functionId').val();
    var assetCategory = $('.vf_gid #assetCategory').val();
    var lossCategory = $('.vf_gid #lossCategory').val();
    var functionDescription = $('.vf_gid #functionDescription').val();


    ////////////////
    // Create vfs //
    ////////////////

    var vulnFunction = '';
    // Create the vfs elements
    for (var k in tabs_data) {
        var vfs = "";
        var tab_data = tabs_data[k];
        var pfx = '.vf_gid .table'+k+'_id';
        var funcType = $(pfx).attr('data-gem-func-type');
        var distSelect = $(pfx+' [name="distribution_select"]').val();
        // Opening vfs tag
        vfs += '\t\t<vulnerabilityFunction id="'+$(pfx+' [name="id"]').val()+
            '" dist="' + distSelect + '">\n';

        vfs += '\t\t\t<imls imt="'+$(pfx+' [name="imt"]').val()+'">'+$(pfx+' [name="imls"]').val()+'</imls>\n';

        if (funcType == 'prob_mass') {
            // Loop through the table rows and create the probabilities tags
            for (var i = 0; i < tab_data.length; i++) {
                // Dynamic vfs tag(s)
                var probs = "";
                for (e = 1 ; e < tab_data[i].length ; e++) {
                    probs += (probs == "" ? "" : " " ) + tab_data[i][e];
                }
                vfs += '\t\t\t<probabilities lr="'+tab_data[i][0]+'">'+probs+'</probabilities>\n';
            }
        }
        else if (funcType == 'discr') {
            var means = "", covs = "";
            for (var i = 0; i < tab_data.length; i++) {
                means += (means == "" ? "" : " " ) + tab_data[i][1];
                covs += (covs == "" ? "" : " " ) + tab_data[i][2];
            }
            vfs += '\t\t\t<meanLRs>' + means + '</meanLRs>\n';
            vfs += '\t\t\t<covLRs>' + covs + '</covLRs>\n';
        }

        // Closing vfs tags
        vfs += '\t\t</vulnerabilityFunction>\n';
        vulnFunction += vfs;
    }

    // Create a NRML element
    var nrml =
        '<?xml version="1.0" encoding="UTF-8"?> \n' +
        '<nrml xmlns="http://openquake.org/xmlns/nrml/0.5"> \n' +
            '\t<vulnerabilityModel id="' + functionId + '" assetCategory="'+ assetCategory + '" lossCategory="'+lossCategory+'"> \n' +
                '\t\t<description>' + functionDescription + '</description> \n' +
                vulnFunction +
            '\t</vulnerabilityModel> \n' +
        '</nrml>';

    validateAndDisplayNRML(nrml, 'vf', vf_obj);
});

// initialization function
$(document).ready(function (){
    $('.vf_gid #outputDiv').hide();

    $('.vf_gid #addProbMassFunc').click(function() {
        vf_updateTable("prob_mass");
    });

    $('.vf_gid #addDiscreteFunc').click(function() {
        vf_updateTable('discr');
    });
});

