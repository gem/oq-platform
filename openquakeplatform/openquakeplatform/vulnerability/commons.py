# Copyright (c) 2012-2013, GEM Foundation.
#
# This program is free software: you can redistribute it and/or modify
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import re
import os
from django.forms.util import ValidationError as FormValidationError
from django.forms.fields import CharField
#from roman import roman_to_int


class SemicolonSeparatedFloatFormField(CharField):
    def __init__(self, *args, **kwargs):
        self.max_length = 1024
        super(SemicolonSeparatedFloatFormField, self).__init__(*args, **kwargs)

    def clean(self, value):
        value = super(CharField, self).clean(value)
        if not value:
            return value
        value = preprocess_input(value)
        # Switch decimal separator from , to .
        value = value.replace(',', '.')
        try:
            [float(x) for x in value.split(";")]
        except ValueError as e:
            raise FormValidationError(e)
        return value


#class SemicolonSeparatedFloatRomanFormField(CharField):
    #def __init__(self, *args, **kwargs):
        #self.max_length = 1024
        #super(SemicolonSeparatedFloatRomanFormField, self).__init__(
            #*args, **kwargs)

    #def clean(self, value):
        #value = super(CharField, self).clean(value)
        #value = preprocess_input(value)
        #for element in value.split(";"):
            #if not isinstance(element, float):
                #try:
                    #roman_to_int(element)
                #except ValueError as e:
                    #raise FormValidationError(e)
        #return value


class SemicolonSeparatedStringFormField(CharField):
    def __init__(self, *args, **kwargs):
        self.max_length = 1024
        super(SemicolonSeparatedStringFormField, self).__init__(
            *args, **kwargs)

    def clean(self, value):
        value = super(CharField, self).clean(value)
        if not value:
            return value
        value = preprocess_s_input(value)
        # Change , into ; as separator (reasonably safe for strings)
        value = value.replace(',', ';')
        try:
            [str(x) for x in value.split(";")]
        except ValueError as e:
            raise FormValidationError(e)
        return value


class BidimensionalFloatFormField(CharField):
    def __init__(self, *args, **kwargs):
        self.max_length = 1024
        super(BidimensionalFloatFormField, self).__init__(*args, **kwargs)

    def clean(self, value):
        value = super(CharField, self).clean(value)
        if not value:
            return value
        value = preprocess_input(value)
        # Switch decimal separator from , to .
        value = value.replace(',', '.')
        rows = value.split("\n")
        len_first_row = len(rows[0].split(';'))
        for row in rows:
            try:
                row_elems = [float(x) for x in row.split(";")]
                if len(row_elems) != len_first_row:
                    raise FormValidationError(
                        'All rows should have the same number of elements')
            except ValueError as e:
                raise FormValidationError(e)
        return value


def preprocess_s_input(value):
    value = value.replace('\t', ';').replace('\r\n', '\n')
    value = re.sub(r';+', ';', value)
    value = value.rstrip('\n\r\t;,')
    value = value.replace(';\n', '\n')
    value = os.linesep.join([line for line in value.splitlines() if line])
    return value


def preprocess_input(value):
    value = value.replace('\t', ';').replace(' ', '').replace('\r\n', '\n')
    value = re.sub(r';+', ';', value)
    value = value.rstrip('\n\r\t;,')
    value = value.replace(';\n', '\n')
    value = os.linesep.join([line for line in value.splitlines() if line])
    return value
