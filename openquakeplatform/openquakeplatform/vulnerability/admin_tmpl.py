try:
    from django.contrib.admin.options import force_unicode
except ImportError:
    from django.utils.encoding import force_text as force_unicode
from django import VERSION as DJANGO_VERSION
from django.contrib import admin
from django.db import models, transaction
from django.views.decorators.csrf import csrf_protect
from django.utils.decorators import method_decorator
from django.forms.util import ErrorList
from django.utils.translation import ugettext as _
from django.core.exceptions import PermissionDenied
from django.contrib.admin.util import unquote
from django.contrib.admin.helpers import InlineAdminFormSet, AdminForm
from django.http import Http404
from django.utils.html import escape
from django.core.urlresolvers import reverse
csrf_protect_m = method_decorator(csrf_protect)
from nested_inlines.admin import NestedModelAdmin, NestedStackedInline
from nested_inlines.helpers import AdminErrorList
from openquakeplatform.vulnerability.forms import PredictorVarForm
from openquakeplatform.vulnerability.forms import CC_PredictorVarForm

# DO NOT REMOVE: end of static header

from models import EmpiricalModelInfo
from models import AnalyticalModelInfo
from models import StatisticalInformation
from models import CC_PredictorVar
from models import CapacityCurveFunc
from models import DamageToLossFunc
from models import FuncDistrVulnCont
from models import FuncDistrVulnDiscr
from models import PredictorVar
from models import VulnerabilityFunc
from models import FuncDistrFragCont
from models import FuncDistrFragDiscr
from models import FragilityFunc
from models import GeneralInformation
from models import QRSEmpirical
from models import QRSAnalytical
from models import FuncDistrDTLDiscr

# DO NOT REMOVE: begin of admin class definitions


from models import (MOE_ANALYTICAL,
                    MOE_EMPIRICAL,
                    TA_FRAGILITY,
                    TA_VULNERABILITY,
                    TA_DAMAGE_TO_LOSS,
                    TA_CAPACITY_CURVE, )


class NestedModelAdminCrossChecked(NestedModelAdmin):
    def is_cross_valid(self, form, formsets):
        return True

    @csrf_protect_m
    @transaction.commit_on_success
    def add_view(self, request, form_url='', extra_context=None):
        "The 'add' admin view for this model."
        model = self.model
        opts = model._meta

        if not self.has_add_permission(request):
            raise PermissionDenied

        ModelForm = self.get_form(request)
        formsets = []
        inline_instances = self.get_inline_instances(request, None)
        if request.method == 'POST':
            form = ModelForm(request.POST, request.FILES)
            if form.is_valid():
                new_object = self.save_form(request, form, change=False)
                form_validated = True
            else:
                form_validated = False
                new_object = self.model()
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request), inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(data=request.POST, files=request.FILES,
                                  instance=new_object,
                                  save_as_new="_saveasnew" in request.POST,
                                  prefix=prefix, queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)
            if (self.all_valid_with_nesting(formsets) and form_validated
                    and self.is_cross_valid(form, formsets)):
                self.save_model(request, new_object, form, False)
                self.save_related(request, form, formsets, False)
                self.log_addition(request, new_object)
                return self.response_add(request, new_object)
        else:
            # Prepare the dict of initial data from the request.
            # We have to special-case M2Ms as a list of comma-separated PKs.
            initial = dict(request.GET.items())
            for k in initial:
                try:
                    f = opts.get_field(k)
                except models.FieldDoesNotExist:
                    continue
                if isinstance(f, models.ManyToManyField):
                    initial[k] = initial[k].split(",")
            form = ModelForm(initial=initial)
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request), inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(instance=self.model(), prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)

        adminForm = AdminForm(form, list(self.get_fieldsets(request)),
            self.get_prepopulated_fields(request),
            self.get_readonly_fields(request),
            model_admin=self)
        media = self.media + adminForm.media

        inline_admin_formsets = []
        for inline, formset in zip(inline_instances, formsets):
            fieldsets = list(inline.get_fieldsets(request))
            readonly = list(inline.get_readonly_fields(request))
            prepopulated = dict(inline.get_prepopulated_fields(request))
            inline_admin_formset = InlineAdminFormSet(inline, formset,
                fieldsets, prepopulated, readonly, model_admin=self)
            inline_admin_formsets.append(inline_admin_formset)
            media = media + inline_admin_formset.media
            if inline.inlines:
                media = media + self.wrap_nested_inline_formsets(request, inline, formset)

        context = {
            'title': _('Add %s') % force_unicode(opts.verbose_name),
            'adminform': adminForm,
            'is_popup': "_popup" in request.REQUEST,
            'show_delete': False,
            'media': media,
            'inline_admin_formsets': inline_admin_formsets,
            'errors': AdminErrorList(form, formsets),
            'app_label': opts.app_label,
            'django_version_lt_1_6': DJANGO_VERSION < (1, 6)
        }
        context.update(extra_context or {})
        return self.render_change_form(request, context, form_url=form_url, add=True)

    @csrf_protect_m
    @transaction.commit_on_success
    def change_view(self, request, object_id, form_url='', extra_context=None):
        "The 'change' admin view for this model."
        model = self.model
        opts = model._meta

        obj = self.get_object(request, unquote(object_id))

        if not self.has_change_permission(request, obj):
            raise PermissionDenied

        if obj is None:
            raise Http404(_('%(name)s object with primary key %(key)r does not exist.') % {'name': force_unicode(opts.verbose_name), 'key': escape(object_id)})

        if request.method == 'POST' and "_saveasnew" in request.POST:
            return self.add_view(request, form_url=reverse('admin:%s_%s_add' %
                                    (opts.app_label, opts.module_name),
                                    current_app=self.admin_site.name))

        ModelForm = self.get_form(request, obj)
        formsets = []
        inline_instances = self.get_inline_instances(request, obj)
        if request.method == 'POST':
            form = ModelForm(request.POST, request.FILES, instance=obj)
            if form.is_valid():
                form_validated = True
                new_object = self.save_form(request, form, change=True)
            else:
                form_validated = False
                new_object = obj
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request, new_object), inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(request.POST, request.FILES,
                                  instance=new_object, prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)

            if (self.all_valid_with_nesting(formsets) and form_validated
                    and self.is_cross_valid(form, formsets)):
                self.save_model(request, new_object, form, True)
                self.save_related(request, form, formsets, True)
                change_message = self.construct_change_message(request, form, formsets)
                self.log_change(request, new_object, change_message)
                return self.response_change(request, new_object)

        else:
            form = ModelForm(instance=obj)
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request, obj), inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(instance=obj, prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)

        adminForm = AdminForm(form, self.get_fieldsets(request, obj),
            self.get_prepopulated_fields(request, obj),
            self.get_readonly_fields(request, obj),
            model_admin=self)
        media = self.media + adminForm.media

        inline_admin_formsets = []
        for inline, formset in zip(inline_instances, formsets):
            fieldsets = list(inline.get_fieldsets(request, obj))
            readonly = list(inline.get_readonly_fields(request, obj))
            prepopulated = dict(inline.get_prepopulated_fields(request, obj))
            inline_admin_formset = InlineAdminFormSet(inline, formset,
                fieldsets, prepopulated, readonly, model_admin=self)
            inline_admin_formsets.append(inline_admin_formset)
            media = media + inline_admin_formset.media
            if inline.inlines:
                media = media + self.wrap_nested_inline_formsets(request, inline, formset)

        context = {
            'title': _('Change %s') % force_unicode(opts.verbose_name),
            'adminform': adminForm,
            'object_id': object_id,
            'original': obj,
            'is_popup': "_popup" in request.REQUEST,
            'media': media,
            'inline_admin_formsets': inline_admin_formsets,
            'errors': AdminErrorList(form, formsets),
            'app_label': opts.app_label,
            'django_version_lt_1_6': DJANGO_VERSION < (1, 6)
        }
        context.update(extra_context or {})
        return self.render_change_form(request, context, change=True, obj=obj, form_url=form_url)


#class QRSEmpiricalAdmin(admin.ModelAdmin):
    #fieldsets = (
        #('Data quality', {
            #'classes': ('collapse',),
            #'fields': ('data_quantity',
                       #'constrained_categories',
                       #'excitation_observation',
                       #'damage_loss_observation',)
        #}),
        #('Rationality', {
            #'classes': ('collapse',),
            #'fields': ('hindcasting',
                       #'cross_validation',
                       #'first_principles',
                       #'uncertainties_treatment',)
        #}),
        #(None, {
            #'fields': ('documentation_quality',
                       #'representativeness',
                       #'overall_rating',)
        #}),
    #)


#admin.site.unregister(QRSEmpirical)
#admin.site.register(QRSEmpirical, QRSEmpiricalAdmin)


class CC_PredictorVarInline(NestedStackedInline):
    form = CC_PredictorVarForm
    model = CC_PredictorVar
    fk_name = 'capacity_curve_func'


class CC_AnalyticalModelInfoInline(NestedStackedInline):
    model = AnalyticalModelInfo
    exclude = ('damage_to_loss_func',
               'fragility_func',
               'vulnerability_func')
    fk_name = 'capacity_curve_func'


class CC_EmpiricalModelInfoInline(NestedStackedInline):
    model = EmpiricalModelInfo
    exclude = ('damage_to_loss_func',
               'fragility_func',
               'vulnerability_func')
    fk_name = 'capacity_curve_func'


class CC_StatisticalInformationInline(NestedStackedInline):
    model = StatisticalInformation
    exclude = ('damage_to_loss_func',
               'fragility_func',
               'vulnerability_func',)
    fk_name = 'capacity_curve_func'


class CapacityCurveFuncInline(NestedStackedInline):
    model = CapacityCurveFunc
    inlines = [
        CC_AnalyticalModelInfoInline,
        CC_EmpiricalModelInfoInline,
        CC_PredictorVarInline,
        CC_StatisticalInformationInline,
    ]


#admin.site.unregister(CapacityCurveFunc)
#admin.site.register(CapacityCurveFunc, CapacityCurveFuncInline)


class DL_AnalyticalModelInfoInline(NestedStackedInline):
    model = AnalyticalModelInfo
    exclude = ('capacity_curve_func',
               'fragility_func',
               'vulnerability_func')
    fk_name = 'damage_to_loss_func'


class DL_EmpiricalModelInfoInline(NestedStackedInline):
    model = EmpiricalModelInfo
    exclude = ('fragility_func',
               'vulnerability_func')
    fk_name = 'damage_to_loss_func'


class DL_StatisticalInformationInline(NestedStackedInline):
    model = StatisticalInformation
    exclude = ('vulnerability_func',
               'fragility_func',
               'capacity_curve_func',)
    fk_name = 'damage_to_loss_func'


class DL_FuncDistrDTLDiscrInline(NestedStackedInline):
    model = FuncDistrDTLDiscr
    fl_name = 'damage_to_loss_func'


class DamageToLossFuncInline(NestedStackedInline):
    model = DamageToLossFunc
    inlines = [
        DL_AnalyticalModelInfoInline,
        DL_EmpiricalModelInfoInline,
        DL_StatisticalInformationInline,
        DL_FuncDistrDTLDiscrInline,
    ]


#admin.site.unregister(DamageToLossFunc)
#admin.site.register(DamageToLossFunc, DamageToLossFuncInline)


class VU_AnalyticalModelInfoInline(NestedStackedInline):
    model = AnalyticalModelInfo
    exclude = ('capacity_curve_func',
               'damage_to_loss_func',
               'fragility_func')
    fk_name = 'vulnerability_func'


class VU_EmpiricalModelInfoInline(NestedStackedInline):
    model = EmpiricalModelInfo
    exclude = ('damage_to_loss_func',
               'fragility_func')
    fk_name = 'vulnerability_func'


class VU_StatisticalInformationInline(NestedStackedInline):
    model = StatisticalInformation
    exclude = ('damage_to_loss_func',
               'fragility_func',
               'capacity_curve_func',)
    fk_name = 'vulnerability_func'


class VU_PredictorVarInline(NestedStackedInline):
    model = PredictorVar
    form = PredictorVarForm
    exclude = ('fragility_func',)
    fk_name = 'vulnerability_func'


class VU_FuncDistrVulnDiscrInline(NestedStackedInline):
    model = FuncDistrVulnDiscr
    fk_name = 'vulnerability_func'


class VU_FuncDistrVulnContInline(NestedStackedInline):
    model = FuncDistrVulnCont
    fk_name = 'vulnerability_func'


def formset_by_rel_name(formsets, rel_name):
    for formset in formsets:
        if formset.rel_name == rel_name:
            return formset
    return None


class VU_QRSAnalyticalInline(NestedStackedInline):
    model = QRSAnalytical
    exclude = ('fragility_func', )
    fk_name = 'vulnerability_func'


class VU_QRSEmpiricalInline(NestedStackedInline):
    model = QRSEmpirical
    exclude = ('fragility_func', )
    fk_name = 'vulnerability_func'


def formset_is_empty(formset):
    #print "1 - formset is empty"
    if not hasattr(formset, 'cleaned_data'):
        return True
    #print "2 - formset is empty"
    if len(formset.cleaned_data) == 0:
        return True
    #print "3 - formset is empty"
    if not formset.cleaned_data[0]:
        return True
    #print "4 - formset is empty"
    if ('DELETE' in formset.cleaned_data[0]
            and formset.cleaned_data[0]['DELETE'] is True
            and formset.can_delete is True):
        return True
    #print "5 - formset is empty"
    return False


def error_add(formset, field_name, desc):
    if not hasattr(formset, 'forms'):
        return False
    if len(formset.forms) != 1:
        return False
    if not hasattr(formset.forms[0], '_errors'):
        return False
    formset.forms[0]._errors[field_name] = ErrorList([desc])


class VulnerabilityFuncInline(NestedStackedInline):
    model = VulnerabilityFunc
    inlines = [
        VU_AnalyticalModelInfoInline,
        VU_EmpiricalModelInfoInline,
        VU_PredictorVarInline,
        VU_StatisticalInformationInline,
        VU_FuncDistrVulnDiscrInline,
        VU_FuncDistrVulnContInline,
        VU_QRSAnalyticalInline,
        VU_QRSEmpiricalInline,
    ]

    def is_cross_valid(self, form, formsets):
        print 'INSIDE VALIDATION OF VULNERABILITYFUNCINLINE'
        if not form.is_valid():
            form.errors['__all__'] = "Invalid form"
            return False
        fs_analytical_model_info = formset_by_rel_name(formsets,
                                                       'analytical_model_info')
        fs_empirical_model_info = formset_by_rel_name(formsets,
                                                      'empirical_model_info')
        if not fs_analytical_model_info or not fs_empirical_model_info:
            form.errors['__all__'] = 'Required formsets not found'
            return False
        if form.cleaned_data['method_of_estimation'] == MOE_ANALYTICAL:
            if formset_is_empty(fs_analytical_model_info):
                error_add(
                    fs_analytical_model_info, '__all__',
                    "Mandatory fields when method of estimation is analytical")
                return False
            # TODO: Set empirical model info fields to empty instead of rising
            # error
            if not formset_is_empty(fs_empirical_model_info):
                error_add(
                    fs_empirical_model_info, '__all__',
                    "Analytical method of estimation selected. "
                    "These fields must be void")
                return False
        if form.cleaned_data['method_of_estimation'] == MOE_EMPIRICAL:
            if formset_is_empty(fs_empirical_model_info):
                error_add(
                    fs_empirical_model_info, '__all__',
                    "Mandatory fields when method of estimation is empirical")
                return False
            # TODO: Set analytical model info fields to empty instead of rising
            # error
            if not formset_is_empty(fs_analytical_model_info):
                error_add(
                    fs_analytical_model_info, '__all__',
                    "Empirical method of estimation selected. "
                    "These fields must be void")
                return False
        print 'form'
        print dir(form)
        print 'has_changed:', form.has_changed()
        print 'is_valid:', form.is_valid()
        print 'is_bound:', form.is_bound
        print 'cleaned_data:', form.cleaned_data  # .get('DELETE')
        for formset in formsets:
            print 'formset'
            print dir(formset)
            print 'model:', formset.model()
            print 'rel_name:', formset.rel_name
            print 'has_changed:', formset.has_changed()
            print 'is_valid:', formset.is_valid()
            print 'is_bound:', formset.is_bound
            print 'can_delete:', formset.can_delete
            print 'cleaned_data:', formset.cleaned_data  # .get('DELETE')
            print 'delete defined and set true:', (
                'true' if 'DELETE' in formset.cleaned_data[0]
                and formset.cleaned_data[0]['DELETE'] is True
                else 'false')
            for formset_form in formset.forms:
                print "FORMSETFORM LOOP"
                if hasattr(formset_form, 'cleaned_data'):
                    print 'dir(formset_form):', dir(formset_form)

        return True

#admin.site.unregister(VulnerabilityFunc)
#admin.site.register(VulnerabilityFunc, VulnerabilityFuncInline)


class FR_AnalyticalModelInfoInline(NestedStackedInline):
    model = AnalyticalModelInfo
    exclude = ('capacity_curve_func',
               'damage_to_loss_func',
               'vulnerability_func')
    fk_name = 'fragility_func'


class FR_EmpiricalModelInfoInline(NestedStackedInline):
    model = EmpiricalModelInfo
    exclude = ('damage_to_loss_func',
               'vulnerability_func')
    fk_name = 'fragility_func'


class FR_StatisticalInformationInline(NestedStackedInline):
    model = StatisticalInformation
    exclude = ('damage_to_loss_func',
               'vulnerability_func',
               'capacity_curve_func',)
    fk_name = 'fragility_func'


class FR_PredictorVarInline(NestedStackedInline):
    model = PredictorVar
    form = PredictorVarForm
    exclude = ('vulnerability_func',)
    fk_name = 'fragility_func'


class FR_FuncDistrFragContInline(NestedStackedInline):
    model = FuncDistrFragCont
    fk_name = 'fragility_func'


class FR_FuncDistrFragDiscrInline(NestedStackedInline):
    model = FuncDistrFragDiscr
    fk_name = 'fragility_func'


class FR_QRSEmpiricalInline(NestedStackedInline):
    model = QRSEmpirical
    exclude = ('vulnerability_func', )
    fk_name = 'fragility_func'


class FR_QRSAnalyticalInline(NestedStackedInline):
    model = QRSAnalytical
    exclude = ('vulnerability_func', )
    fk_name = 'fragility_func'


class FragilityFuncInline(NestedStackedInline):
    model = FragilityFunc
    inlines = [
        FR_AnalyticalModelInfoInline,
        FR_EmpiricalModelInfoInline,
        FR_PredictorVarInline,
        FR_StatisticalInformationInline,
        FR_FuncDistrFragContInline,
        FR_FuncDistrFragDiscrInline,
        FR_QRSEmpiricalInline,
        FR_QRSAnalyticalInline,
    ]


#admin.site.unregister(FragilityFunc)
#admin.site.register(FragilityFunc, FragilityFuncInline)


class GeneralInformationAdmin(NestedModelAdminCrossChecked):
    inlines = [
        FragilityFuncInline,
        VulnerabilityFuncInline,
        DamageToLossFuncInline,
        CapacityCurveFuncInline,
    ]

    class Media:
        js = ("vulnerability/js/waterfall_show_hide.js", )

    #fieldsets = (
        #(None, {
            #'fields': ('name',
                       #'category',
                       #'taxonomy_type',
                       #'taxonomy_text',)
        #}),
        #('Functions', {
            #'fields': ('fragility_func',)
        #}),
        #('Reference / Documentation', {
            #'classes': ('collapse',),
            #'fields': ('authors',
                       #'article_title',
                       #'publication_conference_name',
                       #'year',
                       #'web_link',)
        #}),
        #(None, {
            #'fields': ('use_case_information',
                       #'general_comments',)
        #}),
    #)

    def is_cross_valid(self, form, formsets):
        print "CROSS-VALIDATING GENERAL INFORMATION"
        #if not form.is_valid():
            #form.errors['__all__'] = "Invalid form"
            #return False
        #fs_fragility_func = formset_by_rel_name(formsets,
                                                #'fragility_func')
        #fs_vulnerability_func = formset_by_rel_name(formsets,
                                                    #'vulnerability_func')
        #fs_damage_to_loss_func = formset_by_rel_name(formsets,
                                                     #'damage_to_loss_func')
        #fs_capacity_curve_func = formset_by_rel_name(formsets,
                                                     #'capacity_curve_func')
        #if (not fs_fragility_func and not fs_vulnerability_func
                #and not fs_damage_to_loss_func and not fs_capacity_curve_func):
            #form.errors['__all__'] = 'Required formsets not found'
            #return False
        #if form.cleaned_data['type_of_assessment'] == TA_FRAGILITY:
            #if formset_is_empty(fs_fragility_func):
                #error_add(
                    #fs_fragility_func, '__all__',
                    #"Mandatory fields when type of assessment is fragility")
                #return False
            #if not formset_is_empty(fs_vulnerability_func):
                #error_add(
                    #fs_vulnerability_func, '__all__',
                    #"Fragility function selected. "
                    #"These fields must be void")
                #return False
            #if not formset_is_empty(fs_damage_to_loss_func):
                #error_add(
                    #fs_damage_to_loss_func, '__all__',
                    #"Fragility function selected. "
                    #"These fields must be void")
                #return False
            #if not formset_is_empty(fs_capacity_curve_func):
                #error_add(
                    #fs_capacity_curve_func, '__all__',
                    #"Fragility function selected. "
                    #"These fields must be void")
                #return False
        #elif form.cleaned_data['type_of_assessment'] == TA_VULNERABILITY:
            #if formset_is_empty(fs_vulnerability_func):
                #error_add(
                    #fs_vulnerability_func, '__all__',
                    #"Mandatory fields when type of assessment is vulnerability")
                #return False
            #if not formset_is_empty(fs_fragility_func):
                #error_add(
                    #fs_fragility_func, '__all__',
                    #"Fragility function selected. "
                    #"These fields must be void")
                #return False
            #if not formset_is_empty(fs_damage_to_loss_func):
                #error_add(
                    #fs_damage_to_loss_func, '__all__',
                    #"Fragility function selected. "
                    #"These fields must be void")
                #return False
            #if not formset_is_empty(fs_capacity_curve_func):
                #error_add(
                    #fs_capacity_curve_func, '__all__',
                    #"Fragility function selected. "
                    #"These fields must be void")
                #return False
        #elif form.cleaned_data['type_of_assessment'] == TA_DAMAGE_TO_LOSS:
            #if formset_is_empty(fs_damage_to_loss_func):
                #error_add(
                    #fs_damage_to_loss_func, '__all__',
                    #"Mandatory fields when type of assessment is damage to loss")
                #return False
            #if not formset_is_empty(fs_fragility_func):
                #error_add(
                    #fs_fragility_func, '__all__',
                    #"Damage to loss function selected. "
                    #"These fields must be void")
                #return False
            #if not formset_is_empty(fs_vulnerability_func):
                #error_add(
                    #fs_vulnerability_func, '__all__',
                    #"Damage to loss function selected. "
                    #"These fields must be void")
                #return False
            #if not formset_is_empty(fs_capacity_curve_func):
                #error_add(
                    #fs_capacity_curve_func, '__all__',
                    #"Damage to loss function selected. "
                    #"These fields must be void")
                #return False
        #elif form.cleaned_data['type_of_assessment'] == TA_CAPACITY_CURVE:
            #if formset_is_empty(fs_capacity_curve_func):
                #error_add(
                    #fs_capacity_curve_func, '__all__',
                    #"Mandatory fields when type of assessment is capacity curve")
                #return False
            #if not formset_is_empty(fs_fragility_func):
                #error_add(
                    #fs_fragility_func, '__all__',
                    #"Capacity curve function selected. "
                    #"These fields must be void")
                #return False
            #if not formset_is_empty(fs_damage_to_loss_func):
                #error_add(
                    #fs_damage_to_loss_func, '__all__',
                    #"Capacity curve function selected. "
                    #"These fields must be void")
                #return False
            #if not formset_is_empty(fs_vulnerability_func):
                #error_add(
                    #fs_vulnerability_func, '__all__',
                    #"Capacity curve function selected. "
                    #"These fields must be void")
                #return False
        return True


admin.site.unregister(GeneralInformation)
admin.site.register(GeneralInformation, GeneralInformationAdmin)
