# Copyright (c) 2012-2013, GEM Foundation.
#
# This program is free software: you can redistribute it and/or modify
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from collections import OrderedDict
try:
    from django.contrib.admin.options import force_unicode
except ImportError:
    from django.utils.encoding import force_text as force_unicode
from django import VERSION as DJANGO_VERSION
from django.contrib import admin
from django.db import models, transaction, router
from django.views.decorators.csrf import csrf_protect
from django.utils.decorators import method_decorator
from django.utils.html import escape
from django.utils.translation import ugettext as _
from django import forms
from django.forms.util import ErrorList
from django.core.exceptions import PermissionDenied
from django.contrib.admin.util import unquote, get_deleted_objects
from django.template.response import TemplateResponse

from django.contrib.admin.helpers import InlineAdminFormSet, AdminForm
from django.http import Http404, HttpResponseRedirect
from django.core.urlresolvers import reverse
csrf_protect_m = method_decorator(csrf_protect)
from nested_inlines.admin import NestedModelAdmin, NestedStackedInline
from nested_inlines.helpers import AdminErrorList
from openquakeplatform.vulnerability.forms import PredictorVarForm
from openquakeplatform.vulnerability.forms import CC_PredictorVarForm
from openquakeplatform.vulnerability.forms import GeoApplicabilityForm
from openquakeplatform.vulnerability.forms import GeneralInformationForm


class OwnershipException(Exception):
    pass


class OwnedNestedInline(object):
    def get_readonly_fields(self, request, obj=None):
        if (request.user.is_superuser
            or request.user.groups.filter(
                name='vulnerability-admins').count()):
            return ()
        sup_ret = super(OwnedNestedInline, self).get_readonly_fields(request,
                                                                     obj)
        sup_ret = () if not sup_ret else sup_ret

        return tuple(set(sup_ret).union(set(('owner',))))

    def has_add_permission(self, request):
        if (request.user.is_superuser
            or request.user.groups.filter(
                name='vulnerability-admins').count()):
            self.exclude = (self.exclude or ()) + ('id',)
        return super(OwnedNestedInline, self).has_add_permission(request)


class OwnedAdmin(object):
    def change_view(self, request, *args, **kwargs):
        if '_clone' in request.POST:
            #  mangle request.POST to clean mandatory fields required
            #    by the special clone listed in vuln. specifications
            request.POST['name'] = ''
            request.POST[
                'capacity_curve_func-0-cc_predictor_var-0-data_pts_num'] = ''
            request.POST[
                'capacity_curve_func-0-cc_predictor_var-0-pred_var_val'] = ''
            request.POST[
                'capacity_curve_func-0-cc_predictor_var-0-resp_var_val'] = ''

            cleanup_entries = ['damage_to_loss_func-0-func_distr_dtl_discr',

                               'vulnerability_func-0-func_distr_vuln_cont',
                               'vulnerability_func-0-func_distr_vuln_discr',

                               'fragility_func-0-func_distr_frag_cont',
                               'fragility_func-0-func_distr_frag_discr']

            for cleanup_entry in cleanup_entries:
                request.POST[cleanup_entry+'-INITIAL_FORMS'] = 0

            for k, v in request.POST.items():
                for cleanup_entry in cleanup_entries:
                    if k.startswith(cleanup_entry + '-0-'):
                        request.POST[k] = ''

            request.POST['gem_was_clone'] = 'true'
        return super(OwnedAdmin, self).change_view(request, *args, **kwargs)

    def add_view(self, request, *args, **kwargs):
        if '_save' in request.POST:
            # custom logic for clone: mangle request.POST to clean mandatory
            # fields required the special clone listed in vuln. specifications
            if 'gem_was_clone' in request.POST:
                if request.POST['gem_was_clone'] == u'true':
                    if "_save" in request.POST:
                        del(request.POST['_save'])
                    # in the 'clone' case at this step we must reconverge to
                    # the 'saveasnew' case, else errors rise
                    request.POST['_saveasnew'] = u'saveasnew'
        return super(OwnedAdmin, self).add_view(request, *args, **kwargs)

    def save_model(self, request, obj, form, change):
        if change:
            if (not (request.user.is_superuser
                     or request.user.groups.filter(
                         name='vulnerability-admins').count())
                and "owner" in form.changed_data):
                raise OwnershipException(
                    "This object is owned by another user.")

            if not (obj.is_owned_by(request.user)
                    or request.user.is_superuser
                    or request.user.groups.filter(
                        name='vulnerability-admins').count()):
                raise OwnershipException(
                    "This object is owned by another user.")

        if not change and obj.owner_id is None:
            obj.owner_id = request.user.id
        else:
            if not obj.owner_id:
                raise OwnershipException(
                    "Inconsistent record %d, no owner id found" % request.pk)

        # ugly but works
        request._gem_custom = obj.owner_id
        super(OwnedAdmin, self).save_model(request, obj, form, change)

    def has_add_permission(self, request):
        if (request.user.is_superuser
            or request.user.groups.filter(
                name='vulnerability-admins').count()):
            self.exclude = (self.exclude or ()) + ('id',)
            self.save_as = True
        return super(OwnedAdmin, self).has_add_permission(request)

    def has_delete_permission(self, request, obj=None):
        if (not obj
            or (obj.is_owned_by(request.user)
                or request.user.is_superuser
                or request.user.groups.filter(
                    name='vulnerability-admins').count())):
            return True
        else:
            return False

    def get_readonly_fields(self, request, obj=None):
        if (request.user.is_superuser
            or request.user.groups.filter(
                name='vulnerability-admins').count()):
            return ()
        sup_ret = super(OwnedAdmin, self).get_readonly_fields(request, obj)
        sup_ret = () if not sup_ret else sup_ret

        return tuple(set(sup_ret).union(set(('owner',))))

    def save_formset(self, request, form, formset, change):
        """
        Given an inline formset save it to the database.
        """
        instances = formset.save(commit=False)
        for instance in instances:
            # cascading ownership from first ancestor just for normal users
            if (not (request.user.is_superuser
                     or request.user.groups.filter(
                         name='vulnerability-admins').count())):
                if hasattr(instance, "owner_id"):
                    instance.owner_id = request._gem_custom
            instance.save()
        formset.save_m2m()

        # https://docs.djangoproject.com/en/1.5/ref/contrib/admin/#django.contrib.admin.ModelAdmin.save_formset
        # and is different from the save_formset defined in
        # django_nested_inlines extension

        #iterate through the nested formsets and save them
        #skip formsets, where the parent is marked for deletion
        if formset.can_delete:
            deleted_forms = formset.deleted_forms
        else:
            deleted_forms = []
        for form in formset.forms:
            if hasattr(form, 'nested_formsets') and form not in deleted_forms:
                for nested_formset in form.nested_formsets:
                    self.save_formset(request, form, nested_formset, change)


class Hide2StaffAdmin(admin.ModelAdmin):
    def get_model_perms(self, request):
        """
        Return empty perms dict thus hiding the model from admin index.
        """

        if (request.user.is_superuser
            or request.user.groups.filter(
                name='vulnerability-admins').count()):
            return super(Hide2StaffAdmin, self).get_model_perms(request)

        return {}

from models import QRSEmpirical
from models import QRSAnalytical
from models import StatModel
from models import StatModelFittingMethod
from models import ModelFittingMethodAssumption
from models import FitAssessmentGoodness
from models import ProcConstrInt
from models import StatisticalInformation
from models import EmpiricalModelInfo
from models import AnalysisType
from models import AnalyticalModelInfo
from models import CC_AnalysisType
from models import CC_AnalyticalModelInfo
from models import Country
from models import GeoApplicability
from models import TaxonomyType
from models import CC_PredictorVar
from models import CapacityCurveFunc
from models import FuncDistrDTLDiscr
from models import DamageToLossFunc
from models import FuncDistrVulnCont
from models import FuncDistrVulnDiscr
from models import EvaluationOfIM
from models import PredictorVar
from models import VulnerabilityFunc
from models import FuncDistrFragCont
from models import FuncDistrFragDiscr
from models import EngineeringDemandPar
from models import FragilityFunc
from models import GeneralInformation

admin.site.register(QRSEmpirical, Hide2StaffAdmin)
admin.site.register(QRSAnalytical, Hide2StaffAdmin)
admin.site.register(StatModel, Hide2StaffAdmin)
admin.site.register(StatModelFittingMethod, Hide2StaffAdmin)
admin.site.register(ModelFittingMethodAssumption, Hide2StaffAdmin)
admin.site.register(FitAssessmentGoodness, Hide2StaffAdmin)
admin.site.register(ProcConstrInt, Hide2StaffAdmin)
admin.site.register(StatisticalInformation, Hide2StaffAdmin)
admin.site.register(EmpiricalModelInfo, Hide2StaffAdmin)
admin.site.register(AnalysisType, Hide2StaffAdmin)
admin.site.register(AnalyticalModelInfo, Hide2StaffAdmin)
admin.site.register(CC_AnalysisType, Hide2StaffAdmin)
admin.site.register(CC_AnalyticalModelInfo, Hide2StaffAdmin)
admin.site.register(Country, Hide2StaffAdmin)
admin.site.register(GeoApplicability, Hide2StaffAdmin)
admin.site.register(TaxonomyType, Hide2StaffAdmin)
admin.site.register(CC_PredictorVar, Hide2StaffAdmin)
admin.site.register(CapacityCurveFunc, Hide2StaffAdmin)
admin.site.register(FuncDistrDTLDiscr, Hide2StaffAdmin)
admin.site.register(DamageToLossFunc, Hide2StaffAdmin)
admin.site.register(FuncDistrVulnCont, Hide2StaffAdmin)
admin.site.register(FuncDistrVulnDiscr, Hide2StaffAdmin)
admin.site.register(EvaluationOfIM, Hide2StaffAdmin)
admin.site.register(PredictorVar, Hide2StaffAdmin)
admin.site.register(VulnerabilityFunc, Hide2StaffAdmin)
admin.site.register(FuncDistrFragCont, Hide2StaffAdmin)
admin.site.register(FuncDistrFragDiscr, Hide2StaffAdmin)
admin.site.register(EngineeringDemandPar, Hide2StaffAdmin)
admin.site.register(FragilityFunc, Hide2StaffAdmin)
admin.site.register(GeneralInformation, Hide2StaffAdmin)


from models import TA, TYPES_OF_ASSESSMENT, FDT


class NestedModelAdminCrossChecked(NestedModelAdmin):
    def is_cross_valid(self, form, formsets):
        return True

    # response_add and response_change methods use '_post' methods to redirect
    def response_post_save_add(self, request, obj):
        """
        Figure out where to redirect after the 'Save' button has been pressed
        when adding a new object.
        """
        if self.has_change_permission(request, None):
            post_url = "/vulnerability/view/%d/" % obj.id
            return HttpResponseRedirect(post_url)
        else:
            return super(NestedModelAdminCrossChecked, self).response_post_save_add(request, obj)

    def response_post_save_change(self, request, obj):
        """
        Figure out where to redirect after the 'Save' button has been pressed
        when editing an existing object.
        """
        if self.has_change_permission(request, None):
            post_url = "/vulnerability/view/%d/" % obj.id
            return HttpResponseRedirect(post_url)
        else:
            return super(NestedModelAdminCrossChecked, self).response_post_save_change(request, obj)

    # delete_view method has no post_delete method associated then override
    # it modifying the django.contrib.admin.options.ModelAdmin
    @csrf_protect_m
    @transaction.commit_on_success
    def delete_view(self, request, object_id, extra_context=None):
        "The 'delete' admin view for this model."
        opts = self.model._meta
        app_label = opts.app_label

        obj = self.get_object(request, unquote(object_id))
        type_of_assessment = obj.type_of_assessment
        if not self.has_delete_permission(request, obj):
            raise PermissionDenied

        if obj is None:
            raise Http404(
                _('%(name)s object with primary key %(key)r does not exist.') %
                {'name': force_unicode(opts.verbose_name),
                 'key': escape(object_id)})

        using = router.db_for_write(self.model)

        # Populate deleted_objects, a data structure of all related objects
        # that will also be deleted.
        (deleted_objects, perms_needed, protected) = get_deleted_objects(
            [obj], opts, request.user, self.admin_site, using)

        if request.POST:  # The user has already confirmed the deletion.
            if perms_needed:
                raise PermissionDenied
            obj_display = force_unicode(obj)
            self.log_deletion(request, obj, obj_display)
            self.delete_model(request, obj)

            self.message_user(
                request,
                _('The %(name)s "%(obj)s" was deleted successfully.') % {
                    'name': force_unicode(opts.verbose_name),
                    'obj': force_unicode(obj_display)})

            if not self.has_change_permission(request, None):
                return HttpResponseRedirect(
                    reverse('admin:index',
                            current_app=self.admin_site.name))
            post_url = "/vulnerability/list/?type_of_assessment=%d" % (
                type_of_assessment)

            return HttpResponseRedirect(post_url)

        object_name = force_unicode(opts.verbose_name)

        if perms_needed or protected:
            title = _("Cannot delete %(name)s") % {"name": object_name}
        else:
            title = _("Are you sure?")

        context = {
            "title": title,
            "object_name": object_name,
            "object": obj,
            "deleted_objects": deleted_objects,
            "perms_lacking": perms_needed,
            "protected": protected,
            "opts": opts,
            "app_label": app_label,
        }
        context.update(extra_context or {})

        return TemplateResponse(request, self.delete_confirmation_template or [
            "admin/%s/%s/delete_confirmation.html" % (
                app_label, opts.object_name.lower()),
            "admin/%s/delete_confirmation.html" % app_label,
            "admin/delete_confirmation.html"
        ], context, current_app=self.admin_site.name)

    @csrf_protect_m
    @transaction.commit_on_success
    def add_view(self, request, form_url='', extra_context=None):
        "The 'add' admin view for this model."
        model = self.model
        opts = model._meta

        if not self.has_add_permission(request):
            raise PermissionDenied

        ModelForm = self.get_form(request)
        formsets = []
        inline_instances = self.get_inline_instances(request, None)
        if request.method == 'POST':
            form = ModelForm(request.POST, request.FILES)
            if form.is_valid():
                new_object = self.save_form(request, form, change=False)
                form_validated = True
            else:
                form_validated = False
                new_object = self.model()
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(data=request.POST, files=request.FILES,
                                  instance=new_object,
                                  save_as_new="_saveasnew" in request.POST,
                                  prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)
            if (self.all_valid_with_nesting(formsets) and form_validated
                    and self.is_cross_valid(form, formsets)):
                self.save_model(request, new_object, form, False)
                self.save_related(request, form, formsets, False)
                self.log_addition(request, new_object)
                return self.response_add(request, new_object)
        else:
            # Prepare the dict of initial data from the request.
            # We have to special-case M2Ms as a list of comma-separated PKs.
            initial = dict(request.GET.items())
            for k in initial:
                try:
                    f = opts.get_field(k)
                except models.FieldDoesNotExist:
                    continue
                if isinstance(f, models.ManyToManyField):
                    initial[k] = initial[k].split(",")
            form = ModelForm(initial=initial)
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(instance=self.model(), prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)

        adminForm = AdminForm(form,
                              list(self.get_fieldsets(request)),
                              self.get_prepopulated_fields(request),
                              self.get_readonly_fields(request),
                              model_admin=self)
        media = self.media + adminForm.media

        inline_admin_formsets = []
        for inline, formset in zip(inline_instances, formsets):
            fieldsets = list(inline.get_fieldsets(request))
            readonly = list(inline.get_readonly_fields(request))
            prepopulated = dict(inline.get_prepopulated_fields(request))
            inline_admin_formset = InlineAdminFormSet(
                inline, formset, fieldsets, prepopulated,
                readonly, model_admin=self)
            inline_admin_formsets.append(inline_admin_formset)
            media = media + inline_admin_formset.media
            if inline.inlines:
                media = media + self.wrap_nested_inline_formsets(
                    request, inline, formset)

        context = {
            'title': _('Add %s') % force_unicode(opts.verbose_name),
            'adminform': adminForm,
            'is_popup': "_popup" in request.REQUEST,
            'show_delete': False,
            'media': media,
            'inline_admin_formsets': inline_admin_formsets,
            'errors': AdminErrorList(form, formsets),
            'app_label': opts.app_label,
            'django_version_lt_1_6': DJANGO_VERSION < (1, 6)
        }
        context.update(extra_context or {})
        return self.render_change_form(
            request, context, form_url=form_url, add=True)

    @csrf_protect_m
    @transaction.commit_on_success
    def change_view(self, request, object_id, form_url='', extra_context=None):
        gem_clone_btn = request.GET.get('gem_clone_btn', '')

        "The 'change' admin view for this model."
        model = self.model
        opts = model._meta

        obj = self.get_object(request, unquote(object_id))

        if not self.has_change_permission(request, obj):
            raise PermissionDenied

        if obj is None:
            raise Http404(
                _('%(name)s object with primary key %(key)r does not exist.')
                % {'name': force_unicode(opts.verbose_name),
                   'key': escape(object_id)})

        # in the '_clone' case at this step we must reconverge to
        # the '_saveasnew' case, else errors rise
        if (request.method == 'POST' and
            ("_saveasnew" in request.POST or "_clone" in request.POST)):
            if "_clone" in request.POST:
                del(request.POST['_clone'])
                request.POST['gem_was_clone'] = ''
                for key in request.POST:
                    if key.endswith('-INITIAL_FORMS'):
                        request.POST[key] = '0'
                request.POST['_saveasnew'] = 'saveasnew'
            return self.add_view(
                request,
                form_url=reverse(
                    'admin:%s_%s_add' % (opts.app_label, opts.module_name),
                    current_app=self.admin_site.name))

        ModelForm = self.get_form(request, obj)
        formsets = []
        inline_instances = self.get_inline_instances(request, obj)
        if request.method == 'POST':
            form = ModelForm(request.POST, request.FILES, instance=obj)
            if form.is_valid():
                form_validated = True
                new_object = self.save_form(request, form, change=True)
            else:
                form_validated = False
                new_object = obj
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request, new_object),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(request.POST, request.FILES,
                                  instance=new_object, prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)

            if (self.all_valid_with_nesting(formsets) and form_validated
                    and self.is_cross_valid(form, formsets)):
                self.save_model(request, new_object, form, True)
                self.save_related(request, form, formsets, True)
                change_message = self.construct_change_message(
                    request, form, formsets)
                self.log_change(request, new_object, change_message)
                return self.response_change(request, new_object)

        else:
            form = ModelForm(instance=obj)
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request, obj),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(instance=obj, prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)

        adminForm = AdminForm(form,
                              self.get_fieldsets(request, obj),
                              self.get_prepopulated_fields(request, obj),
                              self.get_readonly_fields(request, obj),
                              model_admin=self)
        media = self.media + adminForm.media

        inline_admin_formsets = []
        for inline, formset in zip(inline_instances, formsets):
            fieldsets = list(inline.get_fieldsets(request, obj))
            readonly = list(inline.get_readonly_fields(request, obj))
            prepopulated = dict(inline.get_prepopulated_fields(request, obj))
            inline_admin_formset = InlineAdminFormSet(
                inline, formset, fieldsets, prepopulated,
                readonly, model_admin=self)
            inline_admin_formsets.append(inline_admin_formset)
            media = media + inline_admin_formset.media
            if inline.inlines:
                media = media + self.wrap_nested_inline_formsets(
                    request, inline, formset)

        context = {
            'title': _('Change %s') % force_unicode(opts.verbose_name),
            'adminform': adminForm,
            'object_id': object_id,
            'original': obj,
            'is_popup': "_popup" in request.REQUEST,
            'media': media,
            'inline_admin_formsets': inline_admin_formsets,
            'errors': AdminErrorList(form, formsets),
            'app_label': opts.app_label,
            'django_version_lt_1_6': DJANGO_VERSION < (1, 6),
            'gem_clone_btn': gem_clone_btn == "true",
        }
        context.update(extra_context or {})
        return self.render_change_form(
            request, context, change=True, obj=obj, form_url=form_url)


qrs_analytical_fieldsets = (
    (None, {
        'fields': ('owner',)
    }),
    ('Data quality', {
        'fields': ('structural_details',
                   'model_completeness',
                   'seismic_demand', )
    }),
    ('Rationality', {
        'fields': ('analysis_type',
                   'limit_states_def',
                   'sampling_method',
                   'cross_validation',
                   'uncertainties_treatment')
    }),
    ('Documentation quality', {
        'fields': ('documentation_quality',
                   'documentation_type', )
    }),
    ('Representativeness', {
        'fields': ('typology_repr',
                   'site_specific',
                   'hazard_model', )
    }),
)


qrs_empirical_fieldsets = (
    (None, {
        'fields': ('owner',)
    }),
    ('Data quality', {
        'fields': ('data_quantity',
                   'constrained_categories',
                   'excitation_observation',
                   'damage_loss_observation',)
    }),
    ('Rationality', {
        'fields': ('hindcasting',
                   'cross_validation',
                   'first_principles',
                   'uncertainties_treatment',)
    }),
    ('Documentation quality', {
        'fields': ('documentation_quality',
                   'documentation_type', )
    }),
    ('Representativeness', {
        'fields': ('representativeness', ),
    }),
)


class CC_PredictorVarInline(OwnedNestedInline, NestedStackedInline):
    form = CC_PredictorVarForm
    model = CC_PredictorVar
    fk_name = 'capacity_curve_func'


class CC_AnalyticalModelInfoInline(OwnedNestedInline, NestedStackedInline):
    model = CC_AnalyticalModelInfo
    fk_name = 'capacity_curve_func'


class CapacityCurveFuncInline(OwnedNestedInline, NestedStackedInline):
    model = CapacityCurveFunc
    inlines = [
        CC_AnalyticalModelInfoInline,
        CC_PredictorVarInline,
    ]


class DL_FuncDistrDTLDiscrInline(OwnedNestedInline, NestedStackedInline):
    model = FuncDistrDTLDiscr
    fl_name = 'damage_to_loss_func'


class DamageToLossFuncInline(OwnedNestedInline, NestedStackedInline):
    model = DamageToLossFunc
    inlines = [
        DL_FuncDistrDTLDiscrInline,
    ]


class VU_AnalyticalModelInfoInline(OwnedNestedInline, NestedStackedInline):
    model = AnalyticalModelInfo
    exclude = ('fragility_func',)
    fk_name = 'vulnerability_func'


class VU_EmpiricalModelInfoInline(OwnedNestedInline, NestedStackedInline):
    model = EmpiricalModelInfo
    exclude = ('capacity_curve_func',
               'damage_to_loss_func',
               'fragility_func')
    fk_name = 'vulnerability_func'


class VU_StatisticalInformationInline(OwnedNestedInline, NestedStackedInline):
    model = StatisticalInformation
    exclude = ('fragility_func', )
    fk_name = 'vulnerability_func'


class VU_PredictorVarInline(OwnedNestedInline, NestedStackedInline):
    model = PredictorVar
    form = PredictorVarForm
    exclude = ('fragility_func',)
    fk_name = 'vulnerability_func'


class VU_FuncDistrVulnDiscrInline(OwnedNestedInline, NestedStackedInline):
    model = FuncDistrVulnDiscr
    fk_name = 'vulnerability_func'


class VU_FuncDistrVulnContInline(OwnedNestedInline, NestedStackedInline):
    model = FuncDistrVulnCont
    fk_name = 'vulnerability_func'


def formset_by_rel_name(formsets, rel_name):
    for formset in formsets:
        if formset.rel_name == rel_name:
            return formset
    return None


def formset_by_parent_and_rel_name(parent_formset, rel_name):
    try:
        nested_formsets = parent_formset.forms[0].nested_formsets
        return formset_by_rel_name(nested_formsets, rel_name)
    except Exception:
        return None


class VU_QRSAnalyticalInline(OwnedNestedInline, NestedStackedInline):
    model = QRSAnalytical
    exclude = ('fragility_func', )
    fk_name = 'vulnerability_func'
    fieldsets = qrs_analytical_fieldsets


class VU_QRSEmpiricalInline(OwnedNestedInline, NestedStackedInline):
    model = QRSEmpirical
    exclude = ('fragility_func', )
    fk_name = 'vulnerability_func'
    fieldsets = qrs_empirical_fieldsets


def formset_is_empty(formset):
    if not hasattr(formset, 'cleaned_data'):
        return True
    if len(formset.cleaned_data) == 0:
        return True
    if not formset.cleaned_data[0]:
        return True
    if ('DELETE' in formset.cleaned_data[0]
            and formset.cleaned_data[0]['DELETE'] is True
            and formset.can_delete is True):
        return True
    return False


def error_add(formset, field_name, desc):
    if not hasattr(formset, 'forms'):
        return False
    if len(formset.forms) != 1:
        return False
    if not hasattr(formset.forms[0], '_errors'):
        return False
    formset.forms[0]._errors[field_name] = ErrorList([desc])
    return True


class VulnerabilityFuncInline(OwnedNestedInline, NestedStackedInline):
    model = VulnerabilityFunc
    inlines = [
        VU_AnalyticalModelInfoInline,
        VU_EmpiricalModelInfoInline,
        VU_PredictorVarInline,
        VU_FuncDistrVulnDiscrInline,
        VU_FuncDistrVulnContInline,
        VU_StatisticalInformationInline,
        VU_QRSAnalyticalInline,
        VU_QRSEmpiricalInline,
    ]


class FR_AnalyticalModelInfoInline(OwnedNestedInline, NestedStackedInline):
    model = AnalyticalModelInfo
    exclude = ('vulnerability_func',)
    fk_name = 'fragility_func'


class FR_EmpiricalModelInfoInline(OwnedNestedInline, NestedStackedInline):
    model = EmpiricalModelInfo
    exclude = ('capacity_curve_func',
               'damage_to_loss_func',
               'vulnerability_func')
    fk_name = 'fragility_func'


class FR_StatisticalInformationInline(OwnedNestedInline, NestedStackedInline):
    model = StatisticalInformation
    exclude = ('vulnerability_func', )
    fk_name = 'fragility_func'


class FR_PredictorVarInline(OwnedNestedInline, NestedStackedInline):
    model = PredictorVar
    form = PredictorVarForm
    exclude = ('vulnerability_func',)
    fk_name = 'fragility_func'


class FR_FuncDistrFragContInline(OwnedNestedInline, NestedStackedInline):
    model = FuncDistrFragCont
    fk_name = 'fragility_func'


class FR_FuncDistrFragDiscrInline(OwnedNestedInline, NestedStackedInline):
    model = FuncDistrFragDiscr
    fk_name = 'fragility_func'


class FR_QRSEmpiricalInline(OwnedNestedInline, NestedStackedInline):
    model = QRSEmpirical
    exclude = ('vulnerability_func', )
    fk_name = 'fragility_func'
    fieldsets = qrs_empirical_fieldsets


class FR_QRSAnalyticalInline(OwnedNestedInline, NestedStackedInline):
    model = QRSAnalytical
    exclude = ('vulnerability_func', )
    fk_name = 'fragility_func'
    fieldsets = qrs_analytical_fieldsets


class FragilityFuncInline(OwnedNestedInline, NestedStackedInline):
    model = FragilityFunc
    inlines = [
        FR_AnalyticalModelInfoInline,
        FR_EmpiricalModelInfoInline,
        FR_PredictorVarInline,
        FR_FuncDistrFragContInline,
        FR_FuncDistrFragDiscrInline,
        FR_StatisticalInformationInline,
        FR_QRSEmpiricalInline,
        FR_QRSAnalyticalInline,
    ]


class GeoApplicability(OwnedNestedInline, NestedStackedInline):
    model = GeoApplicability
    form = GeoApplicabilityForm


class GeneralInformationAdmin(OwnedAdmin, NestedModelAdminCrossChecked):
    form = GeneralInformationForm
    save_as = True
    save_on_top = True
    search_fields = ['name']
    inlines = [
        FragilityFuncInline,
        VulnerabilityFuncInline,
        DamageToLossFuncInline,
        CapacityCurveFuncInline,
        GeoApplicability,
    ]

    exclude = ('cart',)
    list_filter = ('category',
                   'type_of_assessment',
                   'geo_applicability__countries__region', )

    class Media:
        js = ("vulnerability/js/waterfall_show_hide.js", )
        css = {"all": ("vulnerability/css/admin_custom.css",)}

    #fieldsets = (
        #(None, {
            #'fields': ('name',
                       #'category',
                       #'taxonomy_type',
                       #'taxonomy_text',)
        #}),
        #('Functions', {
            #'fields': ('fragility_func',)
        #}),
        #('Reference / Documentation', {
            #'classes': ('collapse',),
            #'fields': ('authors',
                       #'article_title',
                       #'publication_conference_name',
                       #'year',
                       #'web_link',)
        #}),
        #(None, {
            #'fields': ('use_case_information',
                       #'general_comments',)
        #}),
    #)

    def is_cross_valid(self, form, formsets):
        any_error_found = False
        errors = form._errors.setdefault(forms.forms.NON_FIELD_ERRORS,
                                         forms.util.ErrorList())
        fs_geo_applicability = formset_by_rel_name(formsets,
                                                   'geo_applicability')
        fs_fragility_func = formset_by_rel_name(formsets,
                                                'fragility_func')
        fs_vulnerability_func = formset_by_rel_name(formsets,
                                                    'vulnerability_func')
        fs_damage_to_loss_func = formset_by_rel_name(formsets,
                                                     'damage_to_loss_func')
        fs_capacity_curve_func = formset_by_rel_name(formsets,
                                                     'capacity_curve_func')
        if formset_is_empty(fs_geo_applicability):
            error_add(
                fs_geo_applicability, '__all__',
                "Mandatory fields")
            any_error_found = True

        if (not fs_fragility_func and not fs_vulnerability_func
                and not fs_damage_to_loss_func and not fs_capacity_curve_func):
            errors.append('Required formsets not found')
            any_error_found = True

        type_of_assessment_idx = (form.cleaned_data['type_of_assessment']
                                  if 'type_of_assessment' in form.cleaned_data
                                  else None)

        # FRAGILITY
        if type_of_assessment_idx == TA.FRAGILITY:
            if formset_is_empty(fs_fragility_func):
                error_add(
                    fs_fragility_func, '__all__',
                    "Mandatory fields")
                any_error_found = True
            if not formset_is_empty(fs_vulnerability_func):
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Fragility function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.VULNERABILITY)
                any_error_found = True
            if not formset_is_empty(fs_damage_to_loss_func):
                error_add(
                    fs_damage_to_loss_func, '__all__',
                    "Fragility function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.DAMAGE_TO_LOSS)
                any_error_found = True
            if not formset_is_empty(fs_capacity_curve_func):
                error_add(
                    fs_capacity_curve_func, '__all__',
                    "Fragility function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.CAPACITY_CURVE)
                any_error_found = True
            fs_predictor_var = get_predictor_var(fs_fragility_func)
            if not fs_predictor_var:
                error_add(
                    fs_fragility_func, '__all__',
                    "Malformed submission: predictor_var fieldset not found")
                any_error_found = True

            if not check_func_distr_type(fs_fragility_func, 'func_distr_frag'):
                any_error_found = True

        # VULNERABILITY
        elif type_of_assessment_idx == TA.VULNERABILITY:
            if formset_is_empty(fs_vulnerability_func):
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Mandatory fields")
                any_error_found = True
            if not formset_is_empty(fs_fragility_func):
                error_add(
                    fs_fragility_func, '__all__',
                    "Vulnerability function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.FRAGILITY)
                any_error_found = True
            if not formset_is_empty(fs_damage_to_loss_func):
                error_add(
                    fs_damage_to_loss_func, '__all__',
                    "Vulnerability function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.DAMAGE_TO_LOSS)
                any_error_found = True
            if not formset_is_empty(fs_capacity_curve_func):
                error_add(
                    fs_capacity_curve_func, '__all__',
                    "Vulnerability function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.CAPACITY_CURVE)
                any_error_found = True

            fs_predictor_var = get_predictor_var(fs_vulnerability_func)
            if not fs_predictor_var:
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Malformed submission: predictor_var fieldset not found")
                any_error_found = True
            if not check_func_distr_type(
                    fs_vulnerability_func, 'func_distr_vuln'):
                any_error_found = True

        # DAMAGE TO LOSS
        elif type_of_assessment_idx == TA.DAMAGE_TO_LOSS:
            if formset_is_empty(fs_damage_to_loss_func):
                error_add(
                    fs_damage_to_loss_func, '__all__',
                    "Mandatory fields")
                any_error_found = True
            if not formset_is_empty(fs_fragility_func):
                error_add(
                    fs_fragility_func, '__all__',
                    "Damage to loss function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.FRAGILITY)
                any_error_found = True
            if not formset_is_empty(fs_vulnerability_func):
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Damage to loss function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.VULNERABILITY)
                any_error_found = True
            if not formset_is_empty(fs_capacity_curve_func):
                error_add(
                    fs_capacity_curve_func, '__all__',
                    "Damage to loss function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.CAPACITY_CURVE)
                any_error_found = True
            fs_func_distr_dtl_discr = formset_by_parent_and_rel_name(
                fs_damage_to_loss_func, 'func_distr_dtl_discr')
            if formset_is_empty(fs_func_distr_dtl_discr):
                error_add(
                    fs_func_distr_dtl_discr, '__all__',
                    "Mandatory fields")
                any_error_found = True

        # CAPACITY CURVE
        elif type_of_assessment_idx == TA.CAPACITY_CURVE:
            if formset_is_empty(fs_capacity_curve_func):
                error_add(
                    fs_capacity_curve_func, '__all__',
                    "Mandatory fields")
                any_error_found = True
            if not formset_is_empty(fs_fragility_func):
                error_add(
                    fs_fragility_func, '__all__',
                    "Capacity curve function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.FRAGILITY)
                any_error_found = True
            if not formset_is_empty(fs_damage_to_loss_func):
                error_add(
                    fs_damage_to_loss_func, '__all__',
                    "Capacity curve function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.DAMAGE_TO_LOSS)
                any_error_found = True
            if not formset_is_empty(fs_vulnerability_func):
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Capacity curve function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.VULNERABILITY)
                any_error_found = True
            fs_cc_predictor_var = formset_by_parent_and_rel_name(
                fs_capacity_curve_func, 'cc_predictor_var')
            if formset_is_empty(fs_cc_predictor_var):
                error_add(
                    fs_cc_predictor_var, '__all__',
                    "Mandatory fields")
                any_error_found = True

        if any_error_found:
            return False
        else:
            return True


def not_empty_error_message(errors, current_TA_idx, not_empty_TA_idx):
    errors.append(
        'The current type of assessment is %(current)s, '
        'but you have inserted data for the %(not_empty)s type too. '
        'If %(current)s type is correct, please select the %(not_empty)s '
        'type, clean the related information, then re-select %(current)s '
        'type. If the %(current)s type is wrong, please clean its related '
        'data before switching to %(not_empty)s type.' % {
            'current': OrderedDict(TYPES_OF_ASSESSMENT)[current_TA_idx],
            'not_empty': OrderedDict(TYPES_OF_ASSESSMENT)[not_empty_TA_idx]
            })


admin.site.unregister(GeneralInformation)
admin.site.register(GeneralInformation, GeneralInformationAdmin)


def get_predictor_var(parent_fieldset):
    fs_predictor_var = formset_by_parent_and_rel_name(
        parent_fieldset, 'predictor_var')
    if formset_is_empty(fs_predictor_var):
        error_add(
            fs_predictor_var, '__all__',
            "Mandatory fields")
        return False
    return fs_predictor_var


def check_func_distr_type(parent_fieldset, partial_rel_name):
    fs_func_distr_discr = formset_by_parent_and_rel_name(
        parent_fieldset, partial_rel_name + '_discr')
    fs_func_distr_cont = formset_by_parent_and_rel_name(
        parent_fieldset, partial_rel_name + '_cont')
    parent_form = parent_fieldset.forms[0]
    if ('func_distr_type' in parent_form.cleaned_data and
            parent_form.cleaned_data['func_distr_type'] == FDT.DISCRETE):
        if formset_is_empty(fs_func_distr_discr):
            error_add(
                fs_func_distr_discr, '__all__',
                "Mandatory fields")
            return False
    elif ('func_distr_type' in parent_form.cleaned_data and
            parent_form.cleaned_data['func_distr_type'] == FDT.CONTINUOUS):
        if formset_is_empty(fs_func_distr_cont):
            error_add(
                fs_func_distr_cont, '__all__',
                "Mandatory fields")
            return False
    return True
