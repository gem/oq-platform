# Copyright (c) 2012-2013, GEM Foundation.
#
# This program is free software: you can redistribute it and/or modify
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

try:
    from django.contrib.admin.options import force_unicode
except ImportError:
    from django.utils.encoding import force_text as force_unicode
from django import VERSION as DJANGO_VERSION
from django.contrib import admin
from django.db import models, transaction
from django.views.decorators.csrf import csrf_protect
from django.utils.decorators import method_decorator
from django.forms.util import ErrorList
from django.utils.translation import ugettext as _
from django.core.exceptions import PermissionDenied
from django.contrib.admin.util import unquote
from django.contrib.admin.helpers import InlineAdminFormSet, AdminForm
from django.http import Http404
from django.utils.html import escape
from django.core.urlresolvers import reverse
csrf_protect_m = method_decorator(csrf_protect)
from nested_inlines.admin import NestedModelAdmin, NestedStackedInline
from nested_inlines.helpers import AdminErrorList
from openquakeplatform.vulnerability.forms import PredictorVarForm
from openquakeplatform.vulnerability.forms import CC_PredictorVarForm
from openquakeplatform.vulnerability.forms import GeoApplicabilityForm


from models import QRSEmpirical
from models import QRSAnalytical
from models import StatModel
from models import StatModelFittingMethod
from models import ModelFittingMethodAssumption
from models import FitAssessmentGoodness
from models import ProcConstrInt
from models import StatisticalInformation
from models import EmpiricalModelInfo
from models import AnalysisType
from models import AnalyticalModelInfo
from models import Country
from models import GeoApplicability
from models import TaxonomyType
from models import FuncDistrShape
from models import CC_PredictorVar
from models import CapacityCurveFunc
from models import FuncDistrDTLDiscr
from models import DamageToLossFunc
from models import FuncDistrVulnCont
from models import FuncDistrVulnDiscr
from models import EvaluationOfIM
from models import PredictorVar
from models import VulnerabilityFunc
from models import FuncDistrFragCont
from models import FuncDistrFragDiscr
from models import EngineeringDemandPar
from models import FragilityFunc
from models import GeneralInformation

admin.site.register(QRSEmpirical)
admin.site.register(QRSAnalytical)
admin.site.register(StatModel)
admin.site.register(StatModelFittingMethod)
admin.site.register(ModelFittingMethodAssumption)
admin.site.register(FitAssessmentGoodness)
admin.site.register(ProcConstrInt)
admin.site.register(StatisticalInformation)
admin.site.register(EmpiricalModelInfo)
admin.site.register(AnalysisType)
admin.site.register(AnalyticalModelInfo)
admin.site.register(Country)
admin.site.register(GeoApplicability)
admin.site.register(TaxonomyType)
admin.site.register(FuncDistrShape)
admin.site.register(CC_PredictorVar)
admin.site.register(CapacityCurveFunc)
admin.site.register(FuncDistrDTLDiscr)
admin.site.register(DamageToLossFunc)
admin.site.register(FuncDistrVulnCont)
admin.site.register(FuncDistrVulnDiscr)
admin.site.register(EvaluationOfIM)
admin.site.register(PredictorVar)
admin.site.register(VulnerabilityFunc)
admin.site.register(FuncDistrFragCont)
admin.site.register(FuncDistrFragDiscr)
admin.site.register(EngineeringDemandPar)
admin.site.register(FragilityFunc)
admin.site.register(GeneralInformation)


from models import MOE, TA, FDT


class NestedModelAdminCrossChecked(NestedModelAdmin):
    def is_cross_valid(self, form, formsets):
        return True

    @csrf_protect_m
    @transaction.commit_on_success
    def add_view(self, request, form_url='', extra_context=None):
        "The 'add' admin view for this model."
        model = self.model
        opts = model._meta

        if not self.has_add_permission(request):
            raise PermissionDenied

        ModelForm = self.get_form(request)
        formsets = []
        inline_instances = self.get_inline_instances(request, None)
        if request.method == 'POST':
            form = ModelForm(request.POST, request.FILES)
            if form.is_valid():
                new_object = self.save_form(request, form, change=False)
                form_validated = True
            else:
                form_validated = False
                new_object = self.model()
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(data=request.POST, files=request.FILES,
                                  instance=new_object,
                                  save_as_new="_saveasnew" in request.POST,
                                  prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)
            if (self.all_valid_with_nesting(formsets) and form_validated
                    and self.is_cross_valid(form, formsets)):
                self.save_model(request, new_object, form, False)
                self.save_related(request, form, formsets, False)
                self.log_addition(request, new_object)
                return self.response_add(request, new_object)
        else:
            # Prepare the dict of initial data from the request.
            # We have to special-case M2Ms as a list of comma-separated PKs.
            initial = dict(request.GET.items())
            for k in initial:
                try:
                    f = opts.get_field(k)
                except models.FieldDoesNotExist:
                    continue
                if isinstance(f, models.ManyToManyField):
                    initial[k] = initial[k].split(",")
            form = ModelForm(initial=initial)
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(instance=self.model(), prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)

        adminForm = AdminForm(form,
                              list(self.get_fieldsets(request)),
                              self.get_prepopulated_fields(request),
                              self.get_readonly_fields(request),
                              model_admin=self)
        media = self.media + adminForm.media

        inline_admin_formsets = []
        for inline, formset in zip(inline_instances, formsets):
            fieldsets = list(inline.get_fieldsets(request))
            readonly = list(inline.get_readonly_fields(request))
            prepopulated = dict(inline.get_prepopulated_fields(request))
            inline_admin_formset = InlineAdminFormSet(
                inline, formset, fieldsets, prepopulated,
                readonly, model_admin=self)
            inline_admin_formsets.append(inline_admin_formset)
            media = media + inline_admin_formset.media
            if inline.inlines:
                media = media + self.wrap_nested_inline_formsets(
                    request, inline, formset)

        context = {
            'title': _('Add %s') % force_unicode(opts.verbose_name),
            'adminform': adminForm,
            'is_popup': "_popup" in request.REQUEST,
            'show_delete': False,
            'media': media,
            'inline_admin_formsets': inline_admin_formsets,
            'errors': AdminErrorList(form, formsets),
            'app_label': opts.app_label,
            'django_version_lt_1_6': DJANGO_VERSION < (1, 6)
        }
        context.update(extra_context or {})
        return self.render_change_form(
            request, context, form_url=form_url, add=True)

    @csrf_protect_m
    @transaction.commit_on_success
    def change_view(self, request, object_id, form_url='', extra_context=None):
        "The 'change' admin view for this model."
        model = self.model
        opts = model._meta

        obj = self.get_object(request, unquote(object_id))

        if not self.has_change_permission(request, obj):
            raise PermissionDenied

        if obj is None:
            raise Http404(
                _('%(name)s object with primary key %(key)r does not exist.')
                % {'name': force_unicode(opts.verbose_name),
                   'key': escape(object_id)})

        if request.method == 'POST' and "_saveasnew" in request.POST:
            return self.add_view(
                request,
                form_url=reverse(
                    'admin:%s_%s_add' % (opts.app_label, opts.module_name),
                    current_app=self.admin_site.name))

        ModelForm = self.get_form(request, obj)
        formsets = []
        inline_instances = self.get_inline_instances(request, obj)
        if request.method == 'POST':
            form = ModelForm(request.POST, request.FILES, instance=obj)
            if form.is_valid():
                form_validated = True
                new_object = self.save_form(request, form, change=True)
            else:
                form_validated = False
                new_object = obj
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request, new_object),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(request.POST, request.FILES,
                                  instance=new_object, prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)

            if (self.all_valid_with_nesting(formsets) and form_validated
                    and self.is_cross_valid(form, formsets)):
                self.save_model(request, new_object, form, True)
                self.save_related(request, form, formsets, True)
                change_message = self.construct_change_message(
                    request, form, formsets)
                self.log_change(request, new_object, change_message)
                return self.response_change(request, new_object)

        else:
            form = ModelForm(instance=obj)
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request, obj),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(instance=obj, prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)

        adminForm = AdminForm(form,
                              self.get_fieldsets(request, obj),
                              self.get_prepopulated_fields(request, obj),
                              self.get_readonly_fields(request, obj),
                              model_admin=self)
        media = self.media + adminForm.media

        inline_admin_formsets = []
        for inline, formset in zip(inline_instances, formsets):
            fieldsets = list(inline.get_fieldsets(request, obj))
            readonly = list(inline.get_readonly_fields(request, obj))
            prepopulated = dict(inline.get_prepopulated_fields(request, obj))
            inline_admin_formset = InlineAdminFormSet(
                inline, formset, fieldsets, prepopulated,
                readonly, model_admin=self)
            inline_admin_formsets.append(inline_admin_formset)
            media = media + inline_admin_formset.media
            if inline.inlines:
                media = media + self.wrap_nested_inline_formsets(
                    request, inline, formset)

        context = {
            'title': _('Change %s') % force_unicode(opts.verbose_name),
            'adminform': adminForm,
            'object_id': object_id,
            'original': obj,
            'is_popup': "_popup" in request.REQUEST,
            'media': media,
            'inline_admin_formsets': inline_admin_formsets,
            'errors': AdminErrorList(form, formsets),
            'app_label': opts.app_label,
            'django_version_lt_1_6': DJANGO_VERSION < (1, 6)
        }
        context.update(extra_context or {})
        return self.render_change_form(
            request, context, change=True, obj=obj, form_url=form_url)


qrs_analytical_fieldsets = (
    ('Data quality', {
        'classes': ('collapse',),
        'fields': ('structural_details',
                   'model_completeness',
                   'seismic_demand', )
    }),
    ('Rationality', {
        'classes': ('collapse',),
        'fields': ('analysis_type',
                   'limit_states_def',
                   'sampling_method',
                   'cross_validation',
                   'uncertainties_treatment')
    }),
    ('Documentation quality', {
        'classes': ('collapse',),
        'fields': ('documentation_quality',
                   'documentation_type', )
    }),
    ('Representativeness', {
        'classes': ('collapse',),
        'fields': ('typology_repr',
                   'site_specific',
                   'hazard_model', )
    }),
)


qrs_empirical_fieldsets = (
    ('Data quality', {
        'classes': ('collapse',),
        'fields': ('data_quantity',
                   'constrained_categories',
                   'excitation_observation',
                   'damage_loss_observation',)
    }),
    ('Rationality', {
        'classes': ('collapse',),
        'fields': ('hindcasting',
                   'cross_validation',
                   'first_principles',
                   'uncertainties_treatment',)
    }),
    ('Documentation quality', {
        'classes': ('collapse',),
        'fields': ('documentation_quality',
                   'documentation_type', )
    }),
    ('Representativeness', {
        'classes': ('collapse',),
        'fields': ('representativeness', ),
    }),
)


class CC_PredictorVarInline(NestedStackedInline):
    form = CC_PredictorVarForm
    model = CC_PredictorVar
    fk_name = 'capacity_curve_func'


class CC_AnalyticalModelInfoInline(NestedStackedInline):
    model = AnalyticalModelInfo
    exclude = ('damage_to_loss_func',
               'fragility_func',
               'vulnerability_func')
    fk_name = 'capacity_curve_func'


class CapacityCurveFuncInline(NestedStackedInline):
    model = CapacityCurveFunc
    inlines = [
        CC_AnalyticalModelInfoInline,
        CC_PredictorVarInline,
    ]


#admin.site.unregister(CapacityCurveFunc)
#admin.site.register(CapacityCurveFunc, CapacityCurveFuncInline)


class DL_FuncDistrDTLDiscrInline(NestedStackedInline):
    model = FuncDistrDTLDiscr
    fl_name = 'damage_to_loss_func'


class DamageToLossFuncInline(NestedStackedInline):
    model = DamageToLossFunc
    inlines = [
        DL_FuncDistrDTLDiscrInline,
    ]


#admin.site.unregister(DamageToLossFunc)
#admin.site.register(DamageToLossFunc, DamageToLossFuncInline)


class VU_AnalyticalModelInfoInline(NestedStackedInline):
    model = AnalyticalModelInfo
    exclude = ('capacity_curve_func',
               'damage_to_loss_func',
               'fragility_func')
    fk_name = 'vulnerability_func'


class VU_EmpiricalModelInfoInline(NestedStackedInline):
    model = EmpiricalModelInfo
    exclude = ('capacity_curve_func',
               'damage_to_loss_func',
               'fragility_func')
    fk_name = 'vulnerability_func'


class VU_StatisticalInformationInline(NestedStackedInline):
    model = StatisticalInformation
    exclude = ('fragility_func', )
    fk_name = 'vulnerability_func'


class VU_PredictorVarInline(NestedStackedInline):
    model = PredictorVar
    form = PredictorVarForm
    exclude = ('fragility_func',)
    fk_name = 'vulnerability_func'


class VU_FuncDistrVulnDiscrInline(NestedStackedInline):
    model = FuncDistrVulnDiscr
    fk_name = 'vulnerability_func'


class VU_FuncDistrVulnContInline(NestedStackedInline):
    model = FuncDistrVulnCont
    fk_name = 'vulnerability_func'


def formset_by_rel_name(formsets, rel_name):
    for formset in formsets:
        if formset.rel_name == rel_name:
            return formset
    return None


def formset_by_parent_and_rel_name(parent_formset, rel_name):
    try:
        nested_formsets = parent_formset.forms[0].nested_formsets
        return formset_by_rel_name(nested_formsets, rel_name)
    except Exception:
        return None


class VU_QRSAnalyticalInline(NestedStackedInline):
    model = QRSAnalytical
    exclude = ('fragility_func', )
    fk_name = 'vulnerability_func'
    fieldsets = qrs_analytical_fieldsets


class VU_QRSEmpiricalInline(NestedStackedInline):
    model = QRSEmpirical
    exclude = ('fragility_func', )
    fk_name = 'vulnerability_func'
    fieldsets = qrs_empirical_fieldsets


def formset_is_empty(formset):
    #print "1 - formset is empty"
    if not hasattr(formset, 'cleaned_data'):
        return True
    #print "2 - formset is empty"
    if len(formset.cleaned_data) == 0:
        return True
    #print "3 - formset is empty"
    if not formset.cleaned_data[0]:
        return True
    #print "4 - formset is empty"
    if ('DELETE' in formset.cleaned_data[0]
            and formset.cleaned_data[0]['DELETE'] is True
            and formset.can_delete is True):
        return True
    #print "5 - formset is empty"
    return False


def error_add(formset, field_name, desc):
    if not hasattr(formset, 'forms'):
        return False
    if len(formset.forms) != 1:
        return False
    if not hasattr(formset.forms[0], '_errors'):
        return False
    formset.forms[0]._errors[field_name] = ErrorList([desc])


class VulnerabilityFuncInline(NestedStackedInline):
    model = VulnerabilityFunc
    inlines = [
        VU_AnalyticalModelInfoInline,
        VU_EmpiricalModelInfoInline,
        VU_PredictorVarInline,
        VU_FuncDistrVulnDiscrInline,
        VU_FuncDistrVulnContInline,
        VU_StatisticalInformationInline,
        VU_QRSAnalyticalInline,
        VU_QRSEmpiricalInline,
    ]

#admin.site.unregister(VulnerabilityFunc)
#admin.site.register(VulnerabilityFunc, VulnerabilityFuncInline)


class FR_AnalyticalModelInfoInline(NestedStackedInline):
    model = AnalyticalModelInfo
    exclude = ('capacity_curve_func',
               'damage_to_loss_func',
               'vulnerability_func')
    fk_name = 'fragility_func'


class FR_EmpiricalModelInfoInline(NestedStackedInline):
    model = EmpiricalModelInfo
    exclude = ('capacity_curve_func',
               'damage_to_loss_func',
               'vulnerability_func')
    fk_name = 'fragility_func'


class FR_StatisticalInformationInline(NestedStackedInline):
    model = StatisticalInformation
    exclude = ('vulnerability_func', )
    fk_name = 'fragility_func'


class FR_PredictorVarInline(NestedStackedInline):
    model = PredictorVar
    form = PredictorVarForm
    exclude = ('vulnerability_func',)
    fk_name = 'fragility_func'


class FR_FuncDistrFragContInline(NestedStackedInline):
    model = FuncDistrFragCont
    fk_name = 'fragility_func'


class FR_FuncDistrFragDiscrInline(NestedStackedInline):
    model = FuncDistrFragDiscr
    fk_name = 'fragility_func'


class FR_QRSEmpiricalInline(NestedStackedInline):
    model = QRSEmpirical
    exclude = ('vulnerability_func', )
    fk_name = 'fragility_func'
    fieldsets = qrs_empirical_fieldsets


class FR_QRSAnalyticalInline(NestedStackedInline):
    model = QRSAnalytical
    exclude = ('vulnerability_func', )
    fk_name = 'fragility_func'
    fieldsets = qrs_analytical_fieldsets


class FragilityFuncInline(NestedStackedInline):
    model = FragilityFunc
    inlines = [
        FR_AnalyticalModelInfoInline,
        FR_EmpiricalModelInfoInline,
        FR_PredictorVarInline,
        FR_FuncDistrFragContInline,
        FR_FuncDistrFragDiscrInline,
        FR_StatisticalInformationInline,
        FR_QRSEmpiricalInline,
        FR_QRSAnalyticalInline,
    ]


#admin.site.unregister(FragilityFunc)
#admin.site.register(FragilityFunc, FragilityFuncInline)


class GeoApplicability(NestedStackedInline):
    model = GeoApplicability
    form = GeoApplicabilityForm


class GeneralInformationAdmin(NestedModelAdminCrossChecked):
    save_as = True
    inlines = [
        FragilityFuncInline,
        VulnerabilityFuncInline,
        DamageToLossFuncInline,
        CapacityCurveFuncInline,
        GeoApplicability,
    ]

    class Media:
        js = ("vulnerability/js/waterfall_show_hide.js", )

    #fieldsets = (
        #(None, {
            #'fields': ('name',
                       #'category',
                       #'taxonomy_type',
                       #'taxonomy_text',)
        #}),
        #('Functions', {
            #'fields': ('fragility_func',)
        #}),
        #('Reference / Documentation', {
            #'classes': ('collapse',),
            #'fields': ('authors',
                       #'article_title',
                       #'publication_conference_name',
                       #'year',
                       #'web_link',)
        #}),
        #(None, {
            #'fields': ('use_case_information',
                       #'general_comments',)
        #}),
    #)

    def is_cross_valid(self, form, formsets):
        if not form.is_valid():
            form.errors['__all__'] = "Invalid form"
            return False
        fs_geo_applicability = formset_by_rel_name(formsets,
                                                   'geo_applicability')
        fs_fragility_func = formset_by_rel_name(formsets,
                                                'fragility_func')
        fs_vulnerability_func = formset_by_rel_name(formsets,
                                                    'vulnerability_func')
        fs_damage_to_loss_func = formset_by_rel_name(formsets,
                                                     'damage_to_loss_func')
        fs_capacity_curve_func = formset_by_rel_name(formsets,
                                                     'capacity_curve_func')
        if formset_is_empty(fs_geo_applicability):
            error_add(
                fs_geo_applicability, '__all__',
                "This section is mandatory")
            return False

        if (not fs_fragility_func and not fs_vulnerability_func
                and not fs_damage_to_loss_func and not fs_capacity_curve_func):
            form.errors['__all__'] = 'Required formsets not found'
            return False

        # FRAGILITY
        if form.cleaned_data['type_of_assessment'] == TA.FRAGILITY:
            if formset_is_empty(fs_fragility_func):
                error_add(
                    fs_fragility_func, '__all__',
                    "Mandatory fields when type of assessment is fragility")
                return False
            if not formset_is_empty(fs_vulnerability_func):
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Fragility function selected. "
                    "These fields must be void")
                return False
            if not formset_is_empty(fs_damage_to_loss_func):
                error_add(
                    fs_damage_to_loss_func, '__all__',
                    "Fragility function selected. "
                    "These fields must be void")
                return False
            if not formset_is_empty(fs_capacity_curve_func):
                error_add(
                    fs_capacity_curve_func, '__all__',
                    "Fragility function selected. "
                    "These fields must be void")
                return False
            # if not check_model_info(fs_fragility_func):
            #     return False
            # if not check_stat_info(fs_fragility_func):
            #     return False
            if not check_predictor_var(fs_fragility_func):
                return False
            if not check_func_distr_type(fs_fragility_func, 'func_distr_frag'):
                return False

        # VULNERABILITY
        elif form.cleaned_data['type_of_assessment'] == TA.VULNERABILITY:
            if formset_is_empty(fs_vulnerability_func):
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Mandatory fields when type of assessment is "
                    "vulnerability")
                return False
            if not formset_is_empty(fs_fragility_func):
                error_add(
                    fs_fragility_func, '__all__',
                    "Vulnerability function selected. "
                    "These fields must be void")
                return False
            if not formset_is_empty(fs_damage_to_loss_func):
                error_add(
                    fs_damage_to_loss_func, '__all__',
                    "Vulnerability function selected. "
                    "These fields must be void")
                return False
            if not formset_is_empty(fs_capacity_curve_func):
                error_add(
                    fs_capacity_curve_func, '__all__',
                    "Vulnerability function selected. "
                    "These fields must be void")
                return False
            # if not check_model_info(fs_vulnerability_func):
            #     return False
            # if not check_stat_info(fs_vulnerability_func):
            #     return False
            if not check_predictor_var(fs_vulnerability_func):
                return False
            if not check_func_distr_type(
                    fs_vulnerability_func, 'func_distr_vuln'):
                return False

        # DAMAGE TO LOSS
        elif form.cleaned_data['type_of_assessment'] == TA.DAMAGE_TO_LOSS:
            if formset_is_empty(fs_damage_to_loss_func):
                error_add(
                    fs_damage_to_loss_func, '__all__',
                    "Mandatory fields when type of assessment is "
                    "damage to loss")
                return False
            if not formset_is_empty(fs_fragility_func):
                error_add(
                    fs_fragility_func, '__all__',
                    "Damage to loss function selected. "
                    "These fields must be void")
                return False
            if not formset_is_empty(fs_vulnerability_func):
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Damage to loss function selected. "
                    "These fields must be void")
                return False
            if not formset_is_empty(fs_capacity_curve_func):
                error_add(
                    fs_capacity_curve_func, '__all__',
                    "Damage to loss function selected. "
                    "These fields must be void")
                return False
            # if not check_model_info(fs_damage_to_loss_func):
            #     return False
            fs_func_distr_dtl_discr = formset_by_parent_and_rel_name(
                fs_damage_to_loss_func, 'func_distr_dtl_discr')
            if formset_is_empty(fs_func_distr_dtl_discr):
                error_add(
                    fs_func_distr_dtl_discr, '__all__',
                    "This section is mandatory")
                return False

        # CAPACITY CURVE
        elif form.cleaned_data['type_of_assessment'] == TA.CAPACITY_CURVE:
            if formset_is_empty(fs_capacity_curve_func):
                error_add(
                    fs_capacity_curve_func, '__all__',
                    "Mandatory fields when type of assessment is "
                    "capacity curve")
                return False
            if not formset_is_empty(fs_fragility_func):
                error_add(
                    fs_fragility_func, '__all__',
                    "Capacity curve function selected. "
                    "These fields must be void")
                return False
            if not formset_is_empty(fs_damage_to_loss_func):
                error_add(
                    fs_damage_to_loss_func, '__all__',
                    "Capacity curve function selected. "
                    "These fields must be void")
                return False
            if not formset_is_empty(fs_vulnerability_func):
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Capacity curve function selected. "
                    "These fields must be void")
                return False
            # if not check_model_info(fs_capacity_curve_func):
            #     return False
            fs_cc_predictor_var = formset_by_parent_and_rel_name(
                fs_capacity_curve_func, 'cc_predictor_var')
            if formset_is_empty(fs_cc_predictor_var):
                error_add(
                    fs_cc_predictor_var, '__all__',
                    "This section is mandatory")
                return False

        return True


admin.site.unregister(GeneralInformation)
admin.site.register(GeneralInformation, GeneralInformationAdmin)


def check_predictor_var(parent_fieldset):
    fs_predictor_var = formset_by_parent_and_rel_name(
        parent_fieldset, 'predictor_var')
    if formset_is_empty(fs_predictor_var):
        error_add(
            fs_predictor_var, '__all__',
            "Mandatory fields")
        return False
    return True


# # FIXME: Delete this when we are sure we don't need it
# def check_stat_info(parent_fieldset):
#     fs_stat_info = formset_by_parent_and_rel_name(
#         parent_fieldset, 'stat_info')
#     parent_form = parent_fieldset.forms[0]
#     if (parent_form.cleaned_data['method_of_estimation']
#             in (MOE.ANALYTICAL, MOE.EMPIRICAL)):
#         if formset_is_empty(fs_stat_info):
#             error_add(
#                 fs_stat_info, '__all__',
#                 "Mandatory fields when method of estimation "
#                 "is analytical or empirical")
#             return False
#     return True


def check_func_distr_type(parent_fieldset, partial_rel_name):
    fs_func_distr_discr = formset_by_parent_and_rel_name(
        parent_fieldset, partial_rel_name + '_discr')
    fs_func_distr_cont = formset_by_parent_and_rel_name(
        parent_fieldset, partial_rel_name + '_cont')
    parent_form = parent_fieldset.forms[0]
    if (parent_form.cleaned_data['func_distr_type']
            == FDT.DISCRETE):
        if formset_is_empty(fs_func_distr_discr):
            error_add(
                fs_func_distr_discr, '__all__',
                "Mandatory fields when function distribution type is "
                "discrete")
            return False
    elif (parent_form.cleaned_data['func_distr_type']
            == FDT.CONTINUOUS):
        if formset_is_empty(fs_func_distr_cont):
            error_add(
                fs_func_distr_cont, '__all__',
                "Mandatory fields when function distribution type is "
                "continuous")
            return False
    return True


# # FIXME: Delete this when we are sure we don't need it
# def check_model_info(parent_fieldset):
#     fs_analytical_model_info = formset_by_parent_and_rel_name(
#         parent_fieldset, 'analytical_model_info')
#     fs_empirical_model_info = formset_by_parent_and_rel_name(
#         parent_fieldset, 'empirical_model_info')
#     parent_form = parent_fieldset.forms[0]
#     if not fs_analytical_model_info or not fs_empirical_model_info:
#         parent_form.errors['__all__'] = \
#             'Required formsets not found'
#         return False
#     if (parent_form.cleaned_data['method_of_estimation']
#             == MOE.ANALYTICAL):
#         if formset_is_empty(fs_analytical_model_info):
#             error_add(
#                 fs_analytical_model_info, '__all__',
#                 "Mandatory fields when method of estimation is "
#                 "analytical")
#             return False
#         # TODO: Set empirical model info fields to empty instead of
#         # rising error
#         if not formset_is_empty(fs_empirical_model_info):
#             error_add(
#                 fs_empirical_model_info, '__all__',
#                 "Analytical method of estimation selected. "
#                 "These fields must be void")
#             return False
#     elif (parent_form.cleaned_data['method_of_estimation']
#             == MOE.EMPIRICAL):
#         if formset_is_empty(fs_empirical_model_info):
#             error_add(
#                 fs_empirical_model_info, '__all__',
#                 "Mandatory fields when method of estimation is "
#                 "empirical")
#             return False
#         # TODO: Set analytical model info fields to empty instead of
#         # rising error
#         if not formset_is_empty(fs_analytical_model_info):
#             error_add(
#                 fs_analytical_model_info, '__all__',
#                 "Empirical method of estimation selected. "
#                 "These fields must be void")
#             return False
#     return True
