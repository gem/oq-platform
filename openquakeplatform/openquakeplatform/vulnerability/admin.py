from django.contrib import admin
from django.db import models, transaction
from django.contrib.admin import helpers
from django.views.decorators.csrf import csrf_protect
from django.utils.decorators import method_decorator
from django.forms.formsets import all_valid
from django.forms.util import ErrorList
from django.utils.translation import ugettext as _
from django.utils.encoding import force_text
from django.core.exceptions import PermissionDenied
from django.contrib.admin.util import unquote
from django.http import Http404
from django.utils.html import escape
from django.core.urlresolvers import reverse
csrf_protect_m = method_decorator(csrf_protect)


from models import QualityRatingSystem
from models import StatisticalInformation
from models import EmpiricalModelInfo
from models import AnalysisType
from models import AnalyticalModelInfo
from models import ModellingInformation
from models import TaxonomyClassifForBuildings
from models import RegionAsGeographicalApplicability
from models import Applicability
from models import FuncDistrShape
from models import CC_EngineeringDemandPar
from models import CC_PredictorVar
from models import CapacityCurveFunc
from models import DamageToLossFunc
from models import FuncDistrVulnCont
from models import FuncDistrVulnDiscr
from models import PredictorVar
from models import VulnerabilityFunc
from models import FuncDistrFragCont
from models import FuncDistrFragDiscr
from models import EngineeringDemandPar
from models import FragilityFunc
from models import GeneralInformation

admin.site.register(QualityRatingSystem)
admin.site.register(StatisticalInformation)
admin.site.register(EmpiricalModelInfo)
admin.site.register(AnalysisType)
admin.site.register(AnalyticalModelInfo)
admin.site.register(ModellingInformation)
admin.site.register(TaxonomyClassifForBuildings)
admin.site.register(RegionAsGeographicalApplicability)
admin.site.register(Applicability)
admin.site.register(FuncDistrShape)
admin.site.register(CC_EngineeringDemandPar)
admin.site.register(CC_PredictorVar)
admin.site.register(CapacityCurveFunc)
admin.site.register(DamageToLossFunc)
admin.site.register(FuncDistrVulnCont)
admin.site.register(FuncDistrVulnDiscr)
admin.site.register(PredictorVar)
admin.site.register(VulnerabilityFunc)
admin.site.register(FuncDistrFragCont)
admin.site.register(FuncDistrFragDiscr)
admin.site.register(EngineeringDemandPar)
admin.site.register(FragilityFunc)
admin.site.register(GeneralInformation)

from models import MOE_ANALYTICAL, MOE_EMPIRICAL


class ModelAdminWithInline(admin.ModelAdmin):
    def is_cross_valid(self, form, formsets):
        return True

    @csrf_protect_m
    @transaction.commit_on_success
    def add_view(self, request, form_url='', extra_context=None):
        "The 'add' admin view for this model."
        model = self.model
        opts = model._meta

        if not self.has_add_permission(request):
            raise PermissionDenied

        ModelForm = self.get_form(request)
        formsets = []
        inline_instances = self.get_inline_instances(request, None)
        if request.method == 'POST':
            form = ModelForm(request.POST, request.FILES)
            if form.is_valid():
                new_object = self.save_form(request, form, change=False)
                form_validated = True
            else:
                form_validated = False
                new_object = self.model()
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(data=request.POST, files=request.FILES,
                                  instance=new_object,
                                  save_as_new="_saveasnew" in request.POST,
                                  prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
            formsets_validated = all_valid(formsets)
            cross_validated = self.is_cross_valid(form, formsets)
            if formsets_validated and form_validated and cross_validated:
                self.save_model(request, new_object, form, False)
                self.save_related(request, form, formsets, False)
                self.log_addition(request, new_object)
                return self.response_add(request, new_object)
        else:
            # Prepare the dict of initial data from the request.
            # We have to special-case M2Ms as a list of comma-separated PKs.
            initial = dict(request.GET.items())
            for k in initial:
                try:
                    f = opts.get_field(k)
                except models.FieldDoesNotExist:
                    continue
                if isinstance(f, models.ManyToManyField):
                    initial[k] = initial[k].split(",")
            form = ModelForm(initial=initial)
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(instance=self.model(), prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)

        adminForm = helpers.AdminForm(form, list(self.get_fieldsets(request)),
                                      self.get_prepopulated_fields(request),
                                      self.get_readonly_fields(request),
                                      model_admin=self)
        media = self.media + adminForm.media

        inline_admin_formsets = []
        for inline, formset in zip(inline_instances, formsets):
            fieldsets = list(inline.get_fieldsets(request))
            readonly = list(inline.get_readonly_fields(request))
            prepopulated = dict(inline.get_prepopulated_fields(request))
            inline_admin_formset = helpers.InlineAdminFormSet(
                inline, formset, fieldsets, prepopulated, readonly,
                model_admin=self)
            inline_admin_formsets.append(inline_admin_formset)
            media = media + inline_admin_formset.media

        context = {
            'title': _('Add %s') % force_text(opts.verbose_name),
            'adminform': adminForm,
            'is_popup': "_popup" in request.REQUEST,
            'media': media,
            'inline_admin_formsets': inline_admin_formsets,
            'errors': helpers.AdminErrorList(form, formsets),
            'app_label': opts.app_label,
        }
        context.update(extra_context or {})
        return self.render_change_form(request, context,
                                       form_url=form_url, add=True)

    @csrf_protect_m
    @transaction.commit_on_success
    def change_view(self, request, object_id, form_url='', extra_context=None):
        "The 'change' admin view for this model."
        model = self.model
        opts = model._meta

        obj = self.get_object(request, unquote(object_id))

        if not self.has_change_permission(request, obj):
            raise PermissionDenied

        if obj is None:
            raise Http404(
                _('%(name)s object with primary key %(key)r does not exist.')
                % {'name': force_text(opts.verbose_name),
                   'key': escape(object_id)})

        if request.method == 'POST' and "_saveasnew" in request.POST:
            return self.add_view(
                request,
                form_url=reverse(
                    'admin:%s_%s_add' % (opts.app_label, opts.module_name),
                    current_app=self.admin_site.name))

        ModelForm = self.get_form(request, obj)
        formsets = []
        inline_instances = self.get_inline_instances(request, obj)
        if request.method == 'POST':
            form = ModelForm(request.POST, request.FILES, instance=obj)
            if form.is_valid():
                form_validated = True
                new_object = self.save_form(request, form, change=True)
            else:
                form_validated = False
                new_object = obj
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request, new_object),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(request.POST, request.FILES,
                                  instance=new_object, prefix=prefix,
                                  queryset=inline.queryset(request))

                formsets.append(formset)

            formsets_validated = all_valid(formsets)
            cross_validated = self.is_cross_valid(form, formsets)
            if formsets_validated and form_validated and cross_validated:
                self.save_model(request, new_object, form, True)
                self.save_related(request, form, formsets, True)
                change_message = self.construct_change_message(
                    request, form, formsets)
                self.log_change(request, new_object, change_message)
                return self.response_change(request, new_object)

        else:
            form = ModelForm(instance=obj)
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request, obj),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(instance=obj, prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)

        adminForm = helpers.AdminForm(
            form, self.get_fieldsets(request, obj),
            self.get_prepopulated_fields(request, obj),
            self.get_readonly_fields(request, obj),
            model_admin=self)
        media = self.media + adminForm.media

        inline_admin_formsets = []
        for inline, formset in zip(inline_instances, formsets):
            fieldsets = list(inline.get_fieldsets(request, obj))
            readonly = list(inline.get_readonly_fields(request, obj))
            prepopulated = dict(inline.get_prepopulated_fields(request, obj))
            inline_admin_formset = helpers.InlineAdminFormSet(
                inline, formset, fieldsets, prepopulated,
                readonly, model_admin=self)
            inline_admin_formsets.append(inline_admin_formset)
            media = media + inline_admin_formset.media

        context = {
            'title': _('Change %s') % force_text(opts.verbose_name),
            'adminform': adminForm,
            'object_id': object_id,
            'original': obj,
            'is_popup': "_popup" in request.REQUEST,
            'media': media,
            'inline_admin_formsets': inline_admin_formsets,
            'errors': helpers.AdminErrorList(form, formsets),
            'app_label': opts.app_label,
        }
        context.update(extra_context or {})
        return self.render_change_form(
            request, context, change=True, obj=obj, form_url=form_url)


class CC_PredictorVarInline(admin.StackedInline):
    model = CC_PredictorVar
    fk_name = 'capacity_curve_func'
    max_num = 1


class CC_AnalyticalModelInfoInline(admin.StackedInline):
    model = AnalyticalModelInfo
    fk_name = 'capacity_curve_func'
    max_num = 1


class CapacityCurveFuncAdmin(admin.ModelAdmin):
    inlines = [
        CC_AnalyticalModelInfoInline,
        CC_PredictorVarInline,
    ]


admin.site.unregister(CapacityCurveFunc)
admin.site.register(CapacityCurveFunc, CapacityCurveFuncAdmin)


class DL_AnalyticalModelInfoInline(admin.StackedInline):
    model = AnalyticalModelInfo
    exclude = ('capacity_curve_func',
               'fragility_func',
               'vulnerability_func')
    fk_name = 'damage_to_loss_func'
    max_num = 1


class DL_EmpiricalModelInfoInline(admin.StackedInline):
    model = EmpiricalModelInfo
    exclude = ('fragility_func',
               'vulnerability_func')
    fk_name = 'damage_to_loss_func'
    max_num = 1


class DamageToLossFuncAdmin(admin.ModelAdmin):
    inlines = [
        DL_AnalyticalModelInfoInline,
        DL_EmpiricalModelInfoInline,
    ]


admin.site.unregister(DamageToLossFunc)
admin.site.register(DamageToLossFunc, DamageToLossFuncAdmin)


class VU_AnalyticalModelInfoInline(admin.StackedInline):
    model = AnalyticalModelInfo
    exclude = ('capacity_curve_func',
               'damage_to_loss_func',
               'fragility_func')
    fk_name = 'vulnerability_func'
    max_num = 1


class VU_EmpiricalModelInfoInline(admin.StackedInline):
    model = EmpiricalModelInfo
    exclude = ('damage_to_loss_func',
               'fragility_func')
    fk_name = 'vulnerability_func'
    max_num = 1


class VU_PredictorVarInline(admin.StackedInline):
    model = PredictorVar
    exclude = ('fragility_func',)
    fk_name = 'vulnerability_func'
    max_num = 1


class VU_FuncDistrVulnDiscrInline(admin.StackedInline):
    model = FuncDistrVulnDiscr
    fk_name = 'vulnerability_func'
    max_num = 1


class VU_FuncDistrVulnContInline(admin.StackedInline):
    model = FuncDistrVulnCont
    fk_name = 'vulnerability_func'
    max_num = 1


def formset_by_rel_name(formsets, rel_name):
    for formset in formsets:
        if formset.rel_name == rel_name:
            return formset
    return None


def formset_is_empty(formset):
    #print "1 - formset is empty"
    if not hasattr(formset, 'cleaned_data'):
        return True
    #print "2 - formset is empty"
    if len(formset.cleaned_data) == 0:
        return True
    #print "3 - formset is empty"
    if not formset.cleaned_data[0]:
        return True
    #print "4 - formset is empty"
    if ('DELETE' in formset.cleaned_data[0]
            and formset.cleaned_data[0]['DELETE'] is True
            and formset.can_delete is True):
        return True
    #print "5 - formset is empty"
    return False


def error_add(formset, field_name, desc):
    if not hasattr(formset, 'forms'):
        return False
    if len(formset.forms) != 1:
        return False
    if not hasattr(formset.forms[0], '_errors'):
        return False
    formset.forms[0]._errors[field_name] = ErrorList([desc])


class VulnerabilityFuncAdmin(ModelAdminWithInline):
    inlines = [
        VU_AnalyticalModelInfoInline,
        VU_EmpiricalModelInfoInline,
        VU_PredictorVarInline,
        VU_FuncDistrVulnDiscrInline,
        VU_FuncDistrVulnContInline,
    ]

    def is_cross_valid(self, form, formsets):
        if not form.is_valid():
            form.errors['__all__'] = "Invalid form"
            return False
        fs_analytical_model_info = formset_by_rel_name(formsets,
                                                       'analytical_model_info')
        fs_empirical_model_info = formset_by_rel_name(formsets,
                                                      'empirical_model_info')
        if not fs_analytical_model_info or not fs_empirical_model_info:
            form.errors['__all__'] = 'Required formsets not found'
            return False
        if form.cleaned_data['method_of_estimation'] == MOE_ANALYTICAL:
            if formset_is_empty(fs_analytical_model_info):
                error_add(
                    fs_analytical_model_info, '__all__',
                    "Mandatory fields when method of estimation is analytical")
                return False
            # TODO: Set empirical model info fields to empty instead of rising
            # error
            if not formset_is_empty(fs_empirical_model_info):
                error_add(
                    fs_empirical_model_info, '__all__',
                    "Analytical method of estimation selected. "
                    "These fields must be void")
                return False
        if form.cleaned_data['method_of_estimation'] == MOE_EMPIRICAL:
            if formset_is_empty(fs_empirical_model_info):
                error_add(
                    fs_empirical_model_info, '__all__',
                    "Mandatory fields when method of estimation is empirical")
                return False
            # TODO: Set analytical model info fields to empty instead of rising
            # error
            if not formset_is_empty(fs_analytical_model_info):
                error_add(
                    fs_analytical_model_info, '__all__',
                    "Empirical method of estimation selected. "
                    "These fields must be void")
                return False
        print 'form'
        print dir(form)
        print 'has_changed:', form.has_changed()
        print 'is_valid:', form.is_valid()
        print 'is_bound:', form.is_bound
        print 'cleaned_data:', form.cleaned_data  # .get('DELETE')
        for formset in formsets:
            print 'formset'
            print dir(formset)
            print 'model:', formset.model()
            print 'rel_name:', formset.rel_name
            print 'has_changed:', formset.has_changed()
            print 'is_valid:', formset.is_valid()
            print 'is_bound:', formset.is_bound
            print 'can_delete:', formset.can_delete
            print 'cleaned_data:', formset.cleaned_data  # .get('DELETE')
            print 'delete defined and set true:', (
                'true' if 'DELETE' in formset.cleaned_data[0]
                and formset.cleaned_data[0]['DELETE'] is True
                else 'false')
            for formset_form in formset.forms:
                print "FORMSETFORM LOOP"
                if hasattr(formset_form, 'cleaned_data'):
                    print 'dir(formset_form):', dir(formset_form)

        return True


admin.site.unregister(VulnerabilityFunc)
admin.site.register(VulnerabilityFunc, VulnerabilityFuncAdmin)


class FR_AnalyticalModelInfoInline(admin.StackedInline):
    model = AnalyticalModelInfo
    exclude = ('capacity_curve_func',
               'damage_to_loss_func',
               'vulnerability_func')
    fk_name = 'fragility_func'
    max_num = 1


class FR_EmpiricalModelInfoInline(admin.StackedInline):
    model = EmpiricalModelInfo
    exclude = ('damage_to_loss_func',
               'vulnerability_func')
    fk_name = 'fragility_func'
    max_num = 1


class FR_PredictorVarInline(admin.StackedInline):
    model = PredictorVar
    exclude = ('vulnerability_func',)
    fk_name = 'fragility_func'
    max_num = 1


class FR_FuncDistrFragContInline(admin.StackedInline):
    model = FuncDistrFragCont
    fk_name = 'fragility_func'
    max_num = 1


class FR_FuncDistrFragDiscrInline(admin.StackedInline):
    model = FuncDistrFragDiscr
    fk_name = 'fragility_func'
    max_num = 1


class FragilityFuncAdmin(admin.ModelAdmin):
    inlines = [
        FR_AnalyticalModelInfoInline,
        FR_EmpiricalModelInfoInline,
        FR_PredictorVarInline,
        FR_FuncDistrFragContInline,
        FR_FuncDistrFragDiscrInline,
    ]


admin.site.unregister(FragilityFunc)
admin.site.register(FragilityFunc, FragilityFuncAdmin)
