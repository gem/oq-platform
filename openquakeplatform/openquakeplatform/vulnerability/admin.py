# Copyright (c) 2012-2013, GEM Foundation.
#
# This program is free software: you can redistribute it and/or modify
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from collections import OrderedDict
try:
    from django.contrib.admin.options import force_unicode
except ImportError:
    from django.utils.encoding import force_text as force_unicode
from django import VERSION as DJANGO_VERSION
from django.contrib import admin
from django.db import models, transaction
from django.views.decorators.csrf import csrf_protect
from django.utils.decorators import method_decorator
from django import forms
from django.forms.util import ErrorList
from django.utils.translation import ugettext as _
from django.core.exceptions import PermissionDenied
from django.core.exceptions import ValidationError
from django.contrib.admin.util import unquote
from django.contrib.admin.helpers import InlineAdminFormSet, AdminForm
from django.http import Http404
from django.utils.html import escape
from django.core.urlresolvers import reverse
csrf_protect_m = method_decorator(csrf_protect)
from nested_inlines.admin import NestedModelAdmin, NestedStackedInline
from nested_inlines.helpers import AdminErrorList
from openquakeplatform.vulnerability.forms import PredictorVarForm
from openquakeplatform.vulnerability.forms import CC_PredictorVarForm
from openquakeplatform.vulnerability.forms import GeoApplicabilityForm


class OwnershipException(Exception):
    pass


class OwnedNestedInline(object):
    def get_readonly_fields(self, request, obj=None):
        if (request.user.is_superuser
            or request.user.groups.filter(name='vulnerability-admins').count()):
            return ()
        sup_ret = super(OwnedNestedInline, self).get_readonly_fields(request, obj)
        sup_ret = () if not sup_ret else sup_ret

        return tuple(set(sup_ret).union(set(('owner',))))


    def has_add_permission(self, request):
        if (request.user.is_superuser
            or request.user.groups.filter(name='vulnerability-admins').count()):
            self.exclude = ('id',)
        return super(OwnedNestedInline, self).has_add_permission(request)


class OwnedAdmin(object):
    def save_model(self, request, obj, form, change):
        print "save_model override (A) change: ", ("TRUE" if change else "FALSE")
        if change:
            if (not (request.user.is_superuser
                     or request.user.groups.filter(name='vulnerability-admins').count())
                and "owner" in form.changed_data):
                raise OwnershipException("This object is owned by another user.")

            if not (obj.is_owned_by(request.user)
                    or request.user.is_superuser
                    or request.user.groups.filter(name='vulnerability-admins').count()):
                raise OwnershipException("This object is owned by another user.")

        if not change and obj.owner_id is None:
            obj.owner_id = request.user.id
        else:
            if not obj.owner_id:
                raise OwnershipException("Inconsistent record %d, no owner id found" % request.pk)

        # ugly but works
        request._gem_custom = obj.owner_id
        super(OwnedAdmin, self).save_model(request, obj, form, change)


    def has_add_permission(self, request):
        if (request.user.is_superuser
            or request.user.groups.filter(name='vulnerability-admins').count()):
            self.exclude = ('id',)
            self.save_as = True
        return super(OwnedAdmin, self).has_add_permission(request)

    def has_delete_permission(self, request, obj=None):
        if (not obj
            or (obj.is_owned_by(request.user)
                or request.user.is_superuser
                or request.user.groups.filter(name='vulnerability-admins').count())):
            return True
        else:
            return False


    def get_readonly_fields(self, request, obj=None):
        if (request.user.is_superuser
            or request.user.groups.filter(name='vulnerability-admins').count()):
            return ()
        sup_ret = super(OwnedAdmin, self).get_readonly_fields(request, obj)
        sup_ret = () if not sup_ret else sup_ret

        return tuple(set(sup_ret).union(set(('owner',))))


    def save_formset(self, request, form, formset, change):
        """
        Given an inline formset save it to the database.
        """
        print "save_formset override (A) ", request._gem_custom
        # pdb.set_trace()
        instances = formset.save(commit=False)
        for instance in instances:
            # cascading ownership from first ancestor just for normal users
            if (not (request.user.is_superuser
                     or request.user.groups.filter(name='vulnerability-admins').count())):
                if hasattr(instance, "owner_id"):
                    instance.owner_id = request._gem_custom
            instance.save()
        formset.save_m2m()

        # this save_m2m arrives from an official django example:
        # https://docs.djangoproject.com/en/1.5/ref/contrib/admin/#django.contrib.admin.ModelAdmin.save_formset
        # and is different from the save_formset defined in django_nested_inlines extension
        # formset.save_m2m()

        #iterate through the nested formsets and save them
        #skip formsets, where the parent is marked for deletion
        if formset.can_delete:
            deleted_forms = formset.deleted_forms
        else:
            deleted_forms = []
        for form in formset.forms:
            if hasattr(form, 'nested_formsets') and form not in deleted_forms:
                for nested_formset in form.nested_formsets:
                    self.save_formset(request, form, nested_formset, change)


class Hide2StaffAdmin(admin.ModelAdmin):
    def get_model_perms(self, request):
        """
        Return empty perms dict thus hiding the model from admin index.
        """

        if (request.user.is_superuser
            or request.user.groups.filter(name='vulnerability-admins').count()):
            return super(Hide2StaffAdmin, self).get_model_perms(request)

        return {}



from models import QRSEmpirical
from models import QRSAnalytical
from models import StatModel
from models import StatModelFittingMethod
from models import ModelFittingMethodAssumption
from models import FitAssessmentGoodness
from models import ProcConstrInt
from models import StatisticalInformation
from models import EmpiricalModelInfo
from models import AnalysisType
from models import AnalyticalModelInfo
from models import CC_AnalysisType
from models import CC_AnalyticalModelInfo
from models import Country
from models import GeoApplicability
from models import TaxonomyType
from models import CC_PredictorVar
from models import CapacityCurveFunc
from models import FuncDistrDTLDiscr
from models import DamageToLossFunc
from models import FuncDistrVulnCont
from models import FuncDistrVulnDiscr
from models import EvaluationOfIM
from models import PredictorVar
from models import VulnerabilityFunc
from models import FuncDistrFragCont
from models import FuncDistrFragDiscr
from models import EngineeringDemandPar
from models import FragilityFunc
from models import GeneralInformation

admin.site.register(QRSEmpirical, Hide2StaffAdmin)
admin.site.register(QRSAnalytical, Hide2StaffAdmin)
admin.site.register(StatModel, Hide2StaffAdmin)
admin.site.register(StatModelFittingMethod, Hide2StaffAdmin)
admin.site.register(ModelFittingMethodAssumption, Hide2StaffAdmin)
admin.site.register(FitAssessmentGoodness, Hide2StaffAdmin)
admin.site.register(ProcConstrInt, Hide2StaffAdmin)
admin.site.register(StatisticalInformation, Hide2StaffAdmin)
admin.site.register(EmpiricalModelInfo, Hide2StaffAdmin)
admin.site.register(AnalysisType, Hide2StaffAdmin)
admin.site.register(AnalyticalModelInfo, Hide2StaffAdmin)
admin.site.register(CC_AnalysisType, Hide2StaffAdmin)
admin.site.register(CC_AnalyticalModelInfo, Hide2StaffAdmin)
admin.site.register(Country, Hide2StaffAdmin)
admin.site.register(GeoApplicability, Hide2StaffAdmin)
admin.site.register(TaxonomyType, Hide2StaffAdmin)
admin.site.register(CC_PredictorVar, Hide2StaffAdmin)
admin.site.register(CapacityCurveFunc, Hide2StaffAdmin)
admin.site.register(FuncDistrDTLDiscr, Hide2StaffAdmin)
admin.site.register(DamageToLossFunc, Hide2StaffAdmin)
admin.site.register(FuncDistrVulnCont, Hide2StaffAdmin)
admin.site.register(FuncDistrVulnDiscr, Hide2StaffAdmin)
admin.site.register(EvaluationOfIM, Hide2StaffAdmin)
admin.site.register(PredictorVar, Hide2StaffAdmin)
admin.site.register(VulnerabilityFunc, Hide2StaffAdmin)
admin.site.register(FuncDistrFragCont, Hide2StaffAdmin)
admin.site.register(FuncDistrFragDiscr, Hide2StaffAdmin)
admin.site.register(EngineeringDemandPar, Hide2StaffAdmin)
admin.site.register(FragilityFunc, Hide2StaffAdmin)
admin.site.register(GeneralInformation, Hide2StaffAdmin)


from models import TA, TYPES_OF_ASSESSMENT, FDT


class NestedModelAdminCrossChecked(NestedModelAdmin):
    def is_cross_valid(self, form, formsets):
        return True

    @csrf_protect_m
    @transaction.commit_on_success
    def add_view(self, request, form_url='', extra_context=None):
        "The 'add' admin view for this model."
        model = self.model
        opts = model._meta

        if not self.has_add_permission(request):
            raise PermissionDenied

        ModelForm = self.get_form(request)
        formsets = []
        inline_instances = self.get_inline_instances(request, None)
        if request.method == 'POST':
            form = ModelForm(request.POST, request.FILES)
            if form.is_valid():
                new_object = self.save_form(request, form, change=False)
                form_validated = True
            else:
                form_validated = False
                new_object = self.model()
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(data=request.POST, files=request.FILES,
                                  instance=new_object,
                                  save_as_new="_saveasnew" in request.POST,
                                  prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)
            if (self.all_valid_with_nesting(formsets) and form_validated
                    and self.is_cross_valid(form, formsets)):
                self.save_model(request, new_object, form, False)
                self.save_related(request, form, formsets, False)
                self.log_addition(request, new_object)
                return self.response_add(request, new_object)
        else:
            # Prepare the dict of initial data from the request.
            # We have to special-case M2Ms as a list of comma-separated PKs.
            initial = dict(request.GET.items())
            for k in initial:
                try:
                    f = opts.get_field(k)
                except models.FieldDoesNotExist:
                    continue
                if isinstance(f, models.ManyToManyField):
                    initial[k] = initial[k].split(",")
            form = ModelForm(initial=initial)
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(instance=self.model(), prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)

        adminForm = AdminForm(form,
                              list(self.get_fieldsets(request)),
                              self.get_prepopulated_fields(request),
                              self.get_readonly_fields(request),
                              model_admin=self)
        media = self.media + adminForm.media

        inline_admin_formsets = []
        for inline, formset in zip(inline_instances, formsets):
            fieldsets = list(inline.get_fieldsets(request))
            readonly = list(inline.get_readonly_fields(request))
            prepopulated = dict(inline.get_prepopulated_fields(request))
            inline_admin_formset = InlineAdminFormSet(
                inline, formset, fieldsets, prepopulated,
                readonly, model_admin=self)
            inline_admin_formsets.append(inline_admin_formset)
            media = media + inline_admin_formset.media
            if inline.inlines:
                media = media + self.wrap_nested_inline_formsets(
                    request, inline, formset)

        context = {
            'title': _('Add %s') % force_unicode(opts.verbose_name),
            'adminform': adminForm,
            'is_popup': "_popup" in request.REQUEST,
            'show_delete': False,
            'media': media,
            'inline_admin_formsets': inline_admin_formsets,
            'errors': AdminErrorList(form, formsets),
            'app_label': opts.app_label,
            'django_version_lt_1_6': DJANGO_VERSION < (1, 6)
        }
        context.update(extra_context or {})
        return self.render_change_form(
            request, context, form_url=form_url, add=True)

    @csrf_protect_m
    @transaction.commit_on_success
    def change_view(self, request, object_id, form_url='', extra_context=None):
        "The 'change' admin view for this model."
        model = self.model
        opts = model._meta

        obj = self.get_object(request, unquote(object_id))

        if not self.has_change_permission(request, obj):
            raise PermissionDenied

        if obj is None:
            raise Http404(
                _('%(name)s object with primary key %(key)r does not exist.')
                % {'name': force_unicode(opts.verbose_name),
                   'key': escape(object_id)})

        if request.method == 'POST' and "_saveasnew" in request.POST:
            return self.add_view(
                request,
                form_url=reverse(
                    'admin:%s_%s_add' % (opts.app_label, opts.module_name),
                    current_app=self.admin_site.name))

        ModelForm = self.get_form(request, obj)
        formsets = []
        inline_instances = self.get_inline_instances(request, obj)
        if request.method == 'POST':
            form = ModelForm(request.POST, request.FILES, instance=obj)
            if form.is_valid():
                form_validated = True
                new_object = self.save_form(request, form, change=True)
            else:
                form_validated = False
                new_object = obj
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request, new_object),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(request.POST, request.FILES,
                                  instance=new_object, prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)

            if (self.all_valid_with_nesting(formsets) and form_validated
                    and self.is_cross_valid(form, formsets)):
                self.save_model(request, new_object, form, True)
                self.save_related(request, form, formsets, True)
                change_message = self.construct_change_message(
                    request, form, formsets)
                self.log_change(request, new_object, change_message)
                return self.response_change(request, new_object)

        else:
            form = ModelForm(instance=obj)
            prefixes = {}
            for FormSet, inline in zip(self.get_formsets(request, obj),
                                       inline_instances):
                prefix = FormSet.get_default_prefix()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
                if prefixes[prefix] != 1 or not prefix:
                    prefix = "%s-%s" % (prefix, prefixes[prefix])
                formset = FormSet(instance=obj, prefix=prefix,
                                  queryset=inline.queryset(request))
                formsets.append(formset)
                if inline.inlines:
                    self.add_nested_inline_formsets(request, inline, formset)

        adminForm = AdminForm(form,
                              self.get_fieldsets(request, obj),
                              self.get_prepopulated_fields(request, obj),
                              self.get_readonly_fields(request, obj),
                              model_admin=self)
        media = self.media + adminForm.media

        inline_admin_formsets = []
        for inline, formset in zip(inline_instances, formsets):
            fieldsets = list(inline.get_fieldsets(request, obj))
            readonly = list(inline.get_readonly_fields(request, obj))
            prepopulated = dict(inline.get_prepopulated_fields(request, obj))
            inline_admin_formset = InlineAdminFormSet(
                inline, formset, fieldsets, prepopulated,
                readonly, model_admin=self)
            inline_admin_formsets.append(inline_admin_formset)
            media = media + inline_admin_formset.media
            if inline.inlines:
                media = media + self.wrap_nested_inline_formsets(
                    request, inline, formset)

        context = {
            'title': _('Change %s') % force_unicode(opts.verbose_name),
            'adminform': adminForm,
            'object_id': object_id,
            'original': obj,
            'is_popup': "_popup" in request.REQUEST,
            'media': media,
            'inline_admin_formsets': inline_admin_formsets,
            'errors': AdminErrorList(form, formsets),
            'app_label': opts.app_label,
            'django_version_lt_1_6': DJANGO_VERSION < (1, 6)
        }
        context.update(extra_context or {})
        return self.render_change_form(
            request, context, change=True, obj=obj, form_url=form_url)


qrs_analytical_fieldsets = (
    ('Data quality', {
        'classes': ('collapse',),
        'fields': ('structural_details',
                   'model_completeness',
                   'seismic_demand', )
    }),
    ('Rationality', {
        'classes': ('collapse',),
        'fields': ('analysis_type',
                   'limit_states_def',
                   'sampling_method',
                   'cross_validation',
                   'uncertainties_treatment')
    }),
    ('Documentation quality', {
        'classes': ('collapse',),
        'fields': ('documentation_quality',
                   'documentation_type', )
    }),
    ('Representativeness', {
        'classes': ('collapse',),
        'fields': ('typology_repr',
                   'site_specific',
                   'hazard_model', )
    }),
)


qrs_empirical_fieldsets = (
    ('Data quality', {
        'classes': ('collapse',),
        'fields': ('data_quantity',
                   'constrained_categories',
                   'excitation_observation',
                   'damage_loss_observation',)
    }),
    ('Rationality', {
        'classes': ('collapse',),
        'fields': ('hindcasting',
                   'cross_validation',
                   'first_principles',
                   'uncertainties_treatment',)
    }),
    ('Documentation quality', {
        'classes': ('collapse',),
        'fields': ('documentation_quality',
                   'documentation_type', )
    }),
    ('Representativeness', {
        'classes': ('collapse',),
        'fields': ('representativeness', ),
    }),
)


class CC_PredictorVarInline(OwnedNestedInline, NestedStackedInline):
    form = CC_PredictorVarForm
    model = CC_PredictorVar
    exclude = ()
    fk_name = 'capacity_curve_func'


class CC_AnalyticalModelInfoInline(OwnedNestedInline, NestedStackedInline):
    model = CC_AnalyticalModelInfo
    fk_name = 'capacity_curve_func'


class CapacityCurveFuncInline(OwnedNestedInline, NestedStackedInline):
    model = CapacityCurveFunc
    inlines = [
        CC_AnalyticalModelInfoInline,
        CC_PredictorVarInline,
    ]


class DL_FuncDistrDTLDiscrInline(OwnedNestedInline, NestedStackedInline):
    model = FuncDistrDTLDiscr
    fl_name = 'damage_to_loss_func'


class DamageToLossFuncInline(OwnedNestedInline, NestedStackedInline):
    model = DamageToLossFunc
    inlines = [
        DL_FuncDistrDTLDiscrInline,
    ]


class VU_AnalyticalModelInfoInline(OwnedNestedInline, NestedStackedInline):
    model = AnalyticalModelInfo
    exclude = ('fragility_func',)
    fk_name = 'vulnerability_func'


class VU_EmpiricalModelInfoInline(OwnedNestedInline, NestedStackedInline):
    model = EmpiricalModelInfo
    exclude = ('capacity_curve_func',
               'damage_to_loss_func',
               'fragility_func')
    fk_name = 'vulnerability_func'


class VU_StatisticalInformationInline(OwnedNestedInline, NestedStackedInline):
    model = StatisticalInformation
    exclude = ('fragility_func', )
    fk_name = 'vulnerability_func'


class VU_PredictorVarInline(OwnedNestedInline, NestedStackedInline):
    model = PredictorVar
    form = PredictorVarForm
    exclude = ('fragility_func',)
    fk_name = 'vulnerability_func'


class VU_FuncDistrVulnDiscrInline(OwnedNestedInline, NestedStackedInline):
    model = FuncDistrVulnDiscr
    fk_name = 'vulnerability_func'


class VU_FuncDistrVulnContInline(OwnedNestedInline, NestedStackedInline):
    model = FuncDistrVulnCont
    fk_name = 'vulnerability_func'


def formset_by_rel_name(formsets, rel_name):
    for formset in formsets:
        if formset.rel_name == rel_name:
            return formset
    return None


def formset_by_parent_and_rel_name(parent_formset, rel_name):
    try:
        nested_formsets = parent_formset.forms[0].nested_formsets
        return formset_by_rel_name(nested_formsets, rel_name)
    except Exception:
        return None


class VU_QRSAnalyticalInline(OwnedNestedInline, NestedStackedInline):
    model = QRSAnalytical
    exclude = ('fragility_func', )
    fk_name = 'vulnerability_func'
    fieldsets = qrs_analytical_fieldsets


class VU_QRSEmpiricalInline(OwnedNestedInline, NestedStackedInline):
    model = QRSEmpirical
    exclude = ('fragility_func', )
    fk_name = 'vulnerability_func'
    fieldsets = qrs_empirical_fieldsets


def formset_is_empty(formset):
    #print "1 - formset is empty"
    if not hasattr(formset, 'cleaned_data'):
        return True
    #print "2 - formset is empty"
    if len(formset.cleaned_data) == 0:
        return True
    #print "3 - formset is empty"
    if not formset.cleaned_data[0]:
        return True
    #print "4 - formset is empty"
    if ('DELETE' in formset.cleaned_data[0]
            and formset.cleaned_data[0]['DELETE'] is True
            and formset.can_delete is True):
        return True
    #print "5 - formset is empty"
    return False


def error_add(formset, field_name, desc):
    if not hasattr(formset, 'forms'):
        return False
    if len(formset.forms) != 1:
        return False
    if not hasattr(formset.forms[0], '_errors'):
        return False
    formset.forms[0]._errors[field_name] = ErrorList([desc])
    return True


class VulnerabilityFuncInline(OwnedNestedInline, NestedStackedInline):
    model = VulnerabilityFunc
    inlines = [
        VU_AnalyticalModelInfoInline,
        VU_EmpiricalModelInfoInline,
        VU_PredictorVarInline,
        VU_FuncDistrVulnDiscrInline,
        VU_FuncDistrVulnContInline,
        VU_StatisticalInformationInline,
        VU_QRSAnalyticalInline,
        VU_QRSEmpiricalInline,
    ]


class FR_AnalyticalModelInfoInline(OwnedNestedInline, NestedStackedInline):
    model = AnalyticalModelInfo
    exclude = ('vulnerability_func',)
    fk_name = 'fragility_func'


class FR_EmpiricalModelInfoInline(OwnedNestedInline, NestedStackedInline):
    model = EmpiricalModelInfo
    exclude = ('capacity_curve_func',
               'damage_to_loss_func',
               'vulnerability_func')
    fk_name = 'fragility_func'


class FR_StatisticalInformationInline(OwnedNestedInline, NestedStackedInline):
    model = StatisticalInformation
    exclude = ('vulnerability_func', )
    fk_name = 'fragility_func'


class FR_PredictorVarInline(OwnedNestedInline, NestedStackedInline):
    model = PredictorVar
    form = PredictorVarForm
    exclude = ('vulnerability_func',)
    fk_name = 'fragility_func'


class FR_FuncDistrFragContInline(OwnedNestedInline, NestedStackedInline):
    model = FuncDistrFragCont
    fk_name = 'fragility_func'


class FR_FuncDistrFragDiscrInline(OwnedNestedInline, NestedStackedInline):
    model = FuncDistrFragDiscr
    fk_name = 'fragility_func'


class FR_QRSEmpiricalInline(OwnedNestedInline, NestedStackedInline):
    model = QRSEmpirical
    exclude = ('vulnerability_func', )
    fk_name = 'fragility_func'
    fieldsets = qrs_empirical_fieldsets


class FR_QRSAnalyticalInline(OwnedNestedInline, NestedStackedInline):
    model = QRSAnalytical
    exclude = ('vulnerability_func', )
    fk_name = 'fragility_func'
    fieldsets = qrs_analytical_fieldsets


class FragilityFuncInline(OwnedNestedInline, NestedStackedInline):
    model = FragilityFunc
    inlines = [
        FR_AnalyticalModelInfoInline,
        FR_EmpiricalModelInfoInline,
        FR_PredictorVarInline,
        FR_FuncDistrFragContInline,
        FR_FuncDistrFragDiscrInline,
        FR_StatisticalInformationInline,
        FR_QRSEmpiricalInline,
        FR_QRSAnalyticalInline,
    ]


class GeoApplicability(OwnedNestedInline, NestedStackedInline):
    model = GeoApplicability
    form = GeoApplicabilityForm


class GeneralInformationAdmin(OwnedAdmin, NestedModelAdminCrossChecked):
    save_as = True
    inlines = [
        FragilityFuncInline,
        VulnerabilityFuncInline,
        DamageToLossFuncInline,
        CapacityCurveFuncInline,
        GeoApplicability,
    ]

    list_filter = ('category',
                   'type_of_assessment',
                   'geo_applicability__countries__region', )

    class Media:
        js = ("vulnerability/js/waterfall_show_hide.js", )

    #fieldsets = (
        #(None, {
            #'fields': ('name',
                       #'category',
                       #'taxonomy_type',
                       #'taxonomy_text',)
        #}),
        #('Functions', {
            #'fields': ('fragility_func',)
        #}),
        #('Reference / Documentation', {
            #'classes': ('collapse',),
            #'fields': ('authors',
                       #'article_title',
                       #'publication_conference_name',
                       #'year',
                       #'web_link',)
        #}),
        #(None, {
            #'fields': ('use_case_information',
                       #'general_comments',)
        #}),
    #)

    def is_cross_valid(self, form, formsets):
        any_error_found = False
        errors = form._errors.setdefault(forms.forms.NON_FIELD_ERRORS,
                                         forms.util.ErrorList())
        fs_geo_applicability = formset_by_rel_name(formsets,
                                                   'geo_applicability')
        fs_fragility_func = formset_by_rel_name(formsets,
                                                'fragility_func')
        fs_vulnerability_func = formset_by_rel_name(formsets,
                                                    'vulnerability_func')
        fs_damage_to_loss_func = formset_by_rel_name(formsets,
                                                     'damage_to_loss_func')
        fs_capacity_curve_func = formset_by_rel_name(formsets,
                                                     'capacity_curve_func')
        if formset_is_empty(fs_geo_applicability):
            error_add(
                fs_geo_applicability, '__all__',
                "Mandatory fields")
            any_error_found = True

        if (not fs_fragility_func and not fs_vulnerability_func
                and not fs_damage_to_loss_func and not fs_capacity_curve_func):
            errors.append('Required formsets not found')
            any_error_found = True

        type_of_assessment_idx = (form.cleaned_data['type_of_assessment']
                                  if 'type_of_assessment' in form.cleaned_data
                                  else None)

        # FRAGILITY
        if type_of_assessment_idx == TA.FRAGILITY:
            if formset_is_empty(fs_fragility_func):
                error_add(
                    fs_fragility_func, '__all__',
                    "Mandatory fields")
                any_error_found = True
            if not formset_is_empty(fs_vulnerability_func):
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Fragility function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.VULNERABILITY)
                any_error_found = True
            if not formset_is_empty(fs_damage_to_loss_func):
                error_add(
                    fs_damage_to_loss_func, '__all__',
                    "Fragility function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.DAMAGE_TO_LOSS)
                any_error_found = True
            if not formset_is_empty(fs_capacity_curve_func):
                error_add(
                    fs_capacity_curve_func, '__all__',
                    "Fragility function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.CAPACITY_CURVE)
                any_error_found = True
            fs_predictor_var = get_predictor_var(fs_fragility_func)
            if fs_predictor_var:
                cd_fragility_func = fs_fragility_func.forms[0].cleaned_data
                if cd_fragility_func['func_distr_type'] == FDT.CONTINUOUS:
                    cd_predictor_var = fs_predictor_var.forms[0].cleaned_data
                    if (cd_predictor_var['minimum_im'] == '' or
                        cd_predictor_var['minimum_im'] == None):
                        error_add(
                            fs_predictor_var, 'minimum_im',
                            "Continuous function distribution type selected. "
                            "This field is mandatory.")
                        any_error_found = True
                    if (cd_predictor_var['maximum_im'] == '' or
                        cd_predictor_var['maximum_im'] == None):
                        error_add(
                            fs_predictor_var, 'maximum_im',
                            "Continuous function distribution type selected. "
                            "This field is mandatory.")
                        any_error_found = True
            else:
                error_add(
                    fs_fragility_func, '__all__',
                    "Malformed submission: predictor_var fieldset not found")
                any_error_found = True

            if not check_func_distr_type(fs_fragility_func, 'func_distr_frag'):
                any_error_found = True

        # VULNERABILITY
        elif type_of_assessment_idx == TA.VULNERABILITY:
            if formset_is_empty(fs_vulnerability_func):
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Mandatory fields")
                any_error_found = True
            if not formset_is_empty(fs_fragility_func):
                error_add(
                    fs_fragility_func, '__all__',
                    "Vulnerability function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.FRAGILITY)
                any_error_found = True
            if not formset_is_empty(fs_damage_to_loss_func):
                error_add(
                    fs_damage_to_loss_func, '__all__',
                    "Vulnerability function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.DAMAGE_TO_LOSS)
                any_error_found = True
            if not formset_is_empty(fs_capacity_curve_func):
                error_add(
                    fs_capacity_curve_func, '__all__',
                    "Vulnerability function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.CAPACITY_CURVE)
                any_error_found = True

            fs_predictor_var = get_predictor_var(fs_vulnerability_func)
            if fs_predictor_var:
                cd_vulnerability_func = fs_vulnerability_func.forms[0].cleaned_data
                if cd_vulnerability_func['func_distr_type'] == FDT.CONTINUOUS:
                    cd_predictor_var = fs_predictor_var.forms[0].cleaned_data
                    if (cd_predictor_var['minimum_im'] == '' or
                        cd_predictor_var['minimum_im'] == None):
                        error_add(
                            fs_predictor_var, 'minimum_im',
                            "Continuous function distribution type selected. "
                            "This field is mandatory.")
                        any_error_found = True
                    if (cd_predictor_var['maximum_im'] == '' or
                        cd_predictor_var['maximum_im'] == None):
                        error_add(
                            fs_predictor_var, 'maximum_im',
                            "Continuous function distribution type selected. "
                            "This field is mandatory.")
                        any_error_found = True
            else:
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Malformed submission: predictor_var fieldset not found")
                any_error_found = True
            if not check_func_distr_type(
                    fs_vulnerability_func, 'func_distr_vuln'):
                any_error_found = True

        # DAMAGE TO LOSS
        elif type_of_assessment_idx == TA.DAMAGE_TO_LOSS:
            if formset_is_empty(fs_damage_to_loss_func):
                error_add(
                    fs_damage_to_loss_func, '__all__',
                    "Mandatory fields")
                any_error_found = True
            if not formset_is_empty(fs_fragility_func):
                error_add(
                    fs_fragility_func, '__all__',
                    "Damage to loss function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.FRAGILITY)
                any_error_found = True
            if not formset_is_empty(fs_vulnerability_func):
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Damage to loss function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.VULNERABILITY)
                any_error_found = True
            if not formset_is_empty(fs_capacity_curve_func):
                error_add(
                    fs_capacity_curve_func, '__all__',
                    "Damage to loss function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.CAPACITY_CURVE)
                any_error_found = True
            fs_func_distr_dtl_discr = formset_by_parent_and_rel_name(
                fs_damage_to_loss_func, 'func_distr_dtl_discr')
            if formset_is_empty(fs_func_distr_dtl_discr):
                error_add(
                    fs_func_distr_dtl_discr, '__all__',
                    "Mandatory fields")
                any_error_found = True

        # CAPACITY CURVE
        elif type_of_assessment_idx == TA.CAPACITY_CURVE:
            if formset_is_empty(fs_capacity_curve_func):
                error_add(
                    fs_capacity_curve_func, '__all__',
                    "Mandatory fields")
                any_error_found = True
            if not formset_is_empty(fs_fragility_func):
                error_add(
                    fs_fragility_func, '__all__',
                    "Capacity curve function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.FRAGILITY)
                any_error_found = True
            if not formset_is_empty(fs_damage_to_loss_func):
                error_add(
                    fs_damage_to_loss_func, '__all__',
                    "Capacity curve function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.DAMAGE_TO_LOSS)
                any_error_found = True
            if not formset_is_empty(fs_vulnerability_func):
                error_add(
                    fs_vulnerability_func, '__all__',
                    "Capacity curve function selected. "
                    "These fields must be void")
                not_empty_error_message(errors, type_of_assessment_idx,
                                        TA.VULNERABILITY)
                any_error_found = True
            fs_cc_predictor_var = formset_by_parent_and_rel_name(
                fs_capacity_curve_func, 'cc_predictor_var')
            if formset_is_empty(fs_cc_predictor_var):
                error_add(
                    fs_cc_predictor_var, '__all__',
                    "Mandatory fields")
                any_error_found = True

        if any_error_found:
            return False
        else:
            return True


def not_empty_error_message(errors, current_TA_idx, not_empty_TA_idx):
    errors.append(
        'The current type of assessment is %(current)s, '
        'but you have inserted data for the %(not_empty)s type too. '
        'If %(current)s type is correct, please select the %(not_empty)s '
        'type, clean the related information, then re-select %(current)s '
        'type. If the %(current)s type is wrong, please clean its related '
        'data before switching to %(not_empty)s type.' % {
            'current': OrderedDict(TYPES_OF_ASSESSMENT)[current_TA_idx],
            'not_empty': OrderedDict(TYPES_OF_ASSESSMENT)[not_empty_TA_idx]
            })


admin.site.unregister(GeneralInformation)
admin.site.register(GeneralInformation, GeneralInformationAdmin)


def get_predictor_var(parent_fieldset):
    fs_predictor_var = formset_by_parent_and_rel_name(
        parent_fieldset, 'predictor_var')
    if formset_is_empty(fs_predictor_var):
        error_add(
            fs_predictor_var, '__all__',
            "Mandatory fields")
        return False
    return fs_predictor_var


def check_func_distr_type(parent_fieldset, partial_rel_name):
    fs_func_distr_discr = formset_by_parent_and_rel_name(
        parent_fieldset, partial_rel_name + '_discr')
    fs_func_distr_cont = formset_by_parent_and_rel_name(
        parent_fieldset, partial_rel_name + '_cont')
    parent_form = parent_fieldset.forms[0]
    if ('func_distr_type' in parent_form.cleaned_data and
            parent_form.cleaned_data['func_distr_type'] == FDT.DISCRETE):
        if formset_is_empty(fs_func_distr_discr):
            error_add(
                fs_func_distr_discr, '__all__',
                "Mandatory fields")
            return False
    elif ('func_distr_type' in parent_form.cleaned_data and
            parent_form.cleaned_data['func_distr_type'] == FDT.CONTINUOUS):
        if formset_is_empty(fs_func_distr_cont):
            error_add(
                fs_func_distr_cont, '__all__',
                "Mandatory fields")
            return False
    return True
