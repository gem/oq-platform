/*
   Copyright (c) 2015, GEM Foundation.

      This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU Affero General Public License as
      published by the Free Software Foundation, either version 3 of the
      License, or (at your option) any later version.

      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU Affero General Public License for more details.

      You should have received a copy of the GNU Affero General Public License
      along with this program.  If not, see <https://www.gnu.org/licenses/agpl.html>.
*/

/////////////////////////////////
//////// Jquery Stuff ///////////
/////////////////////////////////

// Remove GeoNode artifact
$(".span12").remove();

$(function() {
    $("#accordion").accordion({
        collapsible: true,
        heightStyle: "content"
    });
});

/////////////////////////////////
/// Create Fragility Metadata ///
/////////////////////////////////

var assessmentType = gl.fields.type_of_assessment;
var funcName = gl.fields.name;
var year = gl.fields.year;
var webLink = gl.fields.web_link;
var generalComments = gl.fields.general_comments;
generalComments = escapeHtml(generalComments);
var useCase = gl.fields.use_case_information;
var authors = gl.fields.authors;
var category = gl.fields.category;
var publication = gl.fields.publication_conference_name;
var method = gl.fields.fragility_func.fields.method_of_estimation;
var articleTitle = gl.fields.article_title;
var funcDistrType = gl.fields.fragility_func.fields.func_distr_type;
var imtTitle = gl.fields.fragility_func.fields.predictor_var.fields.intensity_measure_type;
var imtUnite = gl.fields.fragility_func.fields.predictor_var.fields.intensity_measure_unit;

// Manage long function names
var funcNameLength = funcName.length;
var funcName1 = funcName;
var funcName2 = null;
if (funcNameLength > 50) {
    // Split the function name into two
    var funcNameArray = funcName.replace(/.{50}\S*\s+/g, "$&@").split(/\s+@/);
    funcName1 = funcNameArray[0];
    funcName2 = funcNameArray[1];
}

// Check if the variables are defined in the database
// and add them to the information dialog
// and do nothing if the information is not available in the database
try {
    var structureType =  gl.fields.structure_type;
} catch(e) {
    var structureType = '';
}

try {
    var limitStatesArray =  gl.fields.fragility_func.fields.limit_states_desc;
    var limitStatesArray = limitStatesArray.split(";");
} catch(e) {
    // Continue
}

try {
    var taxType = gl.fields.taxonomy_type.fields.name;
} catch(e) {

}

try {
    var taxText = gl.fields.taxonomy_text;
} catch(e) {
    // Continue
}

try {
    var typeOfPeriod = gl.fields.fragility_func.fields.predictor_var.fields.type_of_period;
} catch(e) {
    // Continue
}

try {
    var period = gl.fields.fragility_func.fields.predictor_var.fields.period;
} catch(e) {
    // Continue
}

var GeoError;
var GeoArea = '';
try {
    var geoApp = gl.fields.geo_applicability.fields.countries;
    GeoError = false;
} catch(e) {
    GeoError = true;
}

if (GeoError === false) {
    GeoArea = gl.fields.geo_applicability.fields.area;
    if (GeoArea === '') {
        GeoArea = '';
    } else {
        GeoArea = '('+GeoArea+')';
    }

    var countriesArray = [];

    for (var i = geoApp.length - 1; i >= 0; i--) {
        var tmp = " "+geoApp[i].fields.name;
        countriesArray.push(tmp);
    }
}

try {
    var cvOfMean = gl.fields.fragility_func.fields.func_distr_frag_cont.fields.coeff_variation_mean;
}
catch(e) {
    // Continue
}

try {
    var cvOfSD = gl.fields.fragility_func.fields.func_distr_frag_cont.fields.coeff_variation_std_dev;
} catch(e) {
    // Continue
}

function is_set(a) {
    return (a !== undefined && a !== "" && a !== null);
}

// Generral information
if (is_set(assessmentType)) {
    $("#genInfo").append('<p><b>Assessment Type: </b>'+assessmentType+'</p>');
}

if (is_set(funcName)) {
    funcName = funcName.replace(/_/g, ' ');
    $("#genInfo").append('<p><b>Name: </b>'+funcName+'</p>');
}

if (is_set(category)) {
    $("#genInfo").append('<p><b>Category: </b>'+category+' - '+structureType+'</p>');
}

if (is_set(taxText)) {
    $("#genInfo").append('<p><b>Taxonomy: </b>'+taxText+' ('+taxType+')</p>');
}

if (is_set(articleTitle)) {
    $("#genInfo").append('<p><b>Reference: </b>'+articleTitle+' ('+authors+', '+year+') - '+publication+'</p>');
}

if (gl.fields.web_link !== undefined && gl.fields.web_link != "") {
    var webLink = gl.fields.web_link;
    $("#genInfo").append('<p><b>Web Link: </b><a style="color:blue" href="'+webLink+'" target="_blank"> '+webLink+'</a></p>');
}

if (countriesArray.length > 0) {
    $("#genInfo").append('<p><b>Geographical Applicability: </b>'+countriesArray+' '+GeoArea+'</p>');
}

if (is_set(method)) {
    $("#genInfo").append('<p><b>Methodology: </b>'+method+'</p>');
}

if (is_set(generalComments)) {
    $("#genInfo").append('<p><b>General Comments: </b>'+generalComments+'</p>');
}

if (is_set(useCase)) {
    $("#genInfo").append('<p><b>Use Case Information: </b>'+useCase+'</p>');
}

// Modelling information

if (gl.fields.fragility_func.fields.damage_scale !== undefined && gl.fields.fragility_func.fields.damage_scale !== null ) {
    var damageScale =  gl.fields.fragility_func.fields.damage_scale;
    if (is_set(damageScale)) {
        $("#modellingInfo").append('<p><b>Damage scale: </b>'+damageScale+'</p>');
    }
}

if (gl.fields.fragility_func.fields.engineering_demand_par !== undefined && gl.fields.fragility_func.fields.engineering_demand_par !== null ) {
    var engineeringDemand =  gl.fields.fragility_func.fields.engineering_demand_par.fields.name;
    if (is_set(engineeringDemand)) {
        $("#modellingInfo").append('<p><b>Engineering demand parameter: </b>'+engineeringDemand+'</p>');
    }
}

try {
    var modelAnalysisType = gl.fields.fragility_func.fields.analytical_model_info.fields.analysis_type.fields.name;
    if (is_set(modelAnalysisType)) {
        $("#modellingInfo").append('<p><b>Analysis Type: </b>'+modelAnalysisType+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var modelType = gl.fields.fragility_func.fields.analytical_model_info.fields.model_type;
    if (is_set(modelType)) {
        $("#modellingInfo").append('<p><b>Model Type: </b>'+modelType+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var methodUncertPropag = gl.fields.fragility_func.fields.analytical_model_info.fields.method_uncert_propag;
    if (is_set(methodUncertPropag)) {
        $("#modellingInfo").append('<p><b>Method of Uncertainty Propagation: </b>'+methodUncertPropag+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var modelsNum = gl.fields.fragility_func.fields.analytical_model_info.fields.models_num;
    if (is_set(modelsNum)) {
        $("#modellingInfo").append('<p><b>Number of Distinct Structural Models Analysed: </b>'+modelsNum+'</p>');
    }
} catch(e) {
    // Continue
}

try{
    var aggrUnitDef = gl.fields.fragility_func.fields.empirical_model_info.fields.aggr_unit_def;
    if (is_set(aggrUnitDef)) {
        $("#modellingInfo").append('<p><b>Aggregated unit: </b>'+aggrUnitDef+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var empiricalStructuralUnit = gl.fields.fragility_func.fields.empirical_model_info.fields.structural_unit;
    if (is_set(empiricalStructuralUnit)) {
        $("#modellingInfo").append('<p><b>Structural unit: </b>'+empiricalStructuralUnit+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var buildingNum = gl.fields.fragility_func.fields.empirical_model_info.fields.building_x_class_num;
    if (is_set(buildingNum)) {
        $("#modellingInfo").append('<p><b>Number of buildings per class: </b>'+buildingNum+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    if(gl.fields.fragility_func.fields.analytical_model_info.fields.evaluation_of_im !== null) {
        var evaluationOfIM =  gl.fields.fragility_func.fields.analytical_model_info.fields.evaluation_of_im.fields.name;
        if (is_set(evaluationOfIM)) {
            $("#modellingInfo").append('<p><b>Evaluation of IM: </b>'+evaluationOfIM+'</p>');
        }
    }
} catch(e) {
    // Continue
}

try {
    if(gl.fields.fragility_func.fields.empirical_model_info.fields.evaluation_of_im !== null) {
        var evaluationOfIM =  gl.fields.fragility_func.fields.empirical_model_info.fields.evaluation_of_im.fields.name;
        if (is_set(evaluationOfIM)) {
            $("#modellingInfo").append('<p><b>Evaluation of IM: </b>'+evaluationOfIM+'</p>');
        }
    }
} catch(e) {
    // Continue
}

try {
    var empiricalDataSrc =  gl.fields.fragility_func.fields.empirical_model_info.fields.empirical_data_src;
    if (is_set(empiricalDataSrc)) {
        $("#modellingInfo").append('<p><b> Source of empirical data: </b>'+empiricalDataSrc+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var buildingAggr =  gl.fields.fragility_func.fields.empirical_model_info.fields.building_aggr;
    if (is_set(buildingAggr)) {
        $("#modellingInfo").append('<p><b> Building aggregation: </b>'+buildingAggr+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var buildingsMin =  gl.fields.fragility_func.fields.empirical_model_info.fields.building_aggr_min_num;
    if (is_set(buildingsMin)) {
        $("#modellingInfo").append('<p><b> Minimum Number of grouped buildings: </b>'+buildingsMin+'</p>');
    }
} catch(e) {
    // Continue
}

// Statistical Information
try {
    var statModel = gl.fields.fragility_func.fields.stat_info.fields.stat_model.fields.name;
    if (is_set(statModel)) {
        $("#statInfo").append('<p><b>Statistical Model: </b>'+statModel+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var statModelFittingMethod = gl.fields.fragility_func.fields.stat_info.fields.stat_model_fitting_method.fields.name;
    if (is_set(statModelFittingMethod)) {
        $("#statInfo").append('<p><b>Statistical model fitting method: </b>'+statModelFittingMethod+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var modelFittingMethodAssumptions = gl.fields.fragility_func.fields.stat_info.fields.model_fitting_method_assumptions.fields.name;
    if (is_set(modelFittingMethodAssumptions)) {
        $("#statInfo").append('<p><b>Model Fitting Method Assumption: </b>'+modelFittingMethodAssumptions+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var fitAssessmentGoodness = gl.fields.fragility_func.fields.stat_info.fields.fit_assessment_goodness.fields.name;
    if (is_set(fitAssessmentGoodness)) {
        $("#statInfo").append('<p><b>Goodness of fit assessment (GLM/GAM): </b>'+fitAssessmentGoodness+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var procConstrPredInt = gl.fields.fragility_func.fields.stat_info.fields.proc_constr_pred_int.fields.name;
    if (is_set(procConstrPredInt)) {
        $("#statInfo").append('<p><b>Procedure for the Construction of Prediction Intervals: </b>'+procConstrPredInt+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var procConstrConfInt = gl.fields.fragility_func.fields.stat_info.fields.proc_constr_conf_int.fields.name;
    if (is_set(procConstrConfInt)) {
        $("#statInfo").append('<p><b>Procedure for the Construction of Confidence Intervals: </b>'+procConstrConfInt+'</p>');
    }
} catch(e) {
    // Continue
}

//  Quality rating system

try {
    var structuralDetails = gl.fields.fragility_func.fields.qrs_analytical.fields.structural_details;
    if (is_set(structuralDetails)) {
        $("#qualitySys").append('<p><b>Structural details: </b>'+structuralDetails+'</p>');
    }
} catch(e) {
    // Continue
}

try{
    var modelCompleteness = gl.fields.fragility_func.fields.qrs_analytical.fields.model_completeness;
    if (is_set(modelCompleteness)) {
        $("#qualitySys").append('<p><b>Completeness of model: </b>'+modelCompleteness+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var seismicDemand = gl.fields.fragility_func.fields.qrs_analytical.fields.seismic_demand;
    if (is_set(seismicDemand)) {
        $("#qualitySys").append('<p><b>Seismic demand: </b>'+seismicDemand+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var analysisType = gl.fields.fragility_func.fields.qrs_analytical.fields.analysis_type;
    if (is_set(analysisType)) {
        $("#qualitySys").append('<p><b>Analysis type: </b>'+analysisType+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var limitStatesDef = gl.fields.fragility_func.fields.qrs_analytical.fields.limit_states_def;
    if (is_set(limitStatesDef)) {
        $("#qualitySys").append('<p><b>Definition of Limit States: </b>'+limitStatesDef+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var samplingMethod = gl.fields.fragility_func.fields.qrs_analytical.fields.sampling_method;
    if (is_set(samplingMethod)) {
        $("#qualitySys").append('<p><b>Sampling method: </b>'+samplingMethod+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var crossValidation = gl.fields.fragility_func.fields.qrs_analytical.fields.sampling_method;
    if (is_set(crossValidation)) {
        $("#qualitySys").append('<p><b>Cross validation: </b>'+crossValidation+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var uncertaintiesTreatment = gl.fields.fragility_func.fields.qrs_analytical.fields.sampling_method;
    if (is_set(uncertaintiesTreatment)) {
        $("#qualitySys").append('<p><b>Treatment of uncertainties: </b>'+uncertaintiesTreatment+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var documentationQuality = gl.fields.fragility_func.fields.qrs_analytical.fields.documentation_quality;
    if (is_set(documentationQuality)) {
        $("#qualitySys").append('<p><b>Documentation quality: </b>'+documentationQuality+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var documentationType = gl.fields.fragility_func.fields.qrs_analytical.fields.documentation_type;
    if (is_set(documentationType)) {
        $("#qualitySys").append('<p><b>Type of documentation: </b>'+documentationType+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var typologyRep = gl.fields.fragility_func.fields.qrs_analytical.fields.typology_repr;
    if (is_set(typologyRep)) {
        $("#qualitySys").append('<p><b>Representation of typology: </b>'+typologyRep+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var siteSpecific = gl.fields.fragility_func.fields.qrs_analytical.fields.site_specific;
    if (is_set(siteSpecific)) {
        $("#qualitySys").append('<p><b>Site specific: </b>'+siteSpecific+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var hazardModel = gl.fields.fragility_func.fields.qrs_analytical.fields.hazard_model;
    if (is_set(hazardModel)) {
        $("#qualitySys").append('<p><b>Hazard model: </b>'+hazardModel+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var dataQuantity = gl.fields.fragility_func.fields.qrs_empirical.fields.data_quantity;
    if (is_set(dataQuantity)) {
        $("#qualitySys").append('<p><b>Data quality: </b>'+dataQuantity+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var constrainedCategories = gl.fields.fragility_func.fields.qrs_empirical.fields.constrained_categories;
    if (is_set(constrainedCategories)) {
        $("#qualitySys").append('<p><b>Constrained categories: </b>'+constrainedCategories+'</p>');
    }
} catch(e) {
    // Continue
}

try{
    var excitationObservation = gl.fields.fragility_func.fields.qrs_empirical.fields.excitation_observation;
    if (is_set(excitationObservation)) {
        $("#qualitySys").append('<p><b>Excitation observations: </b>'+excitationObservation+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var damageLossObservation = gl.fields.fragility_func.fields.qrs_empirical.fields.damage_loss_observation;
    if (is_set(damageLossObservation)) {
        $("#qualitySys").append('<p><b>Damage/loss observation: </b>'+damageLossObservation+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var firstPrinciples = gl.fields.fragility_func.fields.qrs_empirical.fields.first_principles;
    if (is_set(firstPrinciples)) {
        $("#qualitySys").append('<p><b>First principles: </b>'+firstPrinciples+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var hindcasting = gl.fields.fragility_func.fields.qrs_empirical.fields.hindcasting;
    if (is_set(hindcasting)) {
        $("#qualitySys").append('<p><b>Hindcasting: </b>'+hindcasting+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var crossValidation = gl.fields.fragility_func.fields.qrs_empirical.fields.cross_validation;
    if (is_set(crossValidation)) {
        $("#qualitySys").append('<p><b>Cross validation: </b>'+crossValidation+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var uncertaintiesTreatment = gl.fields.fragility_func.fields.qrs_empirical.fields.uncertainties_treatment;
    if (is_set(uncertaintiesTreatment)) {
        $("#qualitySys").append('<p><b>Treatment of uncertainties: </b>'+uncertaintiesTreatment+'</p>');
    }
} catch(e) {
    // Continue
}

try {
    var documentationQuality = gl.fields.fragility_func.fields.qrs_empirical.fields.documentation_quality;
    if (is_set(documentationQuality)) {
        $("#qualitySys").append('<p><b>Documentation quality: </b>'+documentationQuality+'</p>');
    }
} catch(e) {
    // Continue
}

try{
    var documentationType = gl.fields.fragility_func.fields.qrs_empirical.fields.documentation_type;
    if (is_set(documentationType)) {
        $("#qualitySys").append('<p><b>Type of documentation: </b>'+documentationType+'</p>');
    }
} catch(e) {
    // Continue
}

// Check to see if the accordions are full or empty
is_empty('modellingInfo');
is_empty('statInfo');
is_empty('qualitySys');

function is_empty(b) {
    if ( $('#'+b).children().length === 0) {
        $('#'+b+'-header').css({'color' : 'LightGray'});
    }
}

/////////////////////////////////
///// Continuous Data Table /////
/////////////////////////////////

function continuousTable() {

    var aaData = [];
    cvOfMean = cvOfMean.split(";");
    cvOfSD = cvOfSD.split(";");
    var tmpMean = [];
    var tmpSD = [];
    var tmpCvMean = [];
    var tmpCvSD = [];
    tmpMean.push("Mean");
    tmpSD.push("Standard Deviation (SD)");
    var imtUniteAlt = "";

    if (imtUnite == "Roman numbers") {
        imtUnite = "";
    } else {
        imtUniteAlt = '('+imtUnite+')';
    }

    if(cvOfMean.length > 1) {
        tmpCvMean.push("Coefficient of variation of the Mean");
    }

    if (cvOfSD.length > 1) {
        tmpCvSD.push("Coefficient of variation of the SD");
    }

    for (var i = 0; i < limitStatesArray.length; i++) {
        tmpMean.push(parseFloat(meanArray[i]));
        tmpSD.push(parseFloat(stddevArray[i]));
        if (cvOfMean.length > 1) {
            tmpCvMean.push(parseFloat(cvOfMean[i]));
            tmpCvSD.push(parseFloat(cvOfSD[i]));
        }
    }

    aaData.push(tmpMean, tmpSD);

    if(cvOfMean.length > 1) {
        aaData.push(tmpCvMean);
    }

    if(cvOfSD.length > 1) {
        aaData.push(tmpCvSD);
    }

    // build the table header
    var header = [];

    header.push({"sTitle": imtTitle+' '+imtUniteAlt});
    var placeHolder = '<th>place holder</th>';
    var length = limitStatesArray.length;

    for (var j = 0; j < limitStatesArray.length; j++) {
        var tmpObj = {};
        limitStatesArray[j] = limitStatesArray[j].replace(/([a-z])([A-Z])/g, '$1 $2');
        tmpObj.sTitle = limitStatesArray[j];
        header.push(tmpObj);
        placeHolder = placeHolder.concat('<th>place holder</th>');
    }

    $('#function-table').append(
        '<thead id="tablehead">'+
            '<tr>'+
                '<th rowspan="1">Intensity Measure</th>'+
                '<th colspan="4">Damage State</th>'+
            '</tr>'+
            '<tr>'+
                placeHolder+
            '</tr>'+
        '</thead>'
    );

    $('#function-table').dataTable({
        "aaData": aaData,
        "aoColumns": header,
        "aaSorting": [],
        "bLengthChange": false,
        "bFilter": false,
        "bPaginate": false,
        "bInfo": false,
        "bSort": false
    });

}

////////////////////////////////////////////////////
///// Continuous Data Table Correlation Matrix /////
////////////////////////////////////////////////////

try {
    var predCorrMatrix = gl.fields.fragility_func.fields.func_distr_frag_cont.fields.predictor_var_corr_matrix;
    if (predCorrMatrix !== undefined && predCorrMatrix !== "") {
        correlationMatrixTable();
    }
} catch(e) {
    // Continue
}

function correlationMatrixTable() {
    $('#matrixTableLabel').append('<p><b>Correlation Matrix Table</b></p>');

    var placeHolder = "";
    placeHolder = placeHolder.concat('<th>place holder</th>');
    var tempData = [];
    var inputData = predCorrMatrix.split('\n');
    var dataCleaned = [];
    var header = [];

    var limitStatesArrayColumLables = [];

    // Setup the column lables
    for (var n = 0; n < limitStatesArray.length; n++) {
        limitStatesArrayColumLables.push(limitStatesArray[n]);
        limitStatesArrayColumLables.push(limitStatesArray[n]);
    }

    // Setup the row lables
    var limitStatesArrayColumLablesYAxis = [];

    for (var o = 0; o < limitStatesArray.length; o++) {
        limitStatesArrayColumLablesYAxis.push(limitStatesArray[o]+'(µ)');
        limitStatesArrayColumLablesYAxis.push(limitStatesArray[o]+'(σ)');
    }

    // header used for the first column
    header.push({sTitle:"Limit State"});

    // Build the column headers
    for (var i = 0; i < inputData.length; i++) {
        tempData.push([inputData[i]]);
        var tmpObj = {};
    }

    for (var i = 0; i < limitStatesArray.length; i++) {
        header.push({sTitle : limitStatesArray[i]+'(µ)'});
        header.push({sTitle : limitStatesArray[i]+'(σ)'});
    }

    // Setup the data for the table
    for (var k in tempData) {

        var tmp2 = [];
        tmp = tempData[k].toString();
        tmp = tmp.split(";");

        // Add table row lables
        tmp2.push(limitStatesArrayColumLablesYAxis[k]);

        for (var m = 0; m < tmp.length; m++) {
            tmp2.push(parseFloat(tmp[m]));
        }
        dataCleaned.push(tmp2);
        placeHolder = placeHolder.concat('<th>place holder</th>');
    }

    // Inject the table
    $('#matrix-table').append(
        '<thead id="matrixTablehead">'+
            '<tr>'+
                placeHolder+
            '</tr>'+
        '</thead>'
    );

    $('#matrix-table').dataTable({
        "aaData": dataCleaned,
        "aoColumns": header,
        "aaSorting": [],
        "bLengthChange": false,
        "bFilter": false,
        "bPaginate": false,
        "bInfo": false,
        "bSort": false
    });
}



//////////////////////////////////////////////
/// Create Fragility Curves - Continuous /////
//////////////////////////////////////////////

function normalCumulativeProbability(z) {
    var b1 = 0.31938153;
    var b2 = -0.356563782;
    var b3 = 1.781477937;
    var b4 = -1.821255978;
    var b5 = 1.330274429;
    var p = 0.2316419;
    var c2 = 0.3989423;
    if (z > 6.0){
        return 1.0;}  // this guards against overflow
    if (z < -6.0){
        return 0.0;}
    var a = Math.abs(z);
    var t = 1.0 / (1.0 + a * p);
    var b = c2 * Math.exp((-z)*(z / 2.0));
    var n = ((((b5 * t + b4) * t + b3) * t + b2) * t + b1) * t;
    var n = 1.0 - b * n;
    if (z < 0.0){
        n = 1.0 - n;}
    return n;
}

function makeFragilityFunctionContinuous(mean, stddev) {
    var variance = stddev * stddev;
    var sigma = Math.sqrt(Math.log((variance / (mean * mean)) + 1.0));

    mu = (mean * mean) / Math.sqrt(variance + mean * mean);

    return function(iml) {
       return normalCumulativeProbability((Math.log(iml / mu)) / sigma);
    };
}

function capitalize(str) {
    return str.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
}

function fragilityData() {
    $("#fragilityDataDialog").append("<b>Limit States, Mean, Stddev: </b></br>");
    for (var i = 0; i < limitStatesArray.length; i++) {
        var ls = capitalize(limitStatesArray[i]);
        $("#fragilityDataDialog").append(ls +", "+ meanArray[i] +", "+ stddevArray[i] +"</br>");
    }
}

if(funcDistrType == "Continuous") {
    // Get values out of JSON
    var dataObj = {};
    var chartData = [];
    var iml = [];
    var stddevArray = gl.fields.fragility_func.fields.func_distr_frag_cont.fields.std_dev;
    stddevArray = stddevArray.split(";");
    var meanArray = gl.fields.fragility_func.fields.func_distr_frag_cont.fields.mean;
    meanArray = meanArray.split(";");

    var min = gl.fields.fragility_func.fields.predictor_var.fields.minimum_im;
    var max = gl.fields.fragility_func.fields.predictor_var.fields.maximum_im;

    var inc = ((max - min) / 100);
    var limitStatesArray =  gl.fields.fragility_func.fields.limit_states_desc;
    limitStatesArray = limitStatesArray.split(";");

    for (var i = 0; i < limitStatesArray.length; i++)
        limitStatesArray[i] = limitStatesArray[i].trim();

    for (var j = 0; j < limitStatesArray.length; j++) {
        dataObj[limitStatesArray[j]] = [];
    }

    for (var l = 0; l < limitStatesArray.length; l++) {
        dataObj[limitStatesArray[l]] = [parseFloat(meanArray[l]), parseFloat(stddevArray[l])];
    }

    // create the x axis values
    for(var m=min; m<max;m=m+inc) {
        iml.push(Math.round(m*1000) / 1000);
    }
    iml.push(max);

    for (var k in dataObj) {
        var tmp = makeFragilityFunctionContinuous(dataObj[k][0], dataObj[k][1]);
        chartData[k] = [];
        for (var n = 0; n < iml.length; n++) {
            var val = tmp(iml[n]);
            chartData[k].push([iml[n], val]);
        }
    }

    continuousTable();
    buildChart(chartData);


    ////////////////////////////////////////////
    /// Create Fragility Curves - Discrete /////
    ////////////////////////////////////////////

} else if (funcDistrType == "Discrete") {
    var chartData = [];

    var limitStateVal = gl.fields.fragility_func.fields.func_distr_frag_discr.fields.limit_state_prob_exceed;
    limitStateVal = limitStateVal.split('\n');

    var LSProbExceed = gl.fields.fragility_func.fields.func_distr_frag_discr.fields.limit_state_prob_exceed;
    LSProbExceed = LSProbExceed.split(";");
    // yAxisVals is used to get the max value for the chart
    yAxisVals = [];
    for (var i = 0; i < LSProbExceed.length; i++) {
        yAxisVals.push(parseFloat(LSProbExceed[i]));
    }

    for (var i = 0; i < limitStateVal.length; i++) {
        limitStateVal[limitStatesArray[i]] = limitStateVal[i].split(";");
    }

    for (var i = 0; i < 4 ; i++) {
        limitStateVal.shift();
    }

    var predVarVal = gl.fields.fragility_func.fields.func_distr_frag_discr.fields.predictor_var_im_val;
    predVarVal = predVarVal.split(";");

    for (var i = 0; i < limitStatesArray.length; i++) {
        chartData[limitStatesArray[i]] = [];
    }

    for(var k in chartData) {
        var LSProbExceed = [];
        for (var i = 0; i < predVarVal.length; i++) {
            var foo = [parseFloat(predVarVal[i]), parseFloat(limitStateVal[k][i])];
            LSProbExceed.push(foo);
        }
        chartData[k] = LSProbExceed;
    }

    buildChart(chartData);
    discreteTable();
}


////////////////////////////////
///// Discrete Data Table //////
////////////////////////////////

function discreteTable() {
    var aaData = [];

    var limitState = gl.fields.fragility_func.fields.func_distr_frag_discr.fields.limit_state_prob_exceed;
    limitState = limitState.split('\n');

    for (var i = 0; i < limitState.length; i++) {
        limitState[i] = limitState[i].split(";");
    }

    if (gl.fields.fragility_func.fields.func_distr_frag_discr.fields.limit_state_prob_exceed_05 != "") {

        var limitState05 = gl.fields.fragility_func.fields.func_distr_frag_discr.fields.limit_state_prob_exceed_05;
        var limitState95 = gl.fields.fragility_func.fields.func_distr_frag_discr.fields.limit_state_prob_exceed_95;
        limitState05 = limitState05.split('\n');
        limitState95 = limitState95.split('\n');

        for (var j = 0; j < limitState05.length; j++) {
            limitState05[j] = limitState05[j].split(";");
        }

        for (var l = 0; l < limitState95.length; l++) {
            limitState95[l] = limitState95[l].split(";");
        }

        for (var m = 0; m < predVarVal.length; m++) {
            var tmp = [];
            tmp.push(predVarVal[m]);

            for (var n = 0; n < limitState.length; n++) {
                tmp.push(limitState[n][m]);
                tmp.push(limitState05[n][m]);
                tmp.push(limitState95[n][m]);
            }
            aaData.push(tmp);
        }

        // build the table header
        var header = [];
        header.push({"sTitle": "PGA (g)"});
        var placeHolder = "<th>place holder</th>";
        var length = limitStatesArray.length;

        for (var o = 0; o < limitStatesArray.length; o++) {
            var tmpObj = {};
            limitStatesArray[o] = limitStatesArray[o].replace(/([a-z])([A-Z])/g, '$1 $2');
            tmpObj.sTitle = limitStatesArray[o];
            header.push(tmpObj);
            placeHolder = placeHolder.concat("<th>place holder</th>");
        }

        for (var q = 0; q < limitStatesArray.length; q++) {
            var tmpObj = {};
            limitStatesArray[q] = limitStatesArray[q].replace(/([a-z])([A-Z])/g, '$1 $2');
            tmpObj.sTitle = limitStatesArray[q];
            header.push(tmpObj);
            placeHolder = placeHolder.concat("<th>place holder</th>");
        }

        for (var r = 0; r < limitStatesArray.length; r++) {
            var tmpObj = {};
            limitStatesArray[r] = limitStatesArray[r].replace(/([a-z])([A-Z])/g, '$1 $2');
            tmpObj.sTitle = limitStatesArray[r];
            header.push(tmpObj);
            placeHolder = placeHolder.concat("<th>place holder</th>");
        }

        $('#function-table').append(
            '<thead id="tablehead">'+
                '<tr>'+
                    '<th rowspan="1">'+imtTitle+' ('+imtUnite+')</th>'+
                    '<th colspan="4">Probability of limit state exceedance</th>'+
                    '<th colspan="4">Probability of limit state exceedance (5% prediction interval)</th>'+
                    '<th colspan="4">Probability of limit state exceedance (95% prediction interval)</th>'+
                '</tr>'+
                '<tr>'+
                    placeHolder+
                '</tr>'+
            '</thead>'
        );

        // Header array will overwright all placeholder tags
        $('#function-table').dataTable({
            "aaData": aaData,
            "aoColumns": header,
            "bLengthChange": false,
            "bFilter": false
        });

    } else {
        var imtUniteAlt= "";
        if (imtUnite == "Roman numbers") {
            imtUnite = "";
            imtUniteAlt = "";
        } else {
            imtUniteAlt = '('+imtUnite+')';
        }

        for (var s = 0; s < predVarVal.length; s++) {
            var tmp = [];
            tmp.push(predVarVal[s]);
            for (var t = 0; t < limitState.length; t++) {
                tmp.push(limitState[t][s]);
            }
            aaData.push(tmp);
        }

        predVarVal = predVarVal.map(parseFloat);

        // build the table header
        var header = [];
        header.push({"sTitle": imtTitle+' '+imtUniteAlt});

        var placeHolder = "<th>place holder</th>";
        var length = limitStatesArray.length;

        for (var u = 0; u < limitStatesArray.length; u++) {
            var tmpObj = {};
            limitStatesArray[u] = limitStatesArray[u].replace(/([a-z])([A-Z])/g, '$1 $2');
            tmpObj.sTitle = limitStatesArray[u];
            header.push(tmpObj);
            placeHolder = placeHolder.concat("<th>place holder</th>");
        }

        $('#function-table').append(
            '<thead id="tablehead">'+
                '<tr>'+
                    '<th rowspan="1">Intensity Measure</th>'+
                    '<th colspan="'+length+'">Probability of limit state exceedance</th>'+
                '</tr>'+
                '<tr>'+
                    placeHolder+
                '</tr>'+
            '</thead>'
        );

        // Header array will overwright all placeholder tags
        $('#function-table').dataTable({
            "aaData": aaData,
            "aoColumns": header,
            "bLengthChange": false,
            "bFilter": false
        });
    }
}


///////////////////////////
///// Fragility Chart  ////
///////////////////////////

function buildChart(chartData) {

    //prep the X axis lable
    var xAxisLable = "";
    if (imtTitle == "PGA") {
        xAxisLable = imtTitle+" ["+imtUnite+"]";
    } else if (imtTitle == "Sa(T)") {
        xAxisLable = imtTitle + " [" +imtUnite+ "] - T =" +typeOfPeriod+ " = "+period;
    } else if (imtTitle == "Sd(T)") {
        xAxisLable = imtTitle + " [" +imtUnite+ "] - T =" +typeOfPeriod+ " = "+period;
    } else if (imtTitle == "MMI") {
        xAxisLable = imtTitle;
    } else if (imtTitle == "PGV") {
        xAxisLable = imtTitle + " [" +imtUnite+ "]";
    } else if (imtTitle == "PGD") {
        xAxisLable = imtTitle + " [" +imtUnite+ "]";
    } else if (imtTitle == "IA") {
        xAxisLable = imtTitle + " [" +imtUnite+ "]";
    } else if (imtTitle == "CAV") {
        xAxisLable = imtTitle + " [" +imtUnite+ "]";
    } else if (imtTitle == "RSD") {
        xAxisLable = imtTitle + " [" +imtUnite+ "]";
    }

     // grid line functions
    function make_x_axis() {
        return d3.svg.axis()
            .scale(x_scale)
            .orient("bottom")
            .ticks(5);
    }
    function make_y_axis() {
        return d3.svg.axis()
            .scale(y_scale)
            .orient("left")
            .ticks(5);
    }
    function capitalise(string) {
        return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
    }
    function makeCircles(chartData, color, elementName) {
        svg.selectAll("circle.line")
            .data(chartData)
            .enter().append("circle")
            .attr("class", "line"+elementName)
            .attr("cx", function(d) { return x_scale(d[0]); })
            .attr("cy", function(d) { return y_scale(d[1]); })
            .attr("r", 2.5)
            .style("fill", color)
            .style("opacity", 1)
            .on("mouseover", function() {
                d3.select(this)
                    .attr('r', 6)
                    .text(circleX + ", " + circleY)
                    .style("fill", color)
                    .style("opacity", 1);
                var circleX = d3.select(this.__data__[0]);
                circleX = circleX.toString();
                circleX = circleX.split(","[0]);

                var circleY = d3.select(this.__data__[1]);

                circleY = circleY.toString();

                textTop.text("Point value (x/y): " + Math.round(circleX * 1000) / 1000 + ", " + Math.round(circleY * 1000) / 1000);

            }).on("mouseout", function() {
                d3.select(this)
                    .attr('r', 2.5)
                    .style("opacity", 1)
                    .style("fill", color);
            });
    }

    // Get the chart length in order to dynamically extend the height of the chart
    // so the labels will fit
    var chartLength = [];

    for (var p in chartData) {
        chartLength.push(p);
    }

    var margin = {top: 55, right: 10, bottom: (80 + (14*chartLength.length)), left: 60},
    width = 480 - margin.left - margin.right,
    height = (440 + (14*chartLength.length)) - margin.top - margin.bottom;

    if (predVarVal != undefined) {
        predVarVal = predVarVal.map(parseFloat);
    }

    if (funcDistrType == "Continuous") {
        var x_scale = d3.scale.linear().range([0, width]).domain([d3.min(iml), d3.max(iml)]);
        var y_scale = d3.scale.linear().range([0, height]).domain([1, 0]);
    }
    else if (funcDistrType == "Discrete") {
        var x_scale = d3.scale.linear().range([0, width]).domain([d3.min(predVarVal), d3.max(predVarVal)]);
        var y_scale = d3.scale.linear().range([0, height]).domain([d3.max(yAxisVals), d3.min(yAxisVals)]);
    }

    var xAxis = d3.svg.axis()
        .scale(x_scale)
        .tickFormat(function (d) { return d; })
        .ticks(10)
        .orient("bottom");

    var yAxis = d3.svg.axis()
        .scale(y_scale)
        .orient("left");

    var line = d3.svg.line()
        .x(function(d) {
            return x_scale(d[0]);
        })
        .y(function(d) {
            return y_scale(d[1]);
        });

    var svg = d3.select("#functionChart").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // grid lines
    svg.append("g")
        .attr("class", "grid")
        .attr("transform", "translate(0," + height + ")")
        .call(make_x_axis()
            .tickSize(-height, 0, 0)
            .tickFormat("")
        );

    svg.append("g")
        .attr("class", "grid")
        .call(make_y_axis()
            .tickSize(-width, 0, 0)
            .tickFormat("")
        );

    var legend = d3.select("#chartDialog").append("svg")
        .attr("height", 25);
    var count = 0;

    for (var k in chartData) {
        var elementName = k;
        elementName = elementName.replace(/\s/g, '');

        svg.append("path")
            .data([chartData[k]])
            .attr("class", "line"+elementName)
            .attr("d", line);

        // Update the css for each line
        if (chartData.hasOwnProperty(k)) {
            ++count;
        }
        colors = [
            "darkred",
            "blue",
            "green",
            "orange",
            "darksalmon",
            "red",
            "lightseagreen",
            "skyblue",
            "sandybrown",
            "yellowgreen"
        ];

        var color = colors[count % colors.length];
        $(".line"+elementName).css({'fill': "none",'opacity':'0.6', 'stroke-width': '2', 'stroke':color});
        var data = chartData[k];
        var curveTitle = k;

        if (funcDistrType == "Discrete") {
            makeCircles(chartData[k], color, elementName);
        }

        curveTitle = curveTitle.replace(/([a-z])([A-Z])/g, '$1 $2');

        // Curve lables
        svg.append("text")
            .attr("x", 20)
            .attr("y", 340+(count * 16))
            .attr("dy", ".35em")
            .text(curveTitle);

        svg.append("svg:circle")
            .attr("cy", 340+(count *16))
            .attr("cx", 0)
            .attr("r", 3)
            .attr("opacity", 0.6)
            .style("fill", color);
    } // End loop

        svg.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

        // x axis lable
        svg.append("text")
            .attr("x", width / 2 )
            .attr("y",  height + 40)
            .style("font-size","14px")
            .style("font-weight", "bold")
            .style("text-anchor", "middle")
            .text(xAxisLable);

        svg.append("g")
            .attr("class", "y axis")
            .call(yAxis)
            .append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", -60)
            .attr("x", -60)
            .attr("dy", ".71em")
            .style("font-size","14px")
            .style("font-weight", "bold")
            .style("text-anchor", "end")
            .text("Probabability of exceedance");

        svg.append("text")
            .attr("x", width / 2)
            .attr("y", -35)
            .attr("dy", ".35em")
            .style("font-weight", "bold")
            .style("text-anchor", "middle")
            .style("font-size"," 14px")
            .text(assessmentType+ ' ' +funcName1);

        if (funcName2 !== null) {
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -15)
                .attr("dy", ".35em")
                .style("font-weight", "bold")
                .style("text-anchor", "middle")
                .style("font-size"," 14px")
                .text(funcName2);
        }

        textTop = svg.append("text")
            .attr("x", width / 2 )
            .attr("y", -15)
            .attr("dy", ".35em")
            .style("text-anchor", "middle")
            .text("");
} // End Chart

