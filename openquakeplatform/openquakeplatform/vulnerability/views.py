# Copyright (c) 2012-2015, GEM Foundation.
#
# This program is free software: you can redistribute it and/or modify
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import json
from scipy import stats
import numpy
from lxml import etree
import re
try:
    from django.contrib.admin.options import force_unicode
except ImportError:
    from django.utils.encoding import force_text as force_unicode

from django.core.exceptions import ObjectDoesNotExist
from django.http import (HttpResponse,
                         HttpResponseNotFound,
                         Http404,
                         )
from django.shortcuts import render_to_response
from django.core import serializers
from django.core.serializers.json import DjangoJSONEncoder
from django.template import RequestContext
from django.views.generic.detail import BaseDetailView
from django.utils.cache import add_never_cache_headers
from django.utils.text import slugify
from django.contrib import messages
from django.contrib.auth.models import User
from django.shortcuts import redirect

from models import (GeneralInformation,
                    CAT, CATEGORIES,
                    IMT, INTENSITY_MEASURE_TYPES,
                    IMU,
                    EDP,
                    RVP, RESP_VAR_PAR,
                    RVU, RESP_VAR_UNITS,
                    EDU,
                    TA, TYPES_OF_ASSESSMENT,
                    FDT,
                    FUNC_DISTR_TYPES,  # NOTE: Never used
                    RV, FDS, FUNC_DISTR_SHAPES_ALL,
                    FUNC_DISTR_SHAPES_NRML_ALL)
from forms import FiltersForm

SERIALIZE_NS_MAP = {None: 'http://openquake.org/xmlns/nrml/0.4',
                    'gml': 'http://www.opengis.net/gml'}
CART_INFO_SFX = "collection of curves to export as a single NRML file"


def index(request, **kwargs):
    return HttpResponse("Hello world!")


def list(request, **kwargs):
    """Main listing."""
    geninfo = GeneralInformation.objects.all()
    user = User.objects.get(username=request.user.username)
    cart = GeneralInformation.objects.filter(cart=user)
    types_of_assessment = dict(
        (key, value) for (key, value) in TYPES_OF_ASSESSMENT)

    try:
        curve_id = int(request.POST.get("curve_id",
                                        request.GET.get("curve_id", -1)))
        if curve_id < 0:
            curve_id = ""
    except ValueError as e:
        print 'Invalid curve id: %s' % e
        curve_id = ""

    curve = None
    if curve_id:
        try:
            curve = geninfo.get(pk=curve_id)
        except ObjectDoesNotExist:
            print 'Invalid curve id: %s' % e
            curve_id = ""

    if curve:
        type_of_assessment = curve.type_of_assessment
    else:
        try:
            type_of_assessment = int(
                request.POST.get("type_of_assessment",
                                 request.GET.get("type_of_assessment",
                                                 TA.FRAGILITY)))
        except ValueError as e:
            print 'Invalid type of assessment: %s' % e
            type_of_assessment = TA.FRAGILITY
    page_title = ("Vulnerability: list of %s functions" %
                  types_of_assessment[type_of_assessment].lower())

    geninfo = geninfo.filter(type_of_assessment=type_of_assessment)
    category = request.POST.get('category')
    material = request.POST.get('material')
    llrs = request.POST.get('llrs')
    author = request.POST.get('author')
    method_of_estimation = request.POST.get('method_of_estimation')
    intensity_measure_type = request.POST.get('intensity_measure_type')
    damage_scale = request.POST.get('damage_scale')
    country = request.POST.get('country')
    region = request.POST.get('region')
    if category:
        geninfo = geninfo.filter(category=category)
    geninfo = geninfo.filter(type_of_assessment=type_of_assessment)
    if type_of_assessment == TA.FRAGILITY:
        if method_of_estimation:
            geninfo = geninfo.filter(
                fragility_func__method_of_estimation=method_of_estimation)
        if intensity_measure_type:
            geninfo = geninfo.filter(
                fragility_func__predictor_var__intensity_measure_type=
                intensity_measure_type)
        if damage_scale:
            geninfo = geninfo.filter(
                fragility_func__damage_scale=damage_scale)
    elif type_of_assessment == TA.VULNERABILITY:
        if method_of_estimation:
            geninfo = geninfo.filter(
                vulnerability_func__method_of_estimation=method_of_estimation)
        if intensity_measure_type:
            geninfo = geninfo.filter(
                vulnerability_func__predictor_var__intensity_measure_type=
                intensity_measure_type)
    elif type_of_assessment == TA.DAMAGE_TO_LOSS:
        if method_of_estimation:
            geninfo = geninfo.filter(
                damage_to_loss_func__method_of_estimation=method_of_estimation)
        if damage_scale:
            geninfo = geninfo.filter(
                damage_to_loss_func__damage_scale=damage_scale)
    elif type_of_assessment == TA.CAPACITY_CURVE:
        if method_of_estimation:
            geninfo = geninfo.filter(
                capacity_curve_func__method_of_estimation=
                method_of_estimation)
    re_pre = r'(^|[/:+,])'
    re_post = r'([/:+,]|$)'
    if material:
        geninfo = geninfo.filter(
            taxonomy_gem__regex=re_pre + material + re_post)
    if llrs:
        geninfo = geninfo.filter(taxonomy_gem__regex=re_pre + llrs + re_post)
    if author:
        geninfo = geninfo.filter(authors__unaccent=author)
    if country:
        geninfo = geninfo.filter(
            geo_applicability__countries__name__icontains=country)
    if region:
        geninfo = geninfo.filter(
            geo_applicability__countries__region=region).distinct()

    # paginator = Paginator(geninfo, 2)

    #try:
    #    page = int(request.GET.get("page", '1'))
    #except ValueError:
    #    page = 1

    #try:
    #    geninfo = paginator.page(page)
    #except (InvalidPage, EmptyPage):
    #    geninfo = paginator.page(paginator.num_pages)
    if request.method == 'POST':  # If the form has been submitted...
        form = FiltersForm(request.POST)  # A form bound to the POST data
    else:
        form = FiltersForm()  # An unbound form
    # form.fields['type_of_assessment'].widget = forms.HiddenInput()
    if type_of_assessment not in [TA.FRAGILITY, TA.DAMAGE_TO_LOSS]:
        form.fields.pop('damage_scale')
    if type_of_assessment in [TA.DAMAGE_TO_LOSS, TA.CAPACITY_CURVE]:
        form.fields.pop('intensity_measure_type')

    form_all = [{'id': id, 'field': field} for id, field in enumerate(form)]

    # we split the form in 2 rows, the first, fixed with 3 fields plus
    # the submit button, the second contains all the remaining fields.
    form1 = form_all[0:3]
    form2 = form_all[3:6]
    form3 = form_all[6:] + [" "] * (3 - len(form_all[6:]))
    return render_to_response("vulnerability/list.html",
                              dict(page_title=page_title,
                                   form1=form1,
                                   form2=form2,
                                   form3=form3,
                                   geninfo=geninfo,
                                   types_of_assessment=types_of_assessment,
                                   type_of_assessment=type_of_assessment,
                                   curve_id=curve_id,
                                   cart_numb=len(cart),
                                   user=request.user,
                                   body_class='bodyclass'),
                              context_instance=RequestContext(request))


def cart(request, action=None, **kwargs):
    """Main listing."""

    user = User.objects.get(username=request.user.username)
    geninfo_user = GeneralInformation.objects.filter(cart=user)

    if action == 'empty':
        for curve in geninfo_user:
            curve.cart.remove(user)
        return redirect('cart')
    elif action == 'export-as-nrml':
        return _func_export_as_nrml(request, -1)

    try:
        curve_id = int(
            request.POST.get("curve_id", request.GET.get("curve_id", -1)))
        if curve_id < 0:
            curve_id = ""
    except ValueError as e:
        print 'Invalid curve id: %s' % e
        curve_id = ""

    if curve_id:
        try:
            geninfo_user.get(pk=curve_id)
        except ObjectDoesNotExist:
            curve_id = ""

    page_title = "Cart of user %s" % user.username

    # A subset of types_of_assessment can be added to the cart.
    types_of_assessment = dict(
        (key, value) for (key, value) in TYPES_OF_ASSESSMENT if key < 3)

    if geninfo_user:
        type_of_assessment = geninfo_user[0].type_of_assessment
    else:
        type_of_assessment = TA.FRAGILITY

    return render_to_response("vulnerability/cart.html",
                              dict(page_title=page_title,
                                   geninfo_user=geninfo_user,
                                   curve_id=curve_id,
                                   types_of_assessment=types_of_assessment,
                                   type_of_assessment=type_of_assessment,
                                   user=request.user,
                                   body_class='bodyclass'),
                              context_instance=RequestContext(request))


class IntensityMeasureCSC(BaseDetailView):
    """
    View to handle the ajax request for the field options.
    """

    def get(self, request, *args, **kwargs):
        parent_value = request.GET.get("parent_value")
        if parent_value:
            parent_value_int = int(parent_value)
        #else:
            #raise ValueError

        if not parent_value:
            choices = (('', '--------'), )
        elif parent_value_int in (IMT.PGA, IMT.SAT):
            choices = ((IMU.G, 'g'),
                       (IMU.CM_S2, 'cm/s^2'),
                       (IMU.M_S2, 'm/s^2'))
        elif parent_value_int in (IMT.PGV, IMT.IA):
            choices = ((IMU.CM_S, 'cm/s'),
                       (IMU.M_S, 'm/s'))
        elif parent_value_int in (IMT.PGD, IMT.SDT):
            choices = ((IMU.CM, 'cm'),
                       (IMU.M, 'm'))
        elif parent_value_int == IMT.RSD:
            choices = ((IMU.S, 's'), )
        elif parent_value_int == IMT.CAV:
            choices = ((IMU.GS, 'g-s'), )
        elif parent_value_int == IMT.MMI:
            choices = ((IMU.ROMAN, 'Roman numbers'), )
        else:
            raise ValueError

        response = HttpResponse(
            json.dumps(choices, cls=DjangoJSONEncoder),
            mimetype='application/javascript'
        )
        add_never_cache_headers(response)
        return response


class EngineeringDemandCSC(BaseDetailView):
    """
    View to handle the ajax request for the field options.
    """

    def get(self, request, *args, **kwargs):
        # field = request.GET.get("field")
        parent_value = request.GET.get("parent_value")
        if parent_value:
            parent_value_int = int(parent_value)
        #else:
            #raise ValueError

        if not parent_value:
            choices = (('', '--------'), )
        elif parent_value_int in (EDP.INTERSTOREY_DRIFT, EDP.GLOBAL_DRIFT):
            choices = ((EDU.PURE, 'Dimensionless'), )
        elif parent_value_int in (EDP.LATERAL_ROOF_DISPLACEMENT,
                                  EDP.SPECTRAL_DISPLACEMENT):
            choices = ((EDU.CM, 'cm'), (EDU.M, 'm'))
        elif parent_value_int == EDP.CHORD_ROTATION:
            choices = ((EDU.RAD, 'rad'), )
        elif parent_value_int == EDP.CURVATURE:
            choices = ((EDU.RAD_KM, 'rad/km'), (EDU.RAD_M, 'rad/m'))
        else:
            raise ValueError

        response = HttpResponse(
            json.dumps(choices, cls=DjangoJSONEncoder),
            mimetype='application/javascript'
        )
        add_never_cache_headers(response)
        return response


class RespVarParCSC(BaseDetailView):
    """
    View to handle the ajax request for the field options.
    """

    def get(self, request, *args, **kwargs):
        # field = request.GET.get("field")
        parent_value = request.GET.get("parent_value")
        if parent_value:
            parent_value_int = int(parent_value)
        #else:
            #raise ValueError

        rvp_desc = dict(RESP_VAR_PAR)
        if not parent_value:
            choices = (('', '--------'), )
        elif parent_value_int in (EDP.INTERSTOREY_DRIFT,
                                  EDP.GLOBAL_DRIFT,
                                  EDP.LATERAL_ROOF_DISPLACEMENT):
            choices = ((RVP.BASE_SHEAR,
                        rvp_desc[str(RVP.BASE_SHEAR)]),
                       (RVP.BASE_SHEAR_COEF,
                        rvp_desc[str(RVP.BASE_SHEAR_COEF)]),
                       )
        elif parent_value_int in (EDP.CHORD_ROTATION,
                                  EDP.CURVATURE):
            choices = ((RVP.BASE_BENDING_MOMENT,
                        rvp_desc[str(RVP.BASE_BENDING_MOMENT)]),
                       )
        elif parent_value_int == EDP.SPECTRAL_DISPLACEMENT:
            choices = ((RVP.SPECTRAL_ACCELERATION,
                        rvp_desc[str(RVP.SPECTRAL_ACCELERATION)]),
                       )
        else:
            raise ValueError

        response = HttpResponse(
            json.dumps(choices, cls=DjangoJSONEncoder),
            mimetype='application/javascript'
        )
        add_never_cache_headers(response)
        return response


class RespVarUnitsCSC(BaseDetailView):
    """
    View to handle the ajax request for the field options.
    """

    def get(self, request, *args, **kwargs):
        # field = request.GET.get("field")
        parent_value = request.GET.get("parent_value")
        if parent_value:
            parent_value_int = int(parent_value)
        #else:
            #raise ValueError

        rvu_desc = dict(RESP_VAR_UNITS)
        if not parent_value:
            choices = (('', '--------'), )
        elif parent_value_int == RVP.BASE_SHEAR:
            choices = ((RVU.KN, rvu_desc[str(RVU.KN)]), )
        elif parent_value_int == RVP.BASE_BENDING_MOMENT:
            choices = ((RVU.KNM, rvu_desc[str(RVU.KNM)]), )
        elif parent_value_int == RVP.SPECTRAL_ACCELERATION:
            choices = ((RVU.G, rvu_desc[str(RVU.G)]),
                       (RVU.CMS2, rvu_desc[str(RVU.CMS2)]),
                       (RVU.MS2, rvu_desc[str(RVU.MS2)]))
        elif parent_value_int == RVP.BASE_SHEAR_COEF:
            choices = ((RVU.NO_DIM, rvu_desc[str(RVU.NO_DIM)]), )
        else:
            raise ValueError

        response = HttpResponse(
            json.dumps(choices, cls=DjangoJSONEncoder),
            mimetype='application/javascript'
        )
        add_never_cache_headers(response)
        return response


def _general_information_serialize(request, gen_info_id):
    try:
        gi = GeneralInformation.objects.select_related().get(pk=gen_info_id)
    except GeneralInformation.DoesNotExist:
        raise Http404
    gi_json_str = serializers.serialize(
        "json",
        [gi],
        #indent=4,
        choices=True,
        relations={
            'owner': {'excludes': ('is_active', 'is_superuser', 'is_staff',
                                   'last_login', 'groups', 'user_permissions',
                                   'password', 'date_joined')
                      },
            'fragility_func': {
                'choices': True,
                'relations': {
                    'analytical_model_info': {
                        'choices': True,
                        'relations': {
                            'analysis_type': {'excludes': ('owner',)},
                            'evaluation_of_im': {'excludes': ('owner',)}, },
                        'excludes': ('owner',),
                    },
                    'empirical_model_info': {
                        'choices': True,
                        'relations': {
                            'evaluation_of_im': {'excludes': ('owner',)}, },
                        'excludes': ('owner',)
                    },
                    'stat_info': {
                        'choices': True,
                        'relations': {'stat_model': {'excludes': ('owner',)},
                                      'stat_model_fitting_method': {
                                          'excludes': ('owner',)},
                                      'model_fitting_method_assumptions': {
                                          'excludes': ('owner',)},
                                      'fit_assessment_goodness': {
                                          'excludes': ('owner',)},
                                      'proc_constr_conf_int': {
                                          'excludes': ('owner',)},
                                      'proc_constr_pred_int': {
                                          'excludes': ('owner',)}, },
                        'excludes': ('owner',),
                    },
                    'predictor_var': {'choices': True, 'excludes': ('owner',)},
                    'func_distr_frag_discr': {
                        'choices': True, 'excludes': ('owner',)},
                    'func_distr_frag_cont': {
                        'choices': True, 'excludes': ('owner',)},
                    'engineering_demand_par': {'excludes': ('owner',)},
                    'qrs_analytical': {
                        'choices': True, 'excludes': ('owner',)},
                    'qrs_empirical': {'choices': True, 'excludes': ('owner',)},
                },
                'excludes': ('owner',)
            },
            'vulnerability_func': {
                'choices': True,
                'relations': {
                    'analytical_model_info': {
                        'choices': True,
                        'relations': {
                            'analysis_type': {'excludes': ('owner',)},
                            'evaluation_of_im': {'excludes': ('owner',)}, },
                        'excludes': ('owner',),
                    },
                    'empirical_model_info': {
                        'choices': True,
                        'relations': {
                            'evaluation_of_im': {'excludes': ('owner',)}, },
                        'excludes': ('owner',)
                    },
                    'stat_info': {
                        'choices': True,
                        'relations': {'stat_model': {'excludes': ('owner',)},
                                      'stat_model_fitting_method': {
                                          'excludes': ('owner',)},
                                      'model_fitting_method_assumptions': {
                                          'excludes': ('owner',)},
                                      'fit_assessment_goodness': {
                                          'excludes': ('owner',)},
                                      'proc_constr_conf_int': {
                                          'excludes': ('owner',)},
                                      'proc_constr_pred_int': {
                                          'excludes': ('owner',)}, },
                        'excludes': ('owner',),
                    },
                    'predictor_var': {'choices': True, 'excludes': ('owner',)},
                    'func_distr_vuln_discr': {
                        'choices': True, 'excludes': ('owner',)},
                    'func_distr_vuln_cont': {
                        'choices': True, 'excludes': ('owner',)},
                    'qrs_analytical': {
                        'choices': True, 'excludes': ('owner',)},
                    'qrs_empirical': {'choices': True, 'excludes': ('owner',)},
                },
                'excludes': ('owner',),
            },
            'damage_to_loss_func': {
                'choices': True,
                'relations': {
                    'analytical_model_info': {
                        'choices': True,
                        'relations': {
                            'analysis_type': {'excludes': ('owner',)},
                            'evaluation_of_im': {'excludes': ('owner',)}, },
                        'excludes': ('owner',)
                    },
                    'empirical_model_info': {
                        'choices': True,
                        'relations': {
                            'evaluation_of_im': {'excludes': ('owner',)}, },
                        'excludes': ('owner',)
                    },
                    'stat_info': {
                        'choices': True,
                        'relations': {'stat_model': {'excludes': ('owner',)},
                                      'stat_model_fitting_method': {
                                          'excludes': ('owner',)},
                                      'model_fitting_method_assumptions': {
                                          'excludes': ('owner',)},
                                      'fit_assessment_goodness': {
                                          'excludes': ('owner',)},
                                      'proc_constr_conf_int': {
                                          'excludes': ('owner',)},
                                      'proc_constr_pred_int': {
                                          'excludes': ('owner',)}, },
                        'excludes': ('owner',),
                    },
                    'func_distr_dtl_discr': {
                        'choices': True, 'excludes': ('owner',)},
                },
                'excludes': ('owner',)
            },
            'capacity_curve_func': {
                'choices': True,
                'relations': {
                    'cc_analytical_model_info': {
                        'choices': True,
                        'relations': {
                            'analysis_type': {'excludes': ('owner',)}, },
                        'excludes': ('owner',)
                    },
                    'empirical_model_info': {
                        'choices': True,
                        'relations': {
                            'evaluation_of_im': {'excludes': ('owner',)}, },
                        'excludes': ('owner',)
                    },
                    'stat_info': {
                        'choices': True,
                        'relations': {'stat_model': {'excludes': ('owner',)},
                                      'stat_model_fitting_method': {
                                          'excludes': ('owner',)},
                                      'model_fitting_method_assumptions': {
                                          'excludes': ('owner',)},
                                      'fit_assessment_goodness': {
                                          'excludes': ('owner',)},
                                      'proc_constr_conf_int': {
                                          'excludes': ('owner',)},
                                      'proc_constr_pred_int': {
                                          'excludes': ('owner',)}, },
                    },
                    'cc_predictor_var': {
                        'choices': True,
                        'excludes': ('owner',)
                    },
                },
                'excludes': ('owner',)
            },
            'taxonomy_type': {'excludes': ('owner',)},
            'geo_applicability': {
                'choices': True,
                'relations': {
                    'countries': {
                        'excludes': ('the_geom', 'owner',),
                    }
                },
                'excludes': ('owner',),
            },
        },
        excludes=('cart', )
    )

    edit_enabled = (
        gi.is_owned_by(request.user)
        or request.user.is_superuser
        or request.user.groups.filter(name='vulnerability-admins').count())
    slug_name = slugify(gi.name)
    gi_json_list = json.loads(gi_json_str)
    gi_json = gi_json_list[0]
    return (gi, edit_enabled, gi.type_of_assessment, gi_json, slug_name)


def show_general_information(request, gen_info_id, action=None):
    gi, edit_enabled, type_of_assessment, gi_json, slug_name = (
        _general_information_serialize(request, gen_info_id))

    curve_in_cart = gi.cart.filter(username=request.user.username)
    cart_curves = GeneralInformation.objects.filter(
        cart__username=request.user.username)
    from_page = request.POST.get("from", "list")
    from_page_info = (
        "back to list of all curves" if from_page == "list" else
        "back to curves collection exportable as single NRML file")
    other_page = ("cart" if from_page == "list" else "list")
    other_page_info = ("go to curves collection exportable as single NRML file"
                       if from_page == "list" else "go to list of all curves")
    if request.method == 'POST':  # If the form has been submitted...
        user = User.objects.get(username=request.user.username)

        failed = False
        if action == 'add-to-cart':
            # check consistency with first curve stored
            while True:
                if curve_in_cart:
                    messages.error(
                        request,
                        'Curve "%s" already in cart.' % force_unicode(gi.name))
                    failed = True
                    break

                first_in_cart = GeneralInformation.objects.filter(cart=user)

                if first_in_cart:
                    first_in_cart = first_in_cart[0]
                    gi_first = GeneralInformation.objects.select_related().get(
                        pk=first_in_cart.id)

                    # check curve type
                    if gi_first.type_of_assessment != gi.type_of_assessment:
                        types_of_assessment = dict(TYPES_OF_ASSESSMENT)
                        messages.error(
                            request,
                            'Curve "type of assessment" is "%s" but '
                            'must be "%s" to be '
                            'added to the current cart.'
                            % (types_of_assessment[gi.type_of_assessment],
                               types_of_assessment[
                                   gi_first.type_of_assessment]))
                        failed = True
                        break

                    # check curve category
                    categories = dict(CATEGORIES)
                    if ((gi_first.category <= CAT.STR_CLASS and gi.category > CAT.STR_CLASS) or
                        (gi_first.category > CAT.STR_CLASS and gi_first.category != gi.category)):
                        messages.error(
                            request,
                            'Curve "category" is "%s" but must be "%s" to be '
                            'added to the current cart.'
                            % (categories[gi.category],
                               (('%s" or "%s' % (categories[CAT.STR_SPEC],
                                                 categories[CAT.STR_CLASS]))
                                if gi_first.category <= CAT.STR_CLASS
                                else categories[gi_first.category])))
                        failed = True
                        break

                    # additional checks if type_of_assessment is TA.FRAGILITY
                    if gi_first.type_of_assessment == TA.FRAGILITY:
                        if gi_first.fragility_func.limit_states_num != gi.fragility_func.limit_states_num:
                            messages.error(
                                request,
                                'Curve "limit states" are %d '
                                'but must be %d to be '
                                'added to the current cart.' %
                                (gi.fragility_func.limit_states_num,
                                 gi_first.fragility_func.limit_states_num))
                            failed = True
                            break

                        if (gi_first.fragility_func.func_distr_type != 
                            gi.fragility_func.func_distr_type):
                            messages.error(
                                request,
                                ('All curves added to the current cart must be '
                                 'a fragility curve and must be %s type.' %
                                dict(FUNC_DISTR_TYPES)[gi_first.fragility_func.func_distr_type].lower()))
                            failed = True
                            break

                        if gi_first.fragility_func.limit_states_desc != gi.fragility_func.limit_states_desc:
                            messages.warning(
                                request,
                                'Curve limit states description "%s" differs '
                                'from first curve in the cart "%s"' %
                                (gi.fragility_func.limit_states_desc,
                                 gi_first.fragility_func.limit_states_desc))
                break

            if not curve_in_cart and not failed:
                gi.cart.add(user)
                # curve_in_cart should be '[ gi ]' to be consistent with the
                # rest of the code but from here we are interested in
                # if is None or not None.
                curve_in_cart = True
                messages.add_message(
                    request, messages.INFO,
                    'Curve ' + force_unicode(gi.name) + ' added to collection'
                    ' of curves to export as a single NRML file.')
            return redirect('view', gen_info_id=gen_info_id)
        elif action == 'remove-from-cart':
            if curve_in_cart:
                gi.cart.remove(user)
                messages.add_message(
                    request,
                    messages.INFO,
                    'Curve ' + force_unicode(gi.name) + ' removed from'
                    ' collection of curves to export as a single NRML file')
                curve_in_cart = None
            else:
                messages.add_message(
                    request,
                    messages.ERROR,
                    'Curve ' + force_unicode(gi.name) + ' not in collection'
                    ' of curves to export as a single NRML file.')
            return redirect('view', gen_info_id=gen_info_id)
        elif action == 'export-as-nrml':
            return _func_export_as_nrml(request, gen_info_id)

    return render_to_response(
        'vulnerability/show_general_information.html',
        dict(general_information=json.dumps(gi_json),
             page_title=gi.name,
             from_page=from_page,
             from_page_info=from_page_info,
             other_page=other_page,
             other_page_info=other_page_info,
             type_of_assessment=type_of_assessment,
             curve_id=gen_info_id,
             edit_enabled=edit_enabled,
             curve_in_cart=curve_in_cart,
             cart_curves=cart_curves,
             slug_name=slug_name,
             user_mailaddr="%s %s <%s>" % (
                    gi.owner.first_name, gi.owner.last_name,
                    gi.owner.email),
             vuln_mailaddr="GEM Vulnerability Team <vulnerability@globalquakemodel.org>"),
        context_instance=RequestContext(request))


def general_information_json_get_all(request):
    gi_json_list = []
    gen_info_ids = [gi.id for gi in GeneralInformation.objects.all()]
    for gen_info_id in gen_info_ids:
        gi, edit_enabled, type_of_assessment, gi_json, slug_name = (
            _general_information_serialize(request, gen_info_id))
        if edit_enabled:
            gi_json_list.append(gi_json)
    return HttpResponse(json.dumps(gi_json_list),
                        content_type="application/json")


def general_information_json_get(request, gen_info_id):
    gi, edit_enabled, type_of_assessment, gi_json, slug_name = (
        _general_information_serialize(request, gen_info_id))

    return HttpResponse(json.dumps(gi_json), content_type="application/json")


class FuncDistrShapeException(Exception):
    pass


class IntensityMeasureTypeException(Exception):
    pass


def _normalize_measurement(iml_orig_type, iml_orig_unit):
    iml_k = 1.0
    if iml_orig_type in (IMT.PGA, IMT.SAT):
        if iml_orig_unit == IMU.CM_S2:
            iml_k = (1.0 / 980.665)
        elif iml_orig_unit == IMU.M_S2:
            iml_k = (1.0 / 9.80665)
        elif iml_orig_unit != IMU.G:
            raise ValueError
        imlUnit = "g"

    elif iml_orig_type == IMT.PGV:
        if iml_orig_unit == IMU.M_S:
            iml_k = 100.0
        elif iml_orig_unit != IMU.CM_S:
            raise ValueError
        imlUnit = "cm/s"

    elif iml_orig_type == IMT.PGD:
        if iml_orig_unit == IMU.M:
            iml_k = 100.0
        elif iml_orig_unit != IMU.CM:
            raise ValueError
        imlUnit = "cm"

    elif iml_orig_type == IMT.IA:
        if iml_orig_unit == IMU.CM_S:
            iml_k = 0.01
        elif iml_orig_unit != IMU.M_S:
            raise ValueError
        imlUnit = "m/s"

    elif iml_orig_type == IMT.CAV:
        if iml_orig_unit != IMU.GS:
            raise ValueError
        imlUnit = "g-s"

    elif iml_orig_type == IMT.RSD:
        if iml_orig_unit != IMU.S:
            raise ValueError
        imlUnit = "s"

    elif iml_orig_type == IMT.MMI:
        if iml_orig_unit != IMU.ROMAN:
            raise ValueError
        imlUnit = "Roman numbers"
    else:
        raise ValueError

    return (iml_k, imlUnit)


def _msd2sigmu(mean, stddev):
    """
    from mean and stddev to sigma and mu
    """
    variance = stddev ** 2.0
    meansqua = mean ** 2.0
    sigma = numpy.sqrt(numpy.log((variance / meansqua) + 1.0))
    mu = meansqua / numpy.sqrt(variance + meansqua)
    return (sigma, mu)


def _stream_vuln_discr_data(curr, func_obj, is_first):
    if is_first:
        vumo = etree.SubElement(curr, "vulnerabilityModel")
    else:
        vumo = curr
    resp_var = func_obj.vulnerability_func.resp_var

    if resp_var in (RV.DF, RV.DEF):
        asset_category = 'buildings'
        loss_category = 'economic_loss'
    elif resp_var in (RV.FRPO, RV.NFIRPO, RV.FRPEP):
        asset_category = 'occupants'
        loss_category = 'fatalities'
    else:
        raise ValueError

    # NOTE: we are using a fix general name to describe the group (just one
    # currently) of curves
    dvs = etree.SubElement(
        vumo,
        "discreteVulnerabilitySet",
        vulnerabilitySetID="Vulnerability from GVD: set of functions",
        assetCategory=asset_category,
        lossCategory=loss_category)

    imt_idx = int(
        func_obj.vulnerability_func.predictor_var.intensity_measure_type)
    imts = dict((k, v) for k, v in INTENSITY_MEASURE_TYPES)
    imt = imts[str(imt_idx)]
    if imt_idx == IMT.SDT:
        raise IntensityMeasureTypeException(imt)
    if imt_idx == IMT.PGA:
        noDamageLimit = '0.05'
    elif imt_idx == IMT.PGV:
        noDamageLimit = '1'
    elif imt_idx in (IMT.PGD, IMT.SAT, IMT.IA, IMT.CAV):
        noDamageLimit = '0.01'
        if imt_idx == IMT.SAT:
            period = func_obj.vulnerability_func.predictor_var.period
            imt = imt.replace('T', str(period))
    elif imt_idx == IMT.RSD:
        noDamageLimit = '3'
    elif imt_idx == IMT.MMI:
        noDamageLimit = '4'  # NOTE: Never used
    else:
        raise IntensityMeasureTypeException(imt)
    iml_orig_type = int(
        func_obj.vulnerability_func.predictor_var.intensity_measure_type)
    iml_orig_unit = int(
        func_obj.vulnerability_func.predictor_var.intensity_measure_unit)

    if iml_orig_type == IMT.SDT:
        raise ValueError

    # NOTE: Those two fields are going to be set as mandatory
    maxIML = func_obj.vulnerability_func.predictor_var.maximum_im
    minIML = func_obj.vulnerability_func.predictor_var.minimum_im

    (iml_k, imlUnit) = _normalize_measurement(iml_orig_type, iml_orig_unit)

    # discrete and continuous omogenisation
    if func_obj.vulnerability_func.func_distr_type == FDT.CONTINUOUS:
        if func_obj.vulnerability_func.func_distr_vuln_cont.discretization_data_pts_num:
            discr_pts_n = func_obj.vulnerability_func.func_distr_vuln_cont.discretization_data_pts_num
        else:
            discr_pts_n = 50

        func_distr_shape = \
            func_obj.vulnerability_func.func_distr_vuln_cont.func_distr_shape

        if func_distr_shape in [FDS.LOGNORMAL, FDS.BETA]:
            x = numpy.linspace(minIML, maxIML, num=discr_pts_n)  # values for
                                                                 # x-axis

            (lr_sigma, lr_mu) = _msd2sigmu(
                func_obj.vulnerability_func.func_distr_vuln_cont.mean,
                func_obj.vulnerability_func.func_distr_vuln_cont.std_dev)

            if (func_obj.vulnerability_func.func_distr_vuln_cont.mean_var_coef and
                func_obj.vulnerability_func.func_distr_vuln_cont.sd_var_coef):
                (cov_sigma, cov_mu) = _msd2sigmu(
                    func_obj.vulnerability_func.func_distr_vuln_cont.mean_var_coef,
                    func_obj.vulnerability_func.func_distr_vuln_cont.sd_var_coef)
            else:
                cov_mu = None
                cov_sigma = None

            if func_distr_shape == FDS.LOGNORMAL:
                iml_vals = ' '.join("%.3f" % (x_cur * iml_k) for x_cur in x)
                loss_ratio = ' '.join("%.3f" % y for y in stats.lognorm.cdf(
                    x, lr_sigma, scale=lr_mu))
                if cov_sigma is not None:
                    cov = ' '.join("%.3f" % y for y in stats.lognorm.cdf(
                        x, cov_sigma, scale=cov_mu))
                else:
                    cov = None
            elif func_distr_shape == FDS.BETA:
                raise ValueError(
                    'Beta distribution shape currently not supported.')
        else:
            raise ValueError('unknown distribution shape')
    else:  # if func_obj.vulnerability_func.func_distr_type == FDT.CONTINUOUS:
        func_distr_shape = \
            func_obj.vulnerability_func.func_distr_vuln_discr.func_distr_shape
        iml_vals = func_obj.vulnerability_func.func_distr_vuln_discr.predictor_var_im_val.replace(';', ' ')
        discr_pts_n = \
            func_obj.vulnerability_func.func_distr_vuln_discr.data_pts_num

        # NOTE:
        #  currently we have 2 names described by the same definition:
        #  'loss_ratio' and 'resp_var_mean_val' in the near future we
        #  might sanitize this ambiguity.
        #  The same for 'cov' (coefficients of variation) and
        #  'resp_var_val_coeff'.
        loss_ratio = func_obj.vulnerability_func.func_distr_vuln_discr.resp_var_mean_val.replace(';', ' ')

        cov = None
        if func_obj.vulnerability_func.func_distr_vuln_discr.resp_var_val_coeff:
            cov = func_obj.vulnerability_func.func_distr_vuln_discr.resp_var_val_coeff.replace(';', ' ')

    iml = etree.SubElement(  # NOTE: Never used
        dvs, "IML",
        IMT=imt,
        imlUnit=imlUnit,
        maxIML=str(maxIML * iml_k),
        minIML=str(minIML * iml_k)
        ).text = iml_vals

    dv = etree.SubElement(
        dvs,
        "discreteVulnerability",
        vulnerabilityFunctionID=func_obj.name,
        probabilisticDistribution=(
            dict(FUNC_DISTR_SHAPES_NRML_ALL)[func_distr_shape]))
    lr = etree.SubElement(dv, "lossRatio")
    lr.text = loss_ratio
    if cov:
        cv = etree.SubElement(dv, "coefficientsVariation")
        cv.text = cov

    return vumo


def _limit_states_slugify(limit_states):
    """
    replace limit states lowercased names with themselves where
    all [^a-z0-9] chars are substituted with '_' and contiguous '_' are
    collapsed into one
    """

    return re.sub(r"_+", "_", re.sub(r"[^a-z0-9;]", "_", limit_states.lower())
                  ).replace(";", " ")


def _stream_frag_discr_data(curr, first_obj, func_obj, is_first):
    if is_first:
        frmo = etree.SubElement(curr, "fragilityModel", format="discrete")

        desc = etree.SubElement(frmo, "description")
        # NOTE: We are currently using a prefix plus the function name, but in
        # the future we are going to have more than one function in the same
        # NRML file and this tag will contain a general description of the set
        # of curves
        desc.text = 'Fragility from GVD: %s' % func_obj.name

        limit_states = _limit_states_slugify(
            func_obj.fragility_func.limit_states_desc)

        func_obj._mangled_limit_states = limit_states

        lims = etree.SubElement(frmo, "limitStates")
        lims.text = limit_states
    else:
        limit_states = first_obj._mangled_limit_states
        frmo = curr

    imt_idx = int(func_obj.fragility_func.predictor_var.intensity_measure_type)
    imts = dict((k, v) for k, v in INTENSITY_MEASURE_TYPES)
    imt = imts[str(imt_idx)]
    if imt_idx == IMT.SDT:
        raise IntensityMeasureTypeException(imt)
    if imt_idx == IMT.PGA:
        noDamageLimit = '0.05'
    elif imt_idx == IMT.PGV:
        noDamageLimit = '1'
    elif imt_idx in (IMT.PGD, IMT.SAT, IMT.IA, IMT.CAV):
        noDamageLimit = '0.01'
        if imt_idx == IMT.SAT:
            period = func_obj.fragility_func.predictor_var.period
            imt = imt.replace('T', str(period))
    elif imt_idx == IMT.RSD:
        noDamageLimit = '3'
    elif imt_idx == IMT.MMI:
        noDamageLimit = '4'
    else:
        raise IntensityMeasureTypeException(imt)
    ffs = etree.SubElement(
        frmo, "ffs", noDamageLimit=noDamageLimit)

    if func_obj.taxonomy_gem:
        tax = etree.SubElement(ffs, "taxonomy")
        tax.text = func_obj.taxonomy_gem
    else:
        ffs.append(etree.Comment('an empty taxonomy means "all taxonomies"'))
        tax = etree.SubElement(ffs, "taxonomy")

    iml_orig_type = int(
        func_obj.fragility_func.predictor_var.intensity_measure_type)
    iml_orig_unit = int(
        func_obj.fragility_func.predictor_var.intensity_measure_unit)

    if iml_orig_type == IMT.SDT:
        raise ValueError

    # NOTE: Those two fields are going to be set as mandatory
    maxIML = func_obj.fragility_func.predictor_var.maximum_im
    minIML = func_obj.fragility_func.predictor_var.minimum_im

    (iml_k, imlUnit) = _normalize_measurement(iml_orig_type, iml_orig_unit)

    iml = etree.SubElement(  # NOTE: Never used
        ffs, "IML",
        IMT=imt,
        imlUnit=imlUnit,
        maxIML=str(maxIML * iml_k),
        minIML=str(minIML * iml_k)
        ).text = func_obj.fragility_func.func_distr_frag_discr.predictor_var_im_val.replace(';', ' ')

    for i, ls in enumerate(limit_states.split(' ')):
        ffd = etree.SubElement(ffs, "ffd", ls=ls)
        poEs = etree.SubElement(ffd, "poEs")
        lspe = func_obj.fragility_func.func_distr_frag_discr.limit_state_prob_exceed
        lspe_i = lspe.split('\n')[i]
        lspe_i_spaces = lspe_i.replace(';', ' ')
        poEs.text = lspe_i_spaces

    return frmo


def _stream_frag_cont_data(curr, first_obj, func_obj, is_first):
    if is_first:
        frmo = etree.SubElement(curr, "fragilityModel", format="continuous")
        desc = etree.SubElement(frmo, "description")
        # NOTE: We are currently using a prefix plus the function name, but in
        # the future we are going to have more than one function in the same
        # NRML file and this tag will contain a general description of the set
        # of curves
        desc.text = 'Fragility from GVD: %s' % func_obj.name

        limit_states = _limit_states_slugify(
            func_obj.fragility_func.limit_states_desc)

        func_obj._mangled_limit_states = limit_states

        lims = etree.SubElement(frmo, "limitStates")
        lims.text = limit_states
    else:
        limit_states = first_obj._mangled_limit_states
        frmo = curr

    func_distr_shape_id = \
        func_obj.fragility_func.func_distr_frag_cont.func_distr_shape
    func_distr_shape = dict(FUNC_DISTR_SHAPES_ALL)[func_distr_shape_id].lower()
    if func_distr_shape != "lognormal":
        raise FuncDistrShapeException(func_distr_shape)

    imt_idx = int(func_obj.fragility_func.predictor_var.intensity_measure_type)
    imts = dict((k, v) for k, v in INTENSITY_MEASURE_TYPES)
    imt = imts[str(imt_idx)]
    if imt_idx == IMT.SDT:
        raise IntensityMeasureTypeException(imt)
    if imt_idx == IMT.PGA:
        noDamageLimit = '0.05'
    elif imt_idx == IMT.PGV:
        noDamageLimit = '1'
    elif imt_idx in (IMT.PGD, IMT.SAT, IMT.IA, IMT.CAV):
        noDamageLimit = '0.01'
        if imt_idx == IMT.SAT:
            period = func_obj.fragility_func.predictor_var.period
            imt = imt.replace('T', str(period))
    elif imt_idx == IMT.RSD:
        noDamageLimit = '3'
    elif imt_idx == IMT.MMI:
        noDamageLimit = '4'
    else:
        raise IntensityMeasureTypeException(imt)

    ffs = etree.SubElement(
        frmo, "ffs", noDamageLimit=noDamageLimit, type=func_distr_shape)

    if func_obj.taxonomy_gem:
        tax = etree.SubElement(ffs, "taxonomy")
        tax.text = func_obj.taxonomy_gem
    else:
        ffs.append(etree.Comment('an empty taxonomy means "all taxonomies"'))
        tax = etree.SubElement(ffs, "taxonomy")

    iml_orig_type = int(
        func_obj.fragility_func.predictor_var.intensity_measure_type)
    iml_orig_unit = int(
        func_obj.fragility_func.predictor_var.intensity_measure_unit)

    if iml_orig_type == IMT.SDT:
        raise ValueError

    maxIML = func_obj.fragility_func.predictor_var.maximum_im
    minIML = func_obj.fragility_func.predictor_var.minimum_im

    (iml_k, imlUnit) = _normalize_measurement(iml_orig_type, iml_orig_unit)

    iml = etree.SubElement(  # NOTE: Never used
        ffs, "IML",
        IMT=imt,
        imlUnit=imlUnit,
        maxIML=str(maxIML * iml_k),
        minIML=str(minIML * iml_k))
    mean_arr = func_obj.fragility_func.func_distr_frag_cont.mean.split(';')
    stddev_arr = func_obj.fragility_func.func_distr_frag_cont.std_dev.split(
        ';')
    for i, ls in enumerate(limit_states.split(' ')):
        ffc = etree.SubElement(ffs, "ffc", ls=ls)
        params = etree.SubElement(ffc, "params")
        params.attrib['mean'] = mean_arr[i]
        params.attrib['stddev'] = stddev_arr[i]

    return frmo


def _func_export_as_nrml(request, gen_info_id):
    if gen_info_id == -1:
        func_objs = GeneralInformation.objects.filter(
            cart__username=request.user.username)
    else:
        try:
            func_objs = [GeneralInformation.objects.get(pk=gen_info_id)]
        except:
            return HttpResponseNotFound(
                '<h1>Item with id %d not found</h1>' % gen_info_id)

    if gen_info_id == -1 and not func_objs:
        return HttpResponseNotFound('<h1>The cart is empty.</h1>')

    content_disp = ('attachment; filename="%s%s.xml"' %
                    (slugify(func_objs[0].name),
                     ("_and-others" if len(func_objs) > 1 else "")))

    mimetype = 'text/plain'

    toa_idx = func_objs[0].type_of_assessment
    toas = dict((k, v) for k, v in TYPES_OF_ASSESSMENT)
    toa = toas[toa_idx]
    if toa_idx not in (TA.FRAGILITY, TA.VULNERABILITY):
        return HttpResponseNotFound(
            '<h1>Export unavailable for type of assessment "%s"</h1>' % toa)

    root = etree.Element("nrml",
                         nsmap=SERIALIZE_NS_MAP)
    curr = root
    is_first = True
    for func_obj in func_objs:
        if is_first:
            first_obj = func_obj
        if toa_idx == TA.FRAGILITY:
            fdt_idx = func_obj.fragility_func.func_distr_type

            try:
                if fdt_idx == FDT.CONTINUOUS:
                    curr = _stream_frag_cont_data(curr, first_obj, func_obj, is_first)
                else:
                    curr = _stream_frag_discr_data(curr, first_obj, func_obj, is_first)
            except FuncDistrShapeException as e:
                return HttpResponseNotFound(
                    '<h1>Function distribution '
                    'shape "%s" not supported.</h1>' % e)
            except IntensityMeasureTypeException as e:
                return HttpResponseNotFound(
                    '<h1>Intensity measure type "%s" not supported.</h1>' % e)

        else:  # VULNERABILITY
            curr = _stream_vuln_discr_data(curr, func_obj, is_first)
        is_first = False

    response_data = etree.tostring(
        root, pretty_print=True, xml_declaration=True, encoding="UTF-8")

    response = HttpResponse(response_data, mimetype=mimetype)
    response['Content-Disposition'] = content_disp

    return response
