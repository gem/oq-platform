# Copyright (c) 2012-2013, GEM Foundation.
#
# This program is free software: you can redistribute it and/or modify
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#import re
from datetime import datetime
from django.contrib.gis.db import models
# from django.db import models
from django.core.exceptions import ValidationError
from commons import (SemicolonSeparatedFloatFormField,
                     #SemicolonSeparatedFloatRomanFormField,
                     SemicolonSeparatedStringFormField,
                     BidimensionalFloatFormField, )
#from django.core import validators
#from django.core.validators import RegexValidator
from django.core.validators import MinValueValidator, MaxValueValidator


class SemicolonSeparatedFloatField(models.CharField):
    description = "Semicolon-separated floats"

    __metaclass__ = models.SubfieldBase

    def formfield(self, form_class=SemicolonSeparatedFloatFormField, **kwargs):
        defaults = {
            "label": self.verbose_name,
            # NOTE: we decided to check with respect to self.null instead of
            # using self.blank, because it seems to be more logically correct
            "required": not self.null,
            "help_text": "Enter semicolon-separated floats (e.g.  4.5;3;2.2)"}
        defaults.update(kwargs)
        return form_class(**defaults)


#class SemicolonSeparatedFloatRomanField(models.CharField):
    #description = "Semicolon-separated floats or roman numerals"

    #__metaclass__ = models.SubfieldBase

    #def formfield(self,
                  #form_class=SemicolonSeparatedFloatRomanFormField,
                  #**kwargs):
        #defaults = {
            #"help_text": ("Enter semicolon-separated floats or roman numerals"
                          #" (e.g. 4.5;3;2.2 or IV;II;VII)")
        #}
        #defaults.update(kwargs)
        #return form_class(**defaults)


class SemicolonSeparatedStringField(models.CharField):
    description = "Semicolon-separated strings"

    __metaclass__ = models.SubfieldBase

    def formfield(self,
                  form_class=SemicolonSeparatedStringFormField, **kwargs):
        defaults = {
            "label": self.verbose_name,
            # NOTE: we decided to check with respect to self.null instead of
            # using self.blank, because it seems to be more logically correct
            "required": not self.null,
            "help_text": ("Enter semicolon-separated strings"
                          "(e.g. first;second;third)")
        }
        defaults.update(kwargs)
        return form_class(**defaults)


class BidimensionalFloatField(models.TextField):
    description = "Matrix containing rows of semicolon-separated floats"

    __metaclass__ = models.SubfieldBase

    def formfield(self, form_class=BidimensionalFloatFormField, **kwargs):
        defaults = {
            "label": self.verbose_name,
            # NOTE: we decided to check with respect to self.null instead of
            # using self.blank, because it seems to be more logically correct
            "required": not self.null,
            "help_text": ("Enter rows of semicolon-separated floats "
                          "(e.g. 4.5;3;2.2 <Enter> 3.1;1;4 <Enter> "
                          "6.2;5.3;1.1)")
        }
        defaults.update(kwargs)
        return form_class(**defaults)


CHMAX = 200
TFMAX = 1023

QRS_VALUES = (
    (1, 'Superior'),
    (2, 'Average'),
    (3, 'Marginal'),
    (4, 'NA'),
)


# E2
class QRSEmpirical(models.Model):
    class Meta:
        verbose_name = "Q.R.S. for empirical function/curve"
        verbose_name_plural = ("Q.R.S. for empirical "
                               "functions/curves")
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='qrs_empirical',
        verbose_name="Fragility function")
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='qrs_empirical',
        verbose_name="Vulnerability function")
    # Group: Data quality
    data_quantity = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    constrained_categories = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    excitation_observation = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    damage_loss_observation = models.IntegerField(
        'Damage/loss observation', choices=QRS_VALUES, null=True, blank=True)
    # end group
    # Group: Rationality
    hindcasting = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    cross_validation = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    first_principles = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    uncertainties_treatment = models.IntegerField(
        'Treatment of uncertainties', choices=QRS_VALUES,
        null=True, blank=True)
    # end group
    documentation_quality = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    documentation_type = models.IntegerField(
        'Type of documentation', choices=QRS_VALUES, null=True, blank=True)
    representativeness = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)


# E1
class QRSAnalytical(models.Model):
    class Meta:
        verbose_name = "Q.R.S. for analytical function/curve"
        verbose_name_plural = ("Q.R.S for analytical "
                               "functions/curves")
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='qrs_analytical',
        verbose_name="Fragility function")
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='qrs_analytical',
        verbose_name="Vulnerability function")
    # Group: Data quality
    structural_details = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    model_completeness = models.IntegerField(
        'Completeness of model', choices=QRS_VALUES, null=True, blank=True)
    seismic_demand = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    # end group
    # Group: Rationality
    analysis_type = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    limit_states_def = models.IntegerField(
        'Definition of Limit States', choices=QRS_VALUES,
        null=True, blank=True)
    sampling_method = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    cross_validation = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    uncertainties_treatment = models.IntegerField(
        'Treatment of uncertainties', choices=QRS_VALUES,
        null=True, blank=True)
    # end group
    # Group: Documentation quality
    documentation_quality = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    documentation_type = models.IntegerField(
        'Type of documentation', choices=QRS_VALUES, null=True, blank=True)
    # end group
    # Group: Representativeness
    typology_repr = models.IntegerField(
        'Representation of typology', choices=QRS_VALUES,
        null=True, blank=True)
    site_specific = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    hazard_model = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    # end group


# D3-e
class StatModel(models.Model):
    # Initial values
    #STATISTICAL_MODELS = (
        #(1, 'Generalised Linear Models'),
        #(2, 'Generalised Additive Models'),
        #(3, 'Kernel smoothing'),
        #(4, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D3-d
class StatModelFittingMethod(models.Model):
    # Initial values
    #STAT_MODEL_FITTING_METHODS = (
        #(1, 'Least squares'),
        #(2, 'Maximum likelyhood'),
        #(3, 'Robust maximum likelyhood'),
        #(4, 'Bayesian'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D3-c
class ModelFittingMethodAssumption(models.Model):
    # Initial values
    #MODEL_FITTING_METHOD_ASSUMPTIONS = (
        #(1, 'Independence of observations'),
        #(2, 'Measurement error in IM'),
        #(3, 'Measurement error in response'),
        #(4, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D3-b
class FitAssessmentGoodness(models.Model):
    # Initial values
    #FIT_ASSESSMENT_GOODNESS_OPTIONS = (
        #(1, 'Acceptable mean function'),
        #(2, 'Acceptable variance function'),
        #(3, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D3-a
class ProcConstrInt(models.Model):
    # Initial values
    #PROC_CONSTR_INT_CHOICES = (
        #(1, 'Asymptotic'),
        #(2, 'Bootstrap'),
        #(3, 'Bayesian'),
        #(4, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D3
class StatisticalInformation(models.Model):
    class Meta:
        verbose_name_plural = "Statistical information"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True, blank=True,
        related_name='stat_info',
        verbose_name='Fragility function')
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True, blank=True,
        related_name='stat_info',
        verbose_name='Vulnerability function')
    stat_model = models.ForeignKey(
        'StatModel', null=True, blank=True,
        verbose_name='Statistical model')
    stat_model_fitting_method = models.ForeignKey(
        'StatModelFittingMethod', null=True, blank=True,
        verbose_name='Statistical model fitting method')
    model_fitting_method_assumptions = models.ForeignKey(
        'ModelFittingMethodAssumption', null=True, blank=True)
    fit_assessment_goodness = models.ForeignKey(
        'FitAssessmentGoodness', null=True, blank=True,
        verbose_name='Goodness of fit assessment (GLM/GAM)')
    proc_constr_conf_int = models.ForeignKey(
        'ProcConstrInt', null=True, blank=True,
        verbose_name='Proc. for constructing conf. intervals',
        related_name='stat_info_conf')
    proc_constr_pred_int = models.ForeignKey(
        'ProcConstrInt', null=True, blank=True,
        verbose_name='Proc. for constructing pred. intervals',
        related_name='stat_info_pref')


# D2
class EmpiricalModelInfo(models.Model):
    class Meta:
        verbose_name = "Empirical modelling information"
        verbose_name_plural = "Empirical modelling information"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='empirical_model_info',
        verbose_name="Fragility function")
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='empirical_model_info',
        verbose_name="Vulnerability function")
    structural_unit = models.IntegerField(null=True, blank=True, choices=(
        (1, 'Dwelling'), (2, 'Building')))
    building_x_class_num = models.IntegerField(
        'Number of buildings per class', null=True, blank=True)
    empirical_data_src = models.CharField(
        'Source of empirical data', max_length=CHMAX, null=True, blank=True)
    BA_BUILDING_BY_BUILDING = 1
    BA_GROUPED = 2
    building_aggr = models.IntegerField(
        'Building aggregation', null=True, blank=True,
        choices=((BA_BUILDING_BY_BUILDING, 'Building-by-building'),
                 (BA_GROUPED, 'Grouped')))
    building_aggr_min_num = models.IntegerField(
        'Minimum number of grouped buildings', null=True, blank=True)
    AGGR_UNIT_DEFS = (
        (1, 'GADM admin 2 region'),
        (2, 'GADM admin 3 region'),
        (3, 'Other admin region'),
        (4, 'Bins of IM'),
    )
    aggr_unit_def = models.IntegerField(
        'Definitions of aggregated units',
        choices=AGGR_UNIT_DEFS, null=True, blank=True)

    def clean(self):
        if self.building_aggr == self.BA_BUILDING_BY_BUILDING:
            self.building_aggr_min_num = None
        elif (self.building_aggr == self.BA_GROUPED
              and self.building_aggr_min_num is None):
            raise ValidationError(
                'You must specify the min number of grouped buildings')
        return True


# D1-a
class AnalysisType(models.Model):
    # Initial values
    #ANALYSIS_TYPES = (
        #(1, 'Nonlinear dynamic analysis (NLD)'),
        #(2, 'Nonlinear static analysis (NLS) with dispersion'),
        #(3, 'NLS without dispersion'),
        #(4, 'Collapse mechanism-based methods'),
        #(5, 'Simplified Displacement-based methods'),
        #(6, 'Other simplified methods'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D1
class AnalyticalModelInfo(models.Model):
    class Meta:
        verbose_name = "Analytical modelling information"
        verbose_name_plural = "Analytical modelling information"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='Fragility function')
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='Vulnerability function')
    capacity_curve_func = models.OneToOneField(
        'CapacityCurveFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='Capacity curve function')
    analysis_type = models.ForeignKey('AnalysisType', null=True, blank=True)
    MODEL_TYPES = (
        (1, '3D'),
        (2, '2D element-by-element'),
        (3, '2D story-by-story'),
        (4, '1D'),
    )
    model_type = models.IntegerField(
        choices=MODEL_TYPES, null=True, blank=True)
    METHODS_UNCERT_PROPAG = (
        (1, 'Random Monte-Carlo or Latin Hypercube sampling'),
        (2, 'Set of index buildings'),
        (3, 'Single index building'),
    )
    method_uncert_propag = models.IntegerField(
        'Method of uncertainty propagation',
        choices=METHODS_UNCERT_PROPAG, null=True, blank=True)
    models_num = models.IntegerField(
        'Number of distinct structural models analysed',
        null=True, blank=True)
    evaluation_of_im = models.ForeignKey(
        'EvaluationOfIM', null=True, blank=True,
        verbose_name='Evaluation of IM')

REGIONS = (
    ('', '--------'),
    (1, 'Worldwide'),
    (2, 'Africa'),
    (3, 'North America'),
    (4, 'Central America & Caribbean'),
    (5, 'South America'),
    (6, 'Asia'),
    (7, 'Europe'),
    (8, 'Oceania'),
    (9, 'Antarctica'),
)


class Country(models.Model):
    name = models.CharField(max_length=CHMAX)
    region = models.IntegerField(choices=REGIONS)
    iso3 = models.CharField(max_length=3)
    the_geom = models.GeometryField(srid=4326, dim=2, null=True, blank=True)
    is_visible = models.BooleanField(default=True)

    def __unicode__(self):
        return '%s (%s)' % (self.name, self.iso3)


# B
class GeoApplicability(models.Model):
    class Meta:
        verbose_name = "Geographical applicability"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='geo_applicability',
        verbose_name='General information')
    countries = models.ManyToManyField(Country)
    # administrative_region =
    area = models.CharField(max_length=CHMAX, blank=True, null=True)
    # Unique location
    lat = models.FloatField(blank=True, null=True)
    lon = models.FloatField(blank=True, null=True)
    address = models.TextField(blank=True, null=True)


class MOE(object):
    ANALYTICAL = 1
    EMPIRICAL = 2
    EXPERT_OPINION = 3


METHODS_OF_ESTIMATION = (
    (MOE.ANALYTICAL, 'Analytical'),
    (MOE.EMPIRICAL, 'Empirical'),
    (MOE.EXPERT_OPINION, 'Expert Opinion'),
)

CC_METHODS_OF_ESTIMATION = (
    (MOE.ANALYTICAL, 'Analytical'),
    (MOE.EMPIRICAL, 'Empirical'),
)


class FDT(object):
    DISCRETE = 1
    CONTINUOUS = 2


FUNC_DISTR_TYPES = (
    (FDT.DISCRETE, 'Discrete'),
    (FDT.CONTINUOUS, 'Continuous'),
)


DAMAGE_SCALES = (
    (1, 'MSK-76'),
    (2, 'EMS-98'),
    (3, 'EMS-92'),
    (4, 'HAZUS'),
    (5, 'ATC-13'),
    (6, 'Custom'),
)


RESP_VARS = (
    (1, 'Damage factor'),
    (2, 'Fatality rate per occupant'),
    (3, 'Nonfatal injury rate per occupant'),
    (4, 'Fatality rate per exposed population'),
    (5, 'Direct economic factor'),
)


class RVP(object):
    BASE_SHEAR = 1
    BASE_BENDING_MOMENT = 2
    SPECTRAL_ACCELERATION = 3

RESP_VAR_PAR = (
    (RVP.BASE_SHEAR, 'Base shear'),
    (RVP.BASE_BENDING_MOMENT, 'Base bending moment'),
    (RVP.SPECTRAL_ACCELERATION, 'Spectral acceleration'),
)


class RVU(object):
    KN = 1
    KNM = 2
    G = 3
    CMS2 = 4
    MS2 = 5


class TA(object):
    FRAGILITY = 1
    VULNERABILITY = 2
    DAMAGE_TO_LOSS = 3
    CAPACITY_CURVE = 4

TYPES_OF_ASSESSMENT = (
    (TA.FRAGILITY, 'Fragility'),
    (TA.VULNERABILITY, 'Vulnerability'),
    (TA.DAMAGE_TO_LOSS, 'Damage-to-loss'),
    (TA.CAPACITY_CURVE, 'Capacity curve'),
)


class IMT(object):
    PGA = 1
    PGV = 2
    PGD = 3
    SAT = 4
    SDT = 5
    IA = 6
    CAV = 7
    RSD = 8
    MMI = 9

INTENSITY_MEASURE_TYPES = (
    ('', '--------'),
    (str(IMT.PGA), 'PGA'),
    (str(IMT.PGV), 'PGV'),
    (str(IMT.PGD), 'PGD'),
    (str(IMT.SAT), 'Sa(T)'),
    (str(IMT.SDT), 'Sd(T)'),
    (str(IMT.IA), 'IA'),
    (str(IMT.CAV), 'CAV'),
    (str(IMT.RSD), 'RSD'),
    (str(IMT.MMI), 'MMI'),
)


class IMU(object):
    G = 1
    CM_S2 = 2
    M_S2 = 3
    CM_S = 4
    M_S = 5
    CM = 6
    M = 7
    S = 8
    GS = 9
    ROMAN = 10


INTENSITY_MEASURE_UNITS = (
    (str(IMU.G), 'g'),
    (str(IMU.CM_S2), 'cm/s^2'),
    (str(IMU.M_S2), 'm/s^2'),
    (str(IMU.CM_S), 'cm/s'),
    (str(IMU.M_S), 'm/s'),
    (str(IMU.CM), 'cm'),
    (str(IMU.M), 'm'),
    (str(IMU.S), 's'),
    (str(IMU.GS), 'g-s'),
    (str(IMU.ROMAN), 'Roman numbers'),
)


class EDP(object):
    INTERSTOREY_DRIFT = 1
    GLOBAL_DRIFT = 2
    LATERAL_ROOF_DISPLACEMENT = 3
    CHORD_ROTATION = 4
    CURVATURE = 5
    SPECTRAL_DISPLACEMENT = 6

ENGINEERING_DEMAND_PARAMETERS = (
    ('', '--------'),
    (EDP.INTERSTOREY_DRIFT, 'Interstorey drift'),
    (EDP.GLOBAL_DRIFT, 'Global drift'),
    (EDP.LATERAL_ROOF_DISPLACEMENT, 'Lateral roof displacement'),
    (EDP.CHORD_ROTATION, 'Chord rotation'),
    (EDP.CURVATURE, 'Curvature'),
    (EDP.SPECTRAL_DISPLACEMENT, 'Spectral displacement'),
)


class EDU(object):
    PURE = 1
    CM = 2
    M = 3
    RAD = 4
    RAD_KM = 5
    RAD_M = 6


# A1
class TaxonomyType(models.Model):
    # Initial values: GEM, PAGER, ATC58
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# Ax-a
class FuncDistrShape(models.Model):
    class Meta:
        verbose_name = "Function distribution shape"
    # Initial values: Lognormal, Beta, Gamma
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# A4-a
class CC_PredictorVar(models.Model):
    class Meta:
        verbose_name = "Capacity curve predictor variable"
    capacity_curve_func = models.OneToOneField(
        'CapacityCurveFunc', related_name='cc_predictor_var',
        verbose_name="Capacity curve function")
    #engineering_demand_par = models.IntegerField(
        #'Engineering demand parameter', choices=ENGINEERING_DEMAND_PARAMETERS)
    engineering_demand_par = models.CharField(
        'Engineering demand parameter',
        max_length=CHMAX)
    data_pts_num = models.IntegerField(
        'Number of data points')
    # Validation:
    # if engineering_demand_par
    # in (Interstorey drift, Global drift):
    #     ==> Dimensionless
    # in (Lateral roof displacement, Spectral displacement):
    #     ==> {cm, m}
    # in (Chord rotation, )
    #     ==> Radians
    # in (Curvature, )
    #     ==> {rad/km, rad/m}
    pred_var_units = models.CharField('Units', max_length=CHMAX)
    #pred_var_units = models.IntegerField()
    #pred_var_units = models.CharField(
        #'Predictor variable units', max_length=16)
    pred_var_val = SemicolonSeparatedFloatField(
        'Predictor variable values', max_length=1024)
    # Validation:
    # if cc_predictor_var.engineering_demand_par
    # in (Interstorey drift, Global drift, Lateral roof displacement):
    #     resp_var_par = Base shear
    # in (Chord rotation, Curvature)
    #     resp_var_par = Base bending moment
    # in (Spectral displacement)
    #     resp_var_par = Spectral acceleration
    #resp_var_par = models.IntegerField(
        #'Response variable parameter', choices=RESP_VAR_PAR)
    resp_var_par = models.CharField(max_length=CHMAX)
    #RESP_VAR_UNITS = (
        #(1, 'kN'),
        #(2, 'kN.m'),
        #(3, 'g'),
        #(4, 'cm/s^2'),
        #(5, 'm/s^2'),
    #)
    # Validation:
    # if resp_var_par == Base shear ==> kN
    #                 == Base bending moment ==> kN.m
    #                 == Spectral acceleration ==> {g, cm/s^2, m/s^2}
    resp_var_units = models.CharField(max_length=CHMAX)
    #resp_var_units = models.IntegerField(
        #'Response variable units', choices=RESP_VAR_UNITS)
    #resp_var_units = models.CharField(
        #'Response variable units', max_length=16)
    resp_var_val = SemicolonSeparatedFloatField(
        'Response variable values', max_length=1024)

    def clean(self):
        if len(self.pred_var_val.split(';')) != self.data_pts_num:
            raise ValidationError('The number of data points and the number '
                                  'of predictor variable values must '
                                  'be consistent')
        if len(self.resp_var_val.split(';')) != self.data_pts_num:
            raise ValidationError('The number of data points and the number '
                                  'of response variable values must '
                                  'be consistent')


# B4
class CapacityCurveFunc(models.Model):
    class Meta:
        verbose_name = "Capacity curve function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='capacity_curve_func',
        verbose_name='General information')
    # One2One with AnalyticalModelInfo
    # One2One with CC_PredictorVar
    method_of_estimation = models.IntegerField(
        choices=CC_METHODS_OF_ESTIMATION)


# B3-a
class FuncDistrDTLDiscr(models.Model):
    class Meta:
        verbose_name = 'Discrete function distribution'
    damage_to_loss_func = models.OneToOneField(
        'DamageToLossFunc', related_name='func_distr_dtl_discr',
        verbose_name="Damage to loss function")
    var_mean_val = SemicolonSeparatedFloatField(
        'Mean values', max_length=1024)
    var_val_coeff = SemicolonSeparatedFloatField(
        'Coefficient of variation values', max_length=1024,
        null=True, blank=True)
    func_distr_shape = models.ForeignKey(
        'FuncDistrShape', null=True, blank=True,
        verbose_name='Function distribution shape')


# B3
class DamageToLossFunc(models.Model):
    class Meta:
        verbose_name = "Damage to loss function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='damage_to_loss_func',
        verbose_name='General information')
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with FuncDistrDTLDiscr
    # begin group 'Predictor variable (damage state)'
    damage_scale = models.IntegerField(
        choices=DAMAGE_SCALES, null=True, blank=True)
    limit_states_desc = SemicolonSeparatedStringField(
        'Description of limit states', max_length=1024)
    # end group 'Predictor variable (damage state)'
    resp_var = models.IntegerField(
        'Response variable', choices=RESP_VARS)

    @property
    def limit_states_num(self):
        return len(self.limit_states_desc.split(';'))


# B2-b
class FuncDistrVulnCont(models.Model):
    class Meta:
        verbose_name = "Continuous function distribution"
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', related_name='func_distr_vuln_cont',
        verbose_name="Vulnerability function")
    discretization_data_pts_num = models.IntegerField(
        'Number of discretization data points', null=True, blank=True)
    mean = models.FloatField()
    std_dev = models.FloatField('Standard deviation')
    func_distr_shape = models.ForeignKey(
        'FuncDistrShape', verbose_name="Function distribution shape")


# B2-a
class FuncDistrVulnDiscr(models.Model):
    class Meta:
        verbose_name = "Discrete function distribution"
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', related_name='func_distr_vuln_discr',
        verbose_name="Vulnerability function")
    data_pts_num = models.IntegerField('Number of data points')
    #predictor_var_im_val = SemicolonSeparatedFloatRomanField(
    predictor_var_im_val = SemicolonSeparatedFloatField(
        'Predictor variable (IM) values', max_length=1024)
    resp_var_mean_val = SemicolonSeparatedFloatField(
        'Response variable: mean values', max_length=1024)
    resp_var_val_coeff = SemicolonSeparatedFloatField(
        'Response variable: coefficient of variation values', max_length=1024,
        null=True, blank=True)

    def clean(self):
        if len(self.predictor_var_im_val.split(';')) != self.data_pts_num:
            raise ValidationError('The number of data points and the number '
                                  'of predictor variable (IM) values must '
                                  'be consistent')
        if len(self.resp_var_mean_val.split(';')) != self.data_pts_num:
            raise ValidationError(
                'The number of data points and the number of "Response '
                'variable: mean values" must be consistent')
        if len(self.resp_var_val_coeff.split(';')) != self.data_pts_num:
            raise ValidationError(
                'The number of data points and the number of "Response '
                'variable: coefficient of variation values" must be '
                'consistent')


# A2.2.2.1
class EvaluationOfIM(models.Model):
    # Initial values:
    #EVALUATIONS_OF_IM = (
        #(1, 'GMPE'),
        #(2, 'ShakeMap'),
        #(3, 'Natural Accelerograms'),
        #(4, 'Artificial Accelerograms'),
        #(5, 'Spectrum-compatible Accelerograms'),
        #(6, 'Spectrum (code-based)'),
        #(7, 'Spectrum (GMPE-based)'),
        #(8, 'Spectrum (other)'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# used by FragilityFunc and VulnerabilityFunc
# A.2.2
class PredictorVar(models.Model):
    class Meta:
        verbose_name = "Predictor variable (IM)"
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='predictor_var',
        verbose_name="Vulnerability function")
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='predictor_var',
        verbose_name="Fragility function")
    intensity_measure_type = models.CharField(
        max_length=CHMAX, choices=INTENSITY_MEASURE_TYPES)
    intensity_measure_unit = models.CharField(
        max_length=CHMAX, choices=INTENSITY_MEASURE_UNITS)
    TYPES_OF_PERIOD = (
        (1, 'Telastic (s)'),
        (2, 'Tyielding (s)'),
        (3, 'Tinelastic (s)'),
    )
    type_of_period = models.IntegerField(
        choices=TYPES_OF_PERIOD, null=True, blank=True)
    period = models.FloatField('Period (s)', null=True, blank=True)
    minimum_im = models.FloatField('Minimum IM', null=True, blank=True)
    maximum_im = models.FloatField('Maximum IM', null=True, blank=True)

    def clean(self):
        if self.intensity_measure_type:
            if int(self.intensity_measure_type) in (IMT.SAT, IMT.SDT):
                if not self.type_of_period or not self.period:
                    raise ValidationError(
                        'For this intensity measure type you '
                        'must specify both the type of period '
                        'and the period')
            elif self.type_of_period or self.period:
                raise ValidationError(
                    'For this intensity measure type, the type of period '
                    'and the period must be blank')


# B2
class VulnerabilityFunc(models.Model):
    class Meta:
        verbose_name = "Vulnerability function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='vulnerability_func',
        verbose_name='General information')
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # One2One with StatisticalInformation
    # One2One with PredictorVar
    # One2One with FuncDistrVulnDiscr
    # One2One with FuncDistrVulnCont
    # One2One with QRSEmpirical
    # One2One with QRSAnalytical
    resp_var = models.IntegerField('Response variable', choices=RESP_VARS)
    func_distr_type = models.IntegerField(
        'Function distribution type',
        choices=FUNC_DISTR_TYPES)


# B1-c
class FuncDistrFragCont(models.Model):
    class Meta:
        verbose_name = "Continous function distribution"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='func_distr_frag_cont',
        verbose_name='Fragility function')
    mean = SemicolonSeparatedFloatField(
        'Mean', max_length=1024)
    std_dev = SemicolonSeparatedFloatField(
        'Standard deviation', max_length=1024)
    func_distr_shape = models.ForeignKey(
        'FuncDistrShape',
        verbose_name='Function distribution shape')
    coeff_variation_mean = SemicolonSeparatedFloatField(
        'Coefficient of variation of the mean',
        max_length=1024, null=True, blank=True)
    coeff_variation_std_dev = SemicolonSeparatedFloatField(
        'Coefficient of variation of the standard deviation',
        max_length=1024, null=True, blank=True)
    predictor_var_corr_matrix = BidimensionalFloatField(
        'Predictor variable correlation matrix',
        null=True, blank=True, max_length=10240)

    def clean(self):
        if not self.fragility_func.limit_states_num:
            raise ValidationError('Please specify the number of limit states')
        else:
            limit_states_num = self.fragility_func.limit_states_num
            if (self.mean and
                    len(self.mean.split(';')) != limit_states_num):
                raise ValidationError(
                    'The number of items of "Mean" must be consistent with '
                    'the number of limit states (i.e. %d)' % limit_states_num)
            if (self.std_dev and
                    len(self.std_dev.split(';')) != limit_states_num):
                raise ValidationError(
                    'The number of items of "Standard deviation" must '
                    'be consistent with '
                    'the number of limit states (i.e. %d)' % limit_states_num)
            if (self.coeff_variation_mean and
                    len(self.coeff_variation_mean.split(';')) !=
                    limit_states_num):
                raise ValidationError(
                    'The number of items of "Coefficient of variation of '
                    'the mean" must be consistent with '
                    'the number of limit states (i.e. %d)' % limit_states_num)
            if (self.coeff_variation_std_dev and
                    len(self.coeff_variation_std_dev.split(';')) !=
                    limit_states_num):
                raise ValidationError(
                    'The number of items of "Coefficient of variation of '
                    'the standard deviation" must be consistent with '
                    'the number of limit states (i.e. %d)' % limit_states_num)
            if self.predictor_var_corr_matrix:
                rows = self.predictor_var_corr_matrix.split('\n')
                if len(rows) != limit_states_num:
                    raise ValidationError(
                        'The "Predictor variable correlation matrix" '
                        'must have a number of rows consistent with '
                        'the number of limit states '
                        '(i.e. %d' % limit_states_num)
                if rows and len(rows[0].split(';')) != limit_states_num:
                    raise ValidationError(
                        'The "Predictor variable correlation matrix" '
                        'must have a number of columns consistent with '
                        'the number of limit states '
                        '(i.e. %d' % limit_states_num)


# B1-b
class FuncDistrFragDiscr(models.Model):
    class Meta:
        verbose_name = "Discrete function distribution"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='func_distr_frag_discr',
        verbose_name='Fragility function')
    data_pts_num = models.IntegerField('Number of data points')
    #predictor_var_im_val = SemicolonSeparatedFloatRomanField(
    predictor_var_im_val = SemicolonSeparatedFloatField(
        'Predictor variable (IM) values', max_length=1024)
    limit_state_prob_exceed = BidimensionalFloatField(
        'Probability of limit state exceedance', max_length=10240)
    limit_state_prob_exceed_05 = BidimensionalFloatField(
        'Probability of limit state exceedance values '
        '(5% prediction interval)',
        null=True, blank=True, max_length=10240)
    limit_state_prob_exceed_95 = BidimensionalFloatField(
        'Probability of limit state exceedance values '
        '(95% prediction interval)',
        null=True, blank=True, max_length=10240)

    def clean(self):
        if len(self.predictor_var_im_val.split(';')) != self.data_pts_num:
            raise ValidationError(
                'The number of data points and the number of predictor '
                'variable (IM) values must be consistent')
        # Get the rows of each matrix
        prob_exceed_rows = None
        prob_exceed_05_rows = None
        prob_exceed_95_rows = None
        if self.limit_state_prob_exceed:
            prob_exceed_rows = self.limit_state_prob_exceed.split('\n')
        if self.limit_state_prob_exceed_05:
            prob_exceed_05_rows = self.limit_state_prob_exceed_05.split('\n')
        if self.limit_state_prob_exceed_95:
            prob_exceed_95_rows = self.limit_state_prob_exceed_95.split('\n')
        if (prob_exceed_rows and
                len(prob_exceed_rows[0].split(';')) != self.data_pts_num):
            raise ValidationError('The number of data points and the number '
                                  'of columns of "Probability of limit state '
                                  'exceedance" must be consistent')
        if (prob_exceed_05_rows and
                len(prob_exceed_05_rows[0].split(';')) != self.data_pts_num):
            raise ValidationError('The number of data points and the number '
                                  'of columns of "Probability of limit state '
                                  'exceedance values (5% prediction '
                                  'interval)" must be consistent')
        if (prob_exceed_95_rows and
                len(prob_exceed_95_rows[0].split(';')) != self.data_pts_num):
            raise ValidationError('The number of data points and the number '
                                  'of columns of "Probability of limit state '
                                  'exceedance values (95% prediction '
                                  'interval)" must be consistent')
        if not self.fragility_func.limit_states_num:
            raise ValidationError('Please specify the number of limit states')
        elif (prob_exceed_rows and
                (len(prob_exceed_rows) !=
                    self.fragility_func.limit_states_num)):
            raise ValidationError(
                'The number of rows of "Probability of limit state '
                'exceedance" must be consistent with the number of '
                'limit states specified (i.e. %d)' % (
                    self.fragility_func.limit_states_num))
        elif (prob_exceed_05_rows and
                (len(prob_exceed_05_rows) !=
                    self.fragility_func.limit_states_num)):
            raise ValidationError(
                'The number of rows of "Probability of limit state '
                'exceedance values (5%% prediction interval)" must be '
                'consistent with the number of limit states specified '
                '(i.e. %d)' % self.fragility_func.limit_states_num)
        elif (prob_exceed_95_rows and
                (len(prob_exceed_95_rows) !=
                    self.fragility_func.limit_states_num)):
            raise ValidationError(
                'The number of rows of "Probability of limit state '
                'exceedance values (95%% prediction interval)" must be '
                'consistent with the number of limit states specified '
                '(i.e. %d)' % self.fragility_func.limit_states_num)


# A1-a
class EngineeringDemandPar(models.Model):
    class Meta:
        verbose_name = "Engineering demand parameter"
    # Initial data
    #ENGINEERING_DEMAND_PARAMETERS = (
        #(1, 'Interstorey drift'),
        #(2, 'Global drift'),
        #(3, 'Residual drift'),
        #(4, 'Rotation capacity'),
        #(5, 'Shear capacity'),
        #(6, 'Strain levels'),
        #(7, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# B1
class FragilityFunc(models.Model):
    class Meta:
        verbose_name = "Fragility function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='fragility_func',
        verbose_name='General information')
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # One2One with StatisticalInformation
    # One2One with PredictorVar
    # One2One with FuncDistrFragDiscr
    # One2One with FuncDistrFragCont
    # One2One with QRSEmpirical
    # One2One with QRSAnalytical
    # TODO Grouping 'Damage characterization'
    damage_scale = models.IntegerField(
        choices=DAMAGE_SCALES, null=True, blank=True)
    engineering_demand_par = models.ForeignKey(
        'EngineeringDemandPar', null=True, blank=True,
        verbose_name='Engineering demand parameter')
    limit_states_desc = SemicolonSeparatedStringField(
        'Description of limit states', max_length=1024)
    func_distr_type = models.IntegerField(
        'Function distribution type',
        choices=FUNC_DISTR_TYPES)

    @property
    def limit_states_num(self):
        if self.limit_states_desc:
            return len(self.limit_states_desc.split(';'))
        else:
            return 0


class CAT(object):
    STR_SPEC = 1
    STR_CLASS = 2
    NONSTR_COMP = 3
    POPULATION = 4
    CAPITAL_STOCK = 5


CATEGORIES = (
    (1, 'Structure specific'),
    (2, 'Structure class'),
    (3, 'Nonstructural component'),
    (4, 'Population'),
    (5, 'Capital stock'),
)


class STR_TYPE(object):
    BUILDING = 1
    BRIDGE = 2
    OTHER = 3


STRUCTURE_TYPES = (
    (STR_TYPE.BUILDING, 'Building'),
    # (STR_TYPE.BRIDGE, 'Bridge'),
    # (STR_TYPE.OTHER, 'Other'),
)


# A
class GeneralInformation(models.Model):
    # one2one with FragilityFunc
    # one2one with VulnerabilityFunc
    # one2one with DamageToLossFunc
    # one2one with CapacityCurveFunc
    # one2one with GeoApplicability
    # A.1 Reference ID code/name: choose integer(code)/string(name)
    name = models.CharField(max_length=CHMAX)
    category = models.IntegerField(choices=CATEGORIES)
    # For category in (Structure specific, Structure class)
    # it's possible to select among
    # Buildings, Bridges and other types of structures
    # Bridge and Other will be available in the next release
    structure_type = models.IntegerField(
        choices=STRUCTURE_TYPES, blank=True, null=True)
    # For Nonstructural component you can use ATC58 taxonomy and other
    # if the structure is a Building, specify the taxonomy
    taxonomy_type = models.ForeignKey('TaxonomyType', blank=True, null=True)
    taxonomy_text = models.CharField(max_length=1023, blank=True, null=True)
    taxonomy_gem = models.CharField(
        max_length=1023, blank=True, null=True, editable=False)
    # if a structure is a Bridge, specify material and llrs
    # NOTE: we are creating these fields in the DB although they are going to
    # be available to the user in a future release
    material = models.CharField(
        max_length=CHMAX, blank=True, null=True, editable=False)
    llrs = models.CharField(
        max_length=CHMAX, blank=True, null=True, editable=False,
        verbose_name="Lateral load resisting system (LLRS)")
    # else TODO: What then?? Add new item to STRUCTURE_TYPES, which therefore
    # needs to become a new table?

    type_of_assessment = models.IntegerField(choices=TYPES_OF_ASSESSMENT)
    # A.3 Reference / documentation
    # TODO: Capire come raggruppare come nell'inline
    authors = models.CharField(max_length=CHMAX)
    article_title = models.CharField(max_length=CHMAX)
    publication_conference_name = models.CharField(
        max_length=CHMAX)
    year = models.IntegerField(
        validators=[MinValueValidator(1900),
                    MaxValueValidator(datetime.now().year)])
    web_link = models.URLField(null=True, blank=True, max_length=255)
    general_comments = models.TextField(
        max_length=TFMAX, null=True, blank=True)
    use_case_information = models.TextField(
        max_length=TFMAX, null=True, blank=True)

    def clean(self):
        if self.category:
            if int(self.category) not in (CAT.STR_SPEC, CAT.STR_CLASS):
                if self.structure_type:
                    raise ValidationError(
                        'Structure type must be empty for '
                        'the selected category')
            elif not self.structure_type:
                raise ValidationError(
                    'Please specify the structure type')
        if self.structure_type != STR_TYPE.BUILDING:
            if self.taxonomy_type or self.taxonomy_text:
                raise ValidationError(
                    'The taxonomy must be specified only if the '
                    'structure type is "Building"')
        # TODO: When Bridge structures will be included, check that material
        # and llrs are filled when Bridge is selected
        # TODO: Give the proper value to taxonomy_gem
        self.taxonomy_gem = self.taxonomy_text
        return True
