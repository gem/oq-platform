# Copyright (c) 2012-2015, GEM Foundation.
#
# This program is free software: you can redistribute it and/or modify
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#import re
from datetime import datetime
from django.contrib.gis.db import models
# from django.db import models
from django.core.exceptions import ValidationError
from django_extras.contrib.auth.models import SingleOwnerMixin
from commons import (SemicolonSeparatedFloatFormField,
                     #SemicolonSeparatedFloatRomanFormField,
                     SemicolonSeparatedStringFormField,
                     BidimensionalFloatFormField, )
#from django.core import validators
#from django.core.validators import RegexValidator
from django.contrib.auth.models import User
from django.forms.fields import MultiValueField, BooleanField, CharField
from django.core.validators import MinValueValidator, MaxValueValidator
from openquakeplatform.models import UnaccentCharField
from openquakeplatform.vulnerability.widgets import TaxonomyInput, TaxonomyOutput

from django.contrib.auth.models import Group, User
from django.dispatch import receiver
from django.db.models.signals import post_save

# somewhere, in your models.py file
@receiver(post_save, sender=User, dispatch_uid='openquakeplatform.vulnerability.models.user_post_save_handler')
def user_post_save(sender, instance, created, **kwargs):
    """ This method is executed whenever an user object is saved
    """
    if created:
        instance.groups.add(Group.objects.get(name='vulnerability-editors'))

class TaxonomyInputField(MultiValueField):
    widget = TaxonomyInput

    def __init__(self, max_length=31, attrs={}, *args, **kwargs):
        self.my_attrs = attrs
        list_fields = [BooleanField(),
                       CharField(max_length=max_length)]
        super(TaxonomyInputField, self).__init__(list_fields, *args, **kwargs)

    def compress(self, values):
        if values[0] is False and values[1] == "":
            return "__InvaliDValuE__"

        return values[1]

class TaxonomyOutputField(CharField):
    widget = TaxonomyOutput


class SemicolonSeparatedFloatField(models.CharField):
    description = "Semicolon-separated floats"

    __metaclass__ = models.SubfieldBase

    def formfield(self, form_class=SemicolonSeparatedFloatFormField, **kwargs):
        help_text = 'Enter semicolon-separated floats (e.g. 4.5;3;2.2)'
        if self.help_text:
            help_text += '. ' + self.help_text
        defaults = {
            "label": self.verbose_name,
            # NOTE: we decided to check with respect to self.null instead of
            # using self.blank, because it seems to be more logically correct
            "required": not self.null,
            "help_text": help_text}
        defaults.update(kwargs)
        return form_class(**defaults)


#class SemicolonSeparatedFloatRomanField(models.CharField):
    #description = "Semicolon-separated floats or roman numerals"

    #__metaclass__ = models.SubfieldBase

    #def formfield(self,
                  #form_class=SemicolonSeparatedFloatRomanFormField,
                  #**kwargs):
        #defaults = {
            #"help_text": ("Enter semicolon-separated floats or roman numerals"
                          #" (e.g. 4.5;3;2.2 or IV;II;VII)")
        #}
        #defaults.update(kwargs)
        #return form_class(**defaults)


class SemicolonSeparatedStringField(models.CharField):
    description = "Semicolon-separated strings"

    __metaclass__ = models.SubfieldBase

    def formfield(self,
                  form_class=SemicolonSeparatedStringFormField, **kwargs):
        help_text = ('Enter semicolon-separated strings '
                     '(e.g. first;second;third)')
        if self.help_text:
            help_text += '. ' + self.help_text
        defaults = {
            "label": self.verbose_name,
            # NOTE: we decided to check with respect to self.null instead of
            # using self.blank, because it seems to be more logically correct
            "required": not self.null,
            "help_text": help_text}
        defaults.update(kwargs)
        return form_class(**defaults)


class BidimensionalFloatField(models.TextField):
    description = "Matrix containing rows of semicolon-separated floats"

    __metaclass__ = models.SubfieldBase

    def formfield(self, form_class=BidimensionalFloatFormField, **kwargs):
        help_text = ('Enter rows of semicolon-separated floats '
                     '(e.g. 4.5;3;2.2 <Enter> 3.1;1;4 <Enter> '
                     '6.2;5.3;1.1)')
        if self.help_text:
            help_text += '. ' + self.help_text
        defaults = {
            "label": self.verbose_name,
            # NOTE: we decided to check with respect to self.null instead of
            # using self.blank, because it seems to be more logically correct
            "required": not self.null,
            "help_text": help_text}
        defaults.update(kwargs)
        return form_class(**defaults)


CHMAX = 200
TFMAX = 1023

QRS_VALUES = (
    (1, 'Superior'),
    (2, 'Average'),
    (3, 'Marginal'),
    (4, 'NA'),
)


# E2
class QRSEmpirical(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "Q.R.S. for empirical function/curve"
        verbose_name_plural = ("Q.R.S. for empirical "
                               "functions/curves")
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='qrs_empirical',
        verbose_name="fragility function")
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='qrs_empirical',
        verbose_name="vulnerability function")
    # Group: Data quality
    data_quantity = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    constrained_categories = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    excitation_observation = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    damage_loss_observation = models.IntegerField(
        'Damage/loss observation', choices=QRS_VALUES, null=True, blank=True)
    # end group
    # Group: Rationality
    hindcasting = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    cross_validation = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    first_principles = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    uncertainties_treatment = models.IntegerField(
        'Treatment of uncertainties', choices=QRS_VALUES,
        null=True, blank=True)
    # end group
    documentation_quality = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    documentation_type = models.IntegerField(
        'Type of documentation', choices=QRS_VALUES, null=True, blank=True)
    representativeness = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)


# E1
class QRSAnalytical(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "Q.R.S. for analytical function/curve"
        verbose_name_plural = ("Q.R.S for analytical "
                               "functions/curves")
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='qrs_analytical',
        verbose_name="fragility function")
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='qrs_analytical',
        verbose_name="vulnerability function")
    # Group: Data quality
    structural_details = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    model_completeness = models.IntegerField(
        'Completeness of model', choices=QRS_VALUES, null=True, blank=True)
    seismic_demand = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    # end group
    # Group: Rationality
    analysis_type = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    limit_states_def = models.IntegerField(
        'Definition of Limit States', choices=QRS_VALUES,
        null=True, blank=True)
    sampling_method = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    cross_validation = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    uncertainties_treatment = models.IntegerField(
        'Treatment of uncertainties', choices=QRS_VALUES,
        null=True, blank=True)
    # end group
    # Group: Documentation quality
    documentation_quality = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    documentation_type = models.IntegerField(
        'Type of documentation', choices=QRS_VALUES, null=True, blank=True)
    # end group
    # Group: Representativeness
    typology_repr = models.IntegerField(
        'Representation of typology', choices=QRS_VALUES,
        null=True, blank=True)
    site_specific = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    hazard_model = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    # end group


# D4-e
class StatModel(SingleOwnerMixin, models.Model):
    # Initial values
    #STATISTICAL_MODELS = (
        #(1, 'Generalised Linear Models'),
        #(2, 'Generalised Additive Models'),
        #(3, 'Kernel smoothing'),
        #(4, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D4-d
class StatModelFittingMethod(SingleOwnerMixin, models.Model):
    # Initial values
    #STAT_MODEL_FITTING_METHODS = (
        #(1, 'Least squares'),
        #(2, 'Maximum likelyhood'),
        #(3, 'Robust maximum likelyhood'),
        #(4, 'Bayesian'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D4-c
class ModelFittingMethodAssumption(SingleOwnerMixin, models.Model):
    # Initial values
    #MODEL_FITTING_METHOD_ASSUMPTIONS = (
        #(1, 'Independence of observations'),
        #(2, 'Measurement error in IM'),
        #(3, 'Measurement error in response'),
        #(4, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D4-b
class FitAssessmentGoodness(SingleOwnerMixin, models.Model):
    # Initial values
    #FIT_ASSESSMENT_GOODNESS_OPTIONS = (
        #(1, 'Acceptable mean function'),
        #(2, 'Acceptable variance function'),
        #(3, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D4-a
class ProcConstrInt(SingleOwnerMixin, models.Model):
    # Initial values
    #PROC_CONSTR_INT_CHOICES = (
        #(1, 'Asymptotic'),
        #(2, 'Bootstrap'),
        #(3, 'Bayesian'),
        #(4, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D4
class StatisticalInformation(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name_plural = "statistical information"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True, blank=True,
        related_name='stat_info',
        verbose_name='fragility function')
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True, blank=True,
        related_name='stat_info',
        verbose_name='vulnerability function')
    stat_model = models.ForeignKey(
        'StatModel', null=True, blank=True,
        verbose_name='statistical model')
    stat_model_fitting_method = models.ForeignKey(
        'StatModelFittingMethod', null=True, blank=True,
        verbose_name='statistical model fitting method')
    model_fitting_method_assumptions = models.ForeignKey(
        'ModelFittingMethodAssumption', null=True, blank=True)
    fit_assessment_goodness = models.ForeignKey(
        'FitAssessmentGoodness', null=True, blank=True,
        verbose_name='goodness of fit assessment (G.L.M./G.A.M.)')
    proc_constr_conf_int = models.ForeignKey(
        'ProcConstrInt', null=True, blank=True,
        verbose_name='proc. for constructing conf. intervals',
        related_name='stat_info_conf')
    proc_constr_pred_int = models.ForeignKey(
        'ProcConstrInt', null=True, blank=True,
        verbose_name='proc. for constructing pred. intervals',
        related_name='stat_info_pref')


# D2
class EmpiricalModelInfo(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "empirical modelling information"
        verbose_name_plural = "empirical modelling information"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='empirical_model_info',
        verbose_name="fragility function")
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='empirical_model_info',
        verbose_name="vulnerability function")
    structural_unit = models.IntegerField(null=True, blank=True, choices=(
        (1, 'Dwelling'), (2, 'Building')))
    building_x_class_num = models.IntegerField(
        'Number of buildings per class', null=True, blank=True)
    empirical_data_src = models.CharField(
        'Source of empirical data', max_length=CHMAX, null=True, blank=True)
    BA_BUILDING_BY_BUILDING = 1
    BA_GROUPED = 2
    building_aggr = models.IntegerField(
        'Building aggregation', null=True, blank=True,
        choices=((BA_BUILDING_BY_BUILDING, 'Building-by-building'),
                 (BA_GROUPED, 'Grouped')))
    building_aggr_min_num = models.IntegerField(
        'Minimum number of grouped buildings', null=True, blank=True,
        help_text='Mandatory if "Building aggregation" is "Grouped"')
    AGGR_UNIT_DEFS = (
        (1, 'GADM admin 2 region'),
        (2, 'GADM admin 3 region'),
        (3, 'Other admin region'),
        (4, 'Bins of IM'),
    )
    aggr_unit_def = models.IntegerField(
        'Definitions of aggregated units',
        choices=AGGR_UNIT_DEFS, null=True, blank=True)
    evaluation_of_im = models.ForeignKey(
        'EvaluationOfIM', null=True, blank=True,
        verbose_name='evaluation of I.M.')

    def clean(self):
        if self.building_aggr == self.BA_BUILDING_BY_BUILDING:
            self.building_aggr_min_num = None
        elif (self.building_aggr == self.BA_GROUPED
              and self.building_aggr_min_num is None):
            raise ValidationError(
                'You must specify the min number of grouped buildings')
        return True


class AMT(object):
    _3D = 1
    _2D_EL_BY_EL = 2
    _2D_ST_BY_ST = 3
    _1D = 4


ANALYTICAL_MODEL_TYPES = (
    (AMT._3D, '3D'),
    (AMT._2D_EL_BY_EL, '2D element-by-element'),
    (AMT._2D_ST_BY_ST, '2D story-by-story'),
    (AMT._1D, '1D'),
)


# D1-a
class AnalysisType(SingleOwnerMixin, models.Model):
    # Initial values
    #ANALYSIS_TYPES = (
        #(1, 'Nonlinear dynamic analysis (NLD)'),
        #(2, 'Nonlinear static analysis (NLS) with dispersion'),
        #(3, 'NLS without dispersion'),
        #(4, 'Collapse mechanism-based methods'),
        #(5, 'Simplified Displacement-based methods'),
        #(6, 'Other simplified methods'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D1
class AnalyticalModelInfo(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "analytical modelling information"
        verbose_name_plural = "analytical modelling information"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='fragility function')
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='vulnerability function')
    analysis_type = models.ForeignKey('AnalysisType', null=True, blank=True)
    model_type = models.IntegerField(
        choices=ANALYTICAL_MODEL_TYPES, null=True, blank=True)
    METHODS_UNCERT_PROPAG = (
        (1, 'Random Monte-Carlo or Latin Hypercube sampling'),
        (2, 'Set of index buildings'),
        (3, 'Single index building'),
    )
    method_uncert_propag = models.IntegerField(
        'Method of uncertainty propagation',
        choices=METHODS_UNCERT_PROPAG, null=True, blank=True)
    models_num = models.IntegerField(
        'Number of distinct structural models analysed',
        null=True, blank=True)
    evaluation_of_im = models.ForeignKey(
        'EvaluationOfIM', null=True, blank=True,
        verbose_name='evaluation of I.M.')


# D3-a
class CC_AnalysisType(SingleOwnerMixin, models.Model):
    # Initial values
    #ANALYSIS_TYPES = (
        #(1, 'Nonlinear static analysis (NLS) with dispersion'),
        #(2, 'NLS without dispersion'),
        #(3, 'Collapse mechanism-based methods'),
        #(4, 'Simplified Displacement-based methods'),
        #(5, 'Other simplified methods'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D3
class CC_AnalyticalModelInfo(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "analytical modelling information"
        verbose_name_plural = "analytical modelling information"
    capacity_curve_func = models.OneToOneField(
        'CapacityCurveFunc',
        related_name='cc_analytical_model_info',
        verbose_name='capacity curve function')
    analysis_type = models.ForeignKey('CC_AnalysisType', null=True, blank=True)
    model_type = models.IntegerField(
        choices=ANALYTICAL_MODEL_TYPES, null=True, blank=True)
    models_num = models.IntegerField(
        'Number of distinct structural models analysed',
        null=True, blank=True)
    struct_fund_period = models.FloatField(
        'Fundamental period of the structure (s)', blank=True, null=True)
    modal_part_fact = models.FloatField(
        'Modal partecipation factor', blank=True, null=True)


REGIONS = (
    ('', '--------'),
    (1, 'Worldwide'),
    (2, 'Africa'),
    (3, 'North America'),
    (4, 'Central America & Caribbean'),
    (5, 'South America'),
    (6, 'Asia'),
    (7, 'Europe'),
    (8, 'Oceania'),
    (9, 'Antarctica'),
)


class Country(models.Model):
    class Meta:
        verbose_name_plural = "countries"

    name = models.CharField(max_length=CHMAX)
    region = models.IntegerField(choices=REGIONS)
    iso3 = models.CharField(max_length=3, primary_key=True)
    the_geom = models.GeometryField(srid=4326, dim=2, null=True, blank=True)
    is_visible = models.BooleanField(default=True)

    def __unicode__(self):
        return '%s (%s)' % (self.name, self.iso3)


# B
class GeoApplicability(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "geographical applicability"
        verbose_name_plural = "geographical applicability"

    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='geo_applicability',
        verbose_name='general information')
    countries = models.ManyToManyField(Country)
    # administrative_region =
    area = models.CharField(max_length=CHMAX, blank=True, null=True)
    # Unique location
    lat = models.FloatField(blank=True, null=True)
    lon = models.FloatField(blank=True, null=True)
    address = models.TextField(blank=True, null=True)


class MOE(object):
    ANALYTICAL = 1
    EMPIRICAL = 2
    EXPERT_OPINION = 3


METHODS_OF_ESTIMATION = (
    (MOE.ANALYTICAL, 'Analytical'),
    (MOE.EMPIRICAL, 'Empirical'),
    (MOE.EXPERT_OPINION, 'Expert Opinion'),
)

CC_METHODS_OF_ESTIMATION = (
    (MOE.ANALYTICAL, 'Analytical'),
    (MOE.EMPIRICAL, 'Empirical'),
)


class FDT(object):
    DISCRETE = 1
    CONTINUOUS = 2


FUNC_DISTR_TYPES = (
    (FDT.DISCRETE, 'Discrete'),
    (FDT.CONTINUOUS, 'Continuous'),
)


DAMAGE_SCALES = (
    (1, 'MSK-76'),
    (2, 'EMS-98'),
    (3, 'EMS-92'),
    (4, 'HAZUS'),
    (5, 'ATC-13'),
    (6, 'Custom'),
)


class RV(object):
    DF = 1
    FRPO = 2
    NFIRPO = 3
    FRPEP = 4
    DEF = 5

RESP_VARS = (
    (RV.DF, 'Damage factor'),
    (RV.FRPO, 'Fatality rate per occupant'),
    (RV.NFIRPO, 'Nonfatal injury rate per occupant'),
    (RV.FRPEP, 'Fatality rate per exposed population'),
    (RV.DEF, 'Direct economic factor'),
)


class RVP(object):
    BASE_SHEAR = 1
    BASE_BENDING_MOMENT = 2
    SPECTRAL_ACCELERATION = 3
    BASE_SHEAR_COEF = 4

RESP_VAR_PAR = (
    (str(RVP.BASE_SHEAR), 'Base shear'),
    (str(RVP.BASE_BENDING_MOMENT), 'Base bending moment'),
    (str(RVP.SPECTRAL_ACCELERATION), 'Spectral acceleration'),
    (str(RVP.BASE_SHEAR_COEF), 'Base shear coefficient (V/W)'),
)


class RVU(object):
    KN = 1
    KNM = 2
    G = 3
    CMS2 = 4
    MS2 = 5
    NO_DIM = 6

RESP_VAR_UNITS = (
    (str(RVU.KN), 'kN'),
    (str(RVU.KNM), 'kN.m'),
    (str(RVU.G), 'g'),
    (str(RVU.CMS2), 'cm/s^2'),
    (str(RVU.MS2), 'm/s^2'),
    (str(RVU.NO_DIM), 'Dimensionless'), )


class TA(object):
    FRAGILITY = 1
    VULNERABILITY = 2
    DAMAGE_TO_LOSS = 3
    CAPACITY_CURVE = 4

TYPES_OF_ASSESSMENT = (
    (TA.FRAGILITY, 'Fragility'),
    (TA.VULNERABILITY, 'Vulnerability'),
    (TA.DAMAGE_TO_LOSS, 'Damage-to-loss'),
    (TA.CAPACITY_CURVE, 'Capacity curve'),
)


class IMT(object):
    PGA = 1
    PGV = 2
    PGD = 3
    SAT = 4
    SDT = 5
    IA = 6
    CAV = 7
    RSD = 8
    MMI = 9

INTENSITY_MEASURE_TYPES = (
    ('', '--------'),
    (str(IMT.PGA), 'PGA'),
    (str(IMT.PGV), 'PGV'),
    (str(IMT.PGD), 'PGD'),
    (str(IMT.SAT), 'Sa(T)'),
    (str(IMT.SDT), 'Sd(T)'),
    (str(IMT.IA), 'IA'),
    (str(IMT.CAV), 'CAV'),
    (str(IMT.RSD), 'RSD'),
    (str(IMT.MMI), 'MMI'),
)


class IMU(object):
    G = 1
    CM_S2 = 2
    M_S2 = 3
    CM_S = 4
    M_S = 5
    CM = 6
    M = 7
    S = 8
    GS = 9
    ROMAN = 10


INTENSITY_MEASURE_UNITS = (
    (str(IMU.G), 'g'),
    (str(IMU.CM_S2), 'cm/s^2'),
    (str(IMU.M_S2), 'm/s^2'),
    (str(IMU.CM_S), 'cm/s'),
    (str(IMU.M_S), 'm/s'),
    (str(IMU.CM), 'cm'),
    (str(IMU.M), 'm'),
    (str(IMU.S), 's'),
    (str(IMU.GS), 'g-s'),
    (str(IMU.ROMAN), 'Roman numbers'),
)


class EDP(object):
    INTERSTOREY_DRIFT = 1
    GLOBAL_DRIFT = 2
    LATERAL_ROOF_DISPLACEMENT = 3
    CHORD_ROTATION = 4
    CURVATURE = 5
    SPECTRAL_DISPLACEMENT = 6

CC_ENGINEERING_DEMAND_PARAMETERS = (
    ('', '--------'),
    (str(EDP.INTERSTOREY_DRIFT), 'Interstorey drift'),
    (str(EDP.GLOBAL_DRIFT), 'Global drift'),
    (str(EDP.LATERAL_ROOF_DISPLACEMENT), 'Lateral roof displacement'),
    (str(EDP.CHORD_ROTATION), 'Chord rotation'),
    (str(EDP.CURVATURE), 'Curvature'),
    (str(EDP.SPECTRAL_DISPLACEMENT), 'Spectral displacement'),
)


class EDU(object):
    PURE = 1
    CM = 2
    M = 3
    RAD = 4
    RAD_KM = 5
    RAD_M = 6


class PVU(object):
    DIMLESS = 1
    CM = 2
    M = 3
    RAD = 4
    RADKM = 5
    RADM = 6

PRED_VAR_UNITS = (
    (str(PVU.DIMLESS), 'Dimensionless'),
    (str(PVU.CM), 'cm'),
    (str(PVU.M), 'm'),
    (str(PVU.RAD), 'rad'),
    (str(PVU.RADKM), 'rad/km'),
    (str(PVU.RADM), 'rad/m'),
)


class FDS(object):
    LOGNORMAL = 1
    BETA = 2


FUNC_DISTR_SHAPES_ALL = (
    (FDS.LOGNORMAL, 'Lognormal'),
    (FDS.BETA,      'Beta'),
)

FUNC_DISTR_SHAPES_NRML_ALL = (
    (FDS.LOGNORMAL, 'LN'),
    (FDS.BETA,      'BT'),
)

FUNC_DISTR_SHAPES_LN = (
    (FDS.LOGNORMAL, 'Lognormal'),
)


# A1
class TaxonomyType(SingleOwnerMixin, models.Model):
    # Initial values: GEM, PAGER, ATC58
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# A4-a
class CC_PredictorVar(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "capacity curve predictor variable"
    capacity_curve_func = models.OneToOneField(
        'CapacityCurveFunc', related_name='cc_predictor_var',
        verbose_name="capacity curve function")
    engineering_demand_par = models.CharField(
        'Engineering demand parameter',
        max_length=CHMAX,
        choices=CC_ENGINEERING_DEMAND_PARAMETERS)
    data_pts_num = models.IntegerField(
        'Number of data points')
    # Validation:
    # if engineering_demand_par
    # in (Interstorey drift, Global drift):
    #     ==> Dimensionless
    # in (Lateral roof displacement, Spectral displacement):
    #     ==> {cm, m}
    # in (Chord rotation, )
    #     ==> Radians
    # in (Curvature, )
    #     ==> {rad/km, rad/m}
    pred_var_units = models.CharField(
        'Predictor variable units',
        max_length=CHMAX,
        choices=PRED_VAR_UNITS)
    #pred_var_units = models.IntegerField()
    #pred_var_units = models.CharField(
        #'Predictor variable units', max_length=16)
    pred_var_val = SemicolonSeparatedFloatField(
        'Predictor variable values', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of data points.'))
    # Validation:
    # if cc_predictor_var.engineering_demand_par
    # in (Interstorey drift, Global drift, Lateral roof displacement):
    #     resp_var_par = Base shear
    # in (Chord rotation, Curvature)
    #     resp_var_par = Base bending moment
    # in (Spectral displacement)
    #     resp_var_par = Spectral acceleration
    resp_var_par = models.CharField(
        'Response variable parameter',
        max_length=CHMAX,
        choices=RESP_VAR_PAR)
    # Validation:
    # if resp_var_par == Base shear ==> kN
    #                 == Base bending moment ==> kN.m
    #                 == Spectral acceleration ==> {g, cm/s^2, m/s^2}
    resp_var_units = models.CharField(
        'Response variable units',
        max_length=CHMAX,
        choices=RESP_VAR_UNITS)
    resp_var_val = SemicolonSeparatedFloatField(
        'Response variable values', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of data points.'))

    def clean(self):
        if len(self.pred_var_val.split(';')) != self.data_pts_num:
            raise ValidationError('The number of data points and the number '
                                  'of predictor variable values must '
                                  'be consistent')
        if len(self.resp_var_val.split(';')) != self.data_pts_num:
            raise ValidationError('The number of data points and the number '
                                  'of response variable values must '
                                  'be consistent')


# B4
class CapacityCurveFunc(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "capacity curve function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='capacity_curve_func',
        verbose_name='general information')
    # One2One with CC_AnalyticalModelInfo
    # One2One with CC_PredictorVar
    method_of_estimation = models.IntegerField(
        choices=CC_METHODS_OF_ESTIMATION)


# B3-a
class FuncDistrDTLDiscr(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = 'discrete function distribution'
    damage_to_loss_func = models.OneToOneField(
        'DamageToLossFunc', related_name='func_distr_dtl_discr',
        verbose_name="damage to loss function")
    var_mean_val = SemicolonSeparatedFloatField(
        'Mean values', max_length=1024)
    var_val_coeff = SemicolonSeparatedFloatField(
        'Coefficient of variation values', max_length=1024,
        null=True, blank=True)
    func_distr_shape = models.IntegerField(
        choices=FUNC_DISTR_SHAPES_ALL,
        null=True, blank=True,
        # FIXME:  at this moment use default force to try
        #         to save hidden field set with errors
        # default=FDS.LOGNORMAL,
        verbose_name='function distribution shape',
        help_text=('Mandatory field if coefficient of variation '
                   'values are specified'))

    def clean(self):
        if not self.damage_to_loss_func.limit_states_num:
            raise ValidationError('Please specify the limit states')
        if (len(self.var_mean_val.split(';')) !=
                self.damage_to_loss_func.limit_states_num):
            raise ValidationError('The number of limit states and the number '
                                  'of mean values must '
                                  'be consistent')
        if self.var_val_coeff:
            if (len(self.var_val_coeff.split(';')) !=
                    self.damage_to_loss_func.limit_states_num):
                raise ValidationError(
                    'The number of limit states and the number '
                    'of coefficient of variation values must '
                    'be consistent')
            if not self.func_distr_shape:
                raise ValidationError('Please specify the function '
                                      'distribution shape')


# B3
class DamageToLossFunc(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "damage to loss function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='damage_to_loss_func',
        verbose_name='general information')
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with FuncDistrDTLDiscr
    # begin group 'Predictor variable (damage state)'
    damage_scale = models.IntegerField(
        choices=DAMAGE_SCALES, null=True, blank=True)
    limit_states_desc = SemicolonSeparatedStringField(
        'Description of limit states', max_length=1024,
        help_text='Select damage scale to automatically populate this field')
    # end group 'Predictor variable (damage state)'
    resp_var = models.IntegerField(
        'Response variable', choices=RESP_VARS)

    @property
    def limit_states_num(self):
        return len(self.limit_states_desc.split(';'))


# B2-b
class FuncDistrVulnCont(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "continuous function distribution"
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', related_name='func_distr_vuln_cont',
        verbose_name="vulnerability function")
    discretization_data_pts_num = models.IntegerField(
        'Number of discretization data points', null=True, blank=True)
    mean = models.FloatField()
    std_dev = models.FloatField('Standard deviation')
    func_distr_shape = models.IntegerField(
        choices=FUNC_DISTR_SHAPES_LN,
        verbose_name='function distribution shape')
    mean_var_coef = models.FloatField(
        'Coefficient of variation of the mean', null=True, blank=True)
    sd_var_coef = models.FloatField(
        'Coefficient of variation of the standard deviation',
        null=True, blank=True)

    def clean(self):
        if (self.discretization_data_pts_num
                and self.discretization_data_pts_num <= 1):
            raise ValidationError(
                'The number of discretization points, if defined,'
                ' must be greater than 1')


# B2-a
class FuncDistrVulnDiscr(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "discrete function distribution"
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', related_name='func_distr_vuln_discr',
        verbose_name="vulnerability function")
    data_pts_num = models.IntegerField('Number of data points')
    #predictor_var_im_val = SemicolonSeparatedFloatRomanField(
    predictor_var_im_val = SemicolonSeparatedFloatField(
        'Predictor variable (IM) values', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of data points.'))
    resp_var_mean_val = SemicolonSeparatedFloatField(
        'Response variable: mean values', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of data points.'))
    resp_var_val_coeff = SemicolonSeparatedFloatField(
        'Response variable: coefficient of variation values', max_length=1024,
        null=True, blank=True,
        help_text=('The number of values must be '
                   'consistent with the number of data points.'))
    func_distr_shape = models.IntegerField(
        choices=FUNC_DISTR_SHAPES_ALL,
        null=True, blank=True,
        # FIXME:  at this moment use default force to try
        #         to save hidden field set with errors
        # default=FDS.LOGNORMAL,
        verbose_name='function distribution shape',
        help_text=('Mandatory field if coefficient of variation '
                   'values are specified'))

    def clean(self):
        if len(self.predictor_var_im_val.split(';')) != self.data_pts_num:
            raise ValidationError('The number of data points and the number '
                                  'of predictor variable (IM) values must '
                                  'be consistent')
        if len(self.resp_var_mean_val.split(';')) != self.data_pts_num:
            raise ValidationError(
                'The number of data points and the number of "Response '
                'variable: mean values" must be consistent')
        if self.resp_var_val_coeff:
            if len(self.resp_var_val_coeff.split(';')) != self.data_pts_num:
                raise ValidationError(
                    'The number of data points and the number of "Response '
                    'variable: coefficient of variation values" must be '
                    'consistent')
            if not self.func_distr_shape:
                raise ValidationError('Please specify the function '
                                      'distribution shape')


# A2.2.2.1
class EvaluationOfIM(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "evaluation of I.M."
        verbose_name_plural = "evaluations of I.M."
    # Initial values:
    #EVALUATIONS_OF_IM = (
        #(1, 'GMPE'),
        #(2, 'ShakeMap'),
        #(3, 'Natural Accelerograms'),
        #(4, 'Artificial Accelerograms'),
        #(5, 'Spectrum-compatible Accelerograms'),
        #(6, 'Spectrum (code-based)'),
        #(7, 'Spectrum (GMPE-based)'),
        #(8, 'Spectrum (other)'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# used by FragilityFunc and VulnerabilityFunc
# A.2.2
class PredictorVar(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = 'predictor variable (I.M.)'
        verbose_name_plural = 'predictor variables (I.M.)'
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='predictor_var',
        verbose_name="vulnerability function")
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='predictor_var',
        verbose_name="fragility function")
    intensity_measure_type = models.CharField(
        max_length=CHMAX, choices=INTENSITY_MEASURE_TYPES)
    intensity_measure_unit = models.CharField(
        max_length=CHMAX, choices=INTENSITY_MEASURE_UNITS,
        help_text='Please select intensity measure type first')
    TYPES_OF_PERIOD = (
        (1, 'Telastic (s)'),
        (2, 'Tyielding (s)'),
        (3, 'Tinelastic (s)'),
    )
    type_of_period = models.IntegerField(
        choices=TYPES_OF_PERIOD, null=True, blank=True,
        help_text='Mandatory if the "Intensity measure type" is '
                  'Sa(T) or Sd(T). Please leave this field empty otherwise.')
    period = models.FloatField(
        'Period (s)', null=True, blank=True,
        help_text='Mandatory if the "Intensity measure type" is '
                  'Sa(T) or Sd(T). Please leave this field empty otherwise.')
    minimum_im = models.FloatField('Minimum IM')
    maximum_im = models.FloatField('Maximum IM')

    def clean(self):
        if self.intensity_measure_type:
            if int(self.intensity_measure_type) in (IMT.SAT, IMT.SDT):
                if not self.type_of_period or not self.period:
                    raise ValidationError(
                        'For this intensity measure type you '
                        'must specify both the type of period '
                        'and the period')
            elif self.type_of_period or self.period:
                raise ValidationError(
                    'For this intensity measure type, the type of period '
                    'and the period must be blank')


# B2
class VulnerabilityFunc(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "vulnerability function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='vulnerability_func',
        verbose_name='general information')
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # One2One with StatisticalInformation
    # One2One with PredictorVar
    # One2One with FuncDistrVulnDiscr
    # One2One with FuncDistrVulnCont
    # One2One with QRSEmpirical
    # One2One with QRSAnalytical
    resp_var = models.IntegerField('Response variable', choices=RESP_VARS)
    func_distr_type = models.IntegerField(
        'Function distribution type',
        choices=FUNC_DISTR_TYPES)


# B1-c
class FuncDistrFragCont(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "continous function distribution"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='func_distr_frag_cont',
        verbose_name='fragility function')
    mean = SemicolonSeparatedFloatField(
        'Mean', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of limit states.'))
    std_dev = SemicolonSeparatedFloatField(
        'Standard deviation', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of limit states.'))
    func_distr_shape = models.IntegerField(
        choices=FUNC_DISTR_SHAPES_LN,
        verbose_name='function distribution shape')
    coeff_variation_mean = SemicolonSeparatedFloatField(
        'Coefficient of variation of the mean',
        max_length=1024, null=True, blank=True,
        help_text=('The number of values must be '
                   'consistent with the number of limit states.'))
    coeff_variation_std_dev = SemicolonSeparatedFloatField(
        'Coefficient of variation of the standard deviation',
        max_length=1024, null=True, blank=True,
        help_text=('The number of values must be '
                   'consistent with the number of limit states.'))
    predictor_var_corr_matrix = BidimensionalFloatField(
        'Predictor variable correlation matrix',
        null=True, blank=True, max_length=10240,
        help_text=('The number of both rows and columns '
                   'must be twice the number of limit states.'))

    def clean(self):
        if not self.fragility_func.limit_states_num:
            raise ValidationError('Please specify the limit states')
        else:
            limit_states_num = self.fragility_func.limit_states_num
            if (self.mean and
                    len(self.mean.split(';')) != limit_states_num):
                raise ValidationError(
                    'The number of items of "Mean" must be consistent with '
                    'the number of limit states (i.e. %d)' % limit_states_num)
            if (self.std_dev and
                    len(self.std_dev.split(';')) != limit_states_num):
                raise ValidationError(
                    'The number of items of "Standard deviation" must '
                    'be consistent with '
                    'the number of limit states (i.e. %d)' % limit_states_num)
            if (self.coeff_variation_mean and
                    len(self.coeff_variation_mean.split(';')) !=
                    limit_states_num):
                raise ValidationError(
                    'The number of items of "Coefficient of variation of '
                    'the mean" must be consistent with '
                    'the number of limit states (i.e. %d)' % limit_states_num)
            if (self.coeff_variation_std_dev and
                    len(self.coeff_variation_std_dev.split(';')) !=
                    limit_states_num):
                raise ValidationError(
                    'The number of items of "Coefficient of variation of '
                    'the standard deviation" must be consistent with '
                    'the number of limit states (i.e. %d)' % limit_states_num)
            if self.predictor_var_corr_matrix:
                rows = self.predictor_var_corr_matrix.split('\n')
                if len(rows) != (2 * limit_states_num):
                    raise ValidationError(
                        'The number of rows of "Predictor variable '
                        'correlation matrix" '
                        'must be twice the number of limit states '
                        '(i.e. %d)' % (2 * limit_states_num))
                if rows and len(rows[0].split(';')) != (2 * limit_states_num):
                    raise ValidationError(
                        'The number of columns of "Predictor variable '
                        'correlation matrix" '
                        'must be twice the number of limit states '
                        '(i.e. %d)' % (2 * limit_states_num))


# B1-b
class FuncDistrFragDiscr(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "discrete function distribution"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='func_distr_frag_discr',
        verbose_name='fragility function')
    data_pts_num = models.IntegerField('Number of data points')
    #predictor_var_im_val = SemicolonSeparatedFloatRomanField(
    predictor_var_im_val = SemicolonSeparatedFloatField(
        'Predictor variable (IM) values', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of data points.'))
    limit_state_prob_exceed = BidimensionalFloatField(
        'Probability of limit state exceedance', max_length=10240,
        help_text=('The number of rows must be '
                   'consistent with the specified number of limit states; '
                   'the number of columns '
                   'must consistent with the number of data points.'))
    limit_state_prob_exceed_05 = BidimensionalFloatField(
        'Probability of limit state exceedance values '
        '(5% prediction interval)',
        null=True, blank=True, max_length=10240,
        help_text=('The number of rows must be '
                   'consistent with the specified number of limit states; '
                   'the number of columns '
                   'must consistent with the number of data points.'))
    limit_state_prob_exceed_95 = BidimensionalFloatField(
        'Probability of limit state exceedance values '
        '(95% prediction interval)',
        null=True, blank=True, max_length=10240,
        help_text=('The number of rows must be '
                   'consistent with the specified number of limit states; '
                   'the number of columns '
                   'must consistent with the number of data points.'))

    def clean(self):
        if len(self.predictor_var_im_val.split(';')) != self.data_pts_num:
            raise ValidationError(
                'The number of data points and the number of predictor '
                'variable (IM) values must be consistent')
        # Get the rows of each matrix
        prob_exceed_rows = None
        prob_exceed_05_rows = None
        prob_exceed_95_rows = None
        if self.limit_state_prob_exceed:
            prob_exceed_rows = self.limit_state_prob_exceed.split('\n')
        if self.limit_state_prob_exceed_05:
            prob_exceed_05_rows = self.limit_state_prob_exceed_05.split('\n')
        if self.limit_state_prob_exceed_95:
            prob_exceed_95_rows = self.limit_state_prob_exceed_95.split('\n')
        if (prob_exceed_rows and
                len(prob_exceed_rows[0].split(';')) != self.data_pts_num):
            raise ValidationError('The number of data points and the number '
                                  'of columns of "Probability of limit state '
                                  'exceedance" must be consistent')
        if (prob_exceed_05_rows and
                len(prob_exceed_05_rows[0].split(';')) != self.data_pts_num):
            raise ValidationError('The number of data points and the number '
                                  'of columns of "Probability of limit state '
                                  'exceedance values (5% prediction '
                                  'interval)" must be consistent')
        if (prob_exceed_95_rows and
                len(prob_exceed_95_rows[0].split(';')) != self.data_pts_num):
            raise ValidationError('The number of data points and the number '
                                  'of columns of "Probability of limit state '
                                  'exceedance values (95% prediction '
                                  'interval)" must be consistent')
        if not self.fragility_func.limit_states_num:
            raise ValidationError('Please specify the limit states')
        elif (prob_exceed_rows and
                (len(prob_exceed_rows) !=
                    self.fragility_func.limit_states_num)):
            raise ValidationError(
                'The number of rows of "Probability of limit state '
                'exceedance" must be consistent with the number of '
                'limit states specified (i.e. %d)' % (
                    self.fragility_func.limit_states_num))
        elif (prob_exceed_05_rows and
                (len(prob_exceed_05_rows) !=
                    self.fragility_func.limit_states_num)):
            raise ValidationError(
                'The number of rows of "Probability of limit state '
                'exceedance values (5%% prediction interval)" must be '
                'consistent with the number of limit states specified '
                '(i.e. %d)' % self.fragility_func.limit_states_num)
        elif (prob_exceed_95_rows and
                (len(prob_exceed_95_rows) !=
                    self.fragility_func.limit_states_num)):
            raise ValidationError(
                'The number of rows of "Probability of limit state '
                'exceedance values (95%% prediction interval)" must be '
                'consistent with the number of limit states specified '
                '(i.e. %d)' % self.fragility_func.limit_states_num)


# A1-a
class EngineeringDemandPar(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "engineering demand parameter"
    # Initial data
    #ENGINEERING_DEMAND_PARAMETERS = (
        #(1, 'Interstorey drift'),
        #(2, 'Global drift'),
        #(3, 'Residual drift'),
        #(4, 'Rotation capacity'),
        #(5, 'Shear capacity'),
        #(6, 'Strain levels'),
        #(7, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# B1
class FragilityFunc(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "fragility function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='fragility_func',
        verbose_name='general information')
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # One2One with StatisticalInformation
    # One2One with PredictorVar
    # One2One with FuncDistrFragDiscr
    # One2One with FuncDistrFragCont
    # One2One with QRSEmpirical
    # One2One with QRSAnalytical
    # TODO Grouping 'Damage characterization'
    damage_scale = models.IntegerField(
        choices=DAMAGE_SCALES, null=True, blank=True)
    engineering_demand_par = models.ForeignKey(
        'EngineeringDemandPar', null=True, blank=True,
        verbose_name='engineering demand parameter')
    limit_states_desc = SemicolonSeparatedStringField(
        'Description of limit states', max_length=1024,
        help_text='Select damage scale to automatically populate this field')
    func_distr_type = models.IntegerField(
        'Function distribution type',
        choices=FUNC_DISTR_TYPES)

    @property
    def limit_states_num(self):
        if self.limit_states_desc:
            return len(self.limit_states_desc.split(';'))
        else:
            return 0


class CAT(object):
    STR_SPEC = 1
    STR_CLASS = 2
    NONSTR_COMP = 3
    POPULATION = 4
    CAPITAL_STOCK = 5


CATEGORIES = (
    (CAT.STR_SPEC, 'Structure specific'),
    (CAT.STR_CLASS, 'Structure class'),
    (CAT.NONSTR_COMP, 'Nonstructural component'),
    (CAT.POPULATION, 'Population'),
    (CAT.CAPITAL_STOCK, 'Capital stock'),
)


class STR_TYPE(object):
    BUILDING = 1
    BRIDGE = 2
    OTHER = 3


STRUCTURE_TYPES = (
    (STR_TYPE.BUILDING, 'Building'),
    # (STR_TYPE.BRIDGE, 'Bridge'),
    # (STR_TYPE.OTHER, 'Other'),
)


class GeneralInformationManager(models.Manager):
    def get_by_natural_key(self, name):
        return self.get(name=name)


# A
class GeneralInformation(SingleOwnerMixin, models.Model):
    # one2one with FragilityFunc
    # one2one with VulnerabilityFunc
    # one2one with DamageToLossFunc
    # one2one with CapacityCurveFunc
    # one2one with GeoApplicability

    class Meta:
        verbose_name = "function"
        ordering = ['name']

    # A.1 Reference ID code/name: choose integer(code)/string(name)
    name = models.CharField(max_length=CHMAX, unique=True)
    category = models.IntegerField(choices=CATEGORIES)
    # For category in (Structure specific, Structure class)
    # it's possible to select among
    # Buildings, Bridges and other types of structures
    # Bridge and Other will be available in the next release
    structure_type = models.IntegerField(
        choices=STRUCTURE_TYPES, blank=True, null=True,
        help_text='"Building" type is only applicable to "Structure specific"'
        ' or "Structure class"')
    # For Nonstructural component you can use ATC58 taxonomy and other
    # if the structure is a Building, specify the taxonomy
    taxonomy_type = models.ForeignKey(
        'TaxonomyType', blank=True, null=True,
        help_text='Mandatory if the structure type is "Building".')
    taxonomy_text = models.CharField(max_length=1023, blank=True, null=True)
    taxonomy_gem = models.CharField(
        max_length=1023, blank=True, null=True)
    # if a structure is a Bridge, specify material and llrs
    # NOTE: we are creating these fields in the DB although they are going to
    # be available to the user in a future release
    material = models.CharField(
        max_length=CHMAX, blank=True, null=True, editable=False)
    llrs = models.CharField(
        max_length=CHMAX, blank=True, null=True, editable=False,
        verbose_name="lateral load resisting system (L.L.R.S.)")
    # else TODO: What then?? Add new item to STRUCTURE_TYPES, which therefore
    # needs to become a new table?

    type_of_assessment = models.IntegerField(choices=TYPES_OF_ASSESSMENT)
    # A.3 Reference / documentation
    # TODO: Capire come raggruppare come nell'inline
    authors = UnaccentCharField(max_length=CHMAX)
    article_title = models.CharField(max_length=CHMAX)
    publication_conference_name = models.CharField(
        max_length=CHMAX)
    year = models.IntegerField(
        validators=[MinValueValidator(1900),
                    MaxValueValidator(datetime.now().year)])
    web_link = models.URLField(null=True, blank=True, max_length=255)
    general_comments = models.TextField(
        max_length=TFMAX, null=True, blank=True)
    use_case_information = models.TextField(
        max_length=TFMAX, null=True, blank=True)

    cart = models.ManyToManyField(User)

    objects = GeneralInformationManager()

    def natural_key(self):
        return (self.name,)

    def clean(self):
        if int(self.category) not in (CAT.STR_SPEC, CAT.STR_CLASS):
            if self.structure_type:
                raise ValidationError(
                    'Structure type must be empty for '
                    'the selected category')
        elif not self.structure_type:
            raise ValidationError(
                'Please specify the structure type')

        taxonomy_text_invalid = False
        if self.taxonomy_text == "__InvaliDValuE__":
            taxonomy_text_invalid = True
            self.taxonomy_text = ""

        if self.taxonomy_text and not self.taxonomy_type:
            raise ValidationError(
                'To set taxonomy specify taxonomy type before')

        if self.type_of_assessment == TA.CAPACITY_CURVE:
            if int(self.category) not in (CAT.STR_SPEC,
                                          CAT.STR_CLASS,
                                          CAT.NONSTR_COMP):
                raise ValidationError(
                    'Capacity curves can only be assigned to structure'
                    ' specific, structure class or nonstructural components.')

        if (int(self.category) in (CAT.STR_SPEC, CAT.STR_CLASS, CAT.NONSTR_COMP)
            and self.structure_type == STR_TYPE.BUILDING):
            if not self.taxonomy_type:
                raise ValidationError(
                    'The structure type is "Building", so you must '
                    'specify both taxonomy type and taxonomy text')
            if self.taxonomy_type and self.taxonomy_type.name == 'ATC58':
                raise ValidationError(
                    'For buildings, the ATC58 taxonomy type is not applicable')
        # TODO: When Bridge structures will be included, check that material
        # and llrs are filled when Bridge is selected

        if self.taxonomy_type and taxonomy_text_invalid:
            raise ValidationError(
                'You must specify a taxonomy or check the "Any" taxonomy'
                ' checkbox.')

        return True

    def __unicode__(self):
        return self.name
