#import re
from django.db import models
from django.core.exceptions import ValidationError
#from django.core import validators
#from django.core.validators import RegexValidator

#comma_separated_float_list_re = re.compile('^([-+]?\d*\.?\d+[,\s]*)+$')
#validate_comma_separated_float_list = RegexValidator(
    #comma_separated_float_list_re,
    #u'Enter only floats separated by commas.', 'invalid')


class SemicolonSeparatedFloatField(models.CharField):
    pass
    #default_validators = [validate_comma_separated_float_list]
    #description = "Comma-separated floats"

    #def formfield(self, **kwargs):
        #defaults = {
            #'error_messages': {
                #'invalid': u'Enter only floats separated by commas.',
            #}
        #}
        #defaults.update(kwargs)
        #return super(SemicolonSeparatedFloatField, self).formfield(**defaults)


#semicolon_separated_string_list_re = re.compile('^([-+]?\d*\.?\d+[,\s]*)+$')
#validate_semicolon_separated_string_list = RegexValidator(
    #semicolon_separated_string_list_re,
    #u'Enter only strings separated by semicolons.', 'invalid')


class SemicolonSeparatedStringField(models.CharField):
    pass
    #default_validators = [validate_semicolon_separated_string_list]
    #description = "Semicolon-separated strings"

    #def formfield(self, **kwargs):
        #defaults = {
            #'error_messages': {
                #'invalid': u'Enter only floats separated by semicolons.',
            #}
        #}
        #defaults.update(kwargs)
        #return super(SemicolonSeparatedStringField, self).formfield(
            #**defaults)


class BidimensionalFloatField(models.TextField):
    pass
    #TODO default_validators =
    #description = ("Semicolon separated float fields with newline"
                   #" as rows separator")

    #def formfield(self, **kwargs):
        #defaults = {
            #'error_messages': {
                #'invalid': u'Enter only floats separated by semicolons.',
            #}
        #}
        #defaults.update(kwargs)
        #return super(BidimensionalFloatField, self).formfield(**defaults)


CHMAX = 200

QRS_VALUES = (
    (1, 'Superior'),
    (2, 'Average'),
    (3, 'Marginal'),
    (4, 'NA'),
)


# E2
class QRSEmpirical(models.Model):
    # Group: Data quality
    data_quantity = models.IntegerField(choices=QRS_VALUES)
    constrained_categories = models.IntegerField(choices=QRS_VALUES)
    excitation_observation = models.IntegerField(choices=QRS_VALUES)
    damage_loss_observation = models.IntegerField(
        'Damage/loss observation', choices=QRS_VALUES)
    # end group
    # Group: Representativeness
    hindcasting = models.IntegerField(choices=QRS_VALUES)
    cross_validation = models.IntegerField(choices=QRS_VALUES)
    first_principles = models.IntegerField(choices=QRS_VALUES)
    uncertainties_treatment = models.IntegerField(
        'Treatment of uncertainties', choices=QRS_VALUES)
    # end group
    documentation_quality = models.IntegerField(choices=QRS_VALUES)
    representativeness = models.IntegerField(choices=QRS_VALUES)
    overall_rating = models.IntegerField(choices=QRS_VALUES)


# E1
class QRSAnalytical(models.Model):
    # Group: Data quality
    structural_details = models.IntegerField(choices=QRS_VALUES)
    model_completeness = models.IntegerField(
        'Completeness of model', choices=QRS_VALUES)
    seismic_demand = models.IntegerField(choices=QRS_VALUES)
    # end group
    # Group: Documentation quality
    documentation_quality = models.IntegerField(choices=QRS_VALUES)
    documentation_type = models.IntegerField(
        'Type of documentation', choices=QRS_VALUES)
    # end group
    # Group: Representativeness
    typology_repr = models.IntegerField(
        'Representation of typology', choices=QRS_VALUES)
    site_specific = models.IntegerField(choices=QRS_VALUES)
    hazard_model = models.IntegerField(choices=QRS_VALUES)
    # end group
    overall_rating = models.IntegerField(choices=QRS_VALUES)


# E TODO Remove?
class QualityRatingSystem(models.Model):

    DATA_QUALITY_ESTIMATIONS = (
        (1, 'Superior'),
        (2, 'Average'),
        (3, 'Marginal'),
        (4, 'Not applicable'),
    )
    data_quality_estimation = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)
    RATIONALITY_CHOICES = (
        (1, 'Hindcasting'),
        (2, 'Cross validation'),
        (3, 'First principles'),
        (4, 'Treatment of uncertainties'),
    )
    rationality = models.IntegerField(choices=RATIONALITY_CHOICES)
    rationality_estimation = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)
    documentation_quality = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)
    representativeness = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)
    overall_rating = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)


# D3-e
class StatModel(models.Model):
    # Initial values
    #STATISTICAL_MODELS = (
        #(1, 'Generalised Linear Models'),
        #(2, 'Generalised Additive Models'),
        #(3, 'Kernel smoothing'),
        #(4, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# D3-d
class StatModelFittingMethod(models.Model):
    # Initial values
    #STAT_MODEL_FITTING_METHODS = (
        #(1, 'Least squares'),
        #(2, 'Maximum likelyhood'),
        #(3, 'Robust maximum likelyhood'),
        #(4, 'Bayesian'),
    #)
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# D3-c
class ModelFittingMethodAssumption(models.Model):
    # Initial values
    #MODEL_FITTING_METHOD_ASSUMPTIONS = (
        #(1, 'Independence of observations'),
        #(2, 'Measurement error in IM'),
        #(3, 'Measurement error in response'),
        #(4, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# D3-b
class FitAssessmentGoodness(models.Model):
    # Initial values
    #FIT_ASSESSMENT_GOODNESS_OPTIONS = (
        #(1, 'Acceptable mean function'),
        #(2, 'Acceptable variance function'),
        #(3, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# D3-a
class ProcConstrInt(models.Model):
    # Initial values
    #PROC_CONSTR_INT_CHOICES = (
        #(1, 'Asymptotic'),
        #(2, 'Bootstrap'),
        #(3, 'Bayesian'),
        #(4, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# D3
class StatisticalInformation(models.Model):
    class Meta:
        verbose_name_plural = "Statistical information"
    stat_model = models.ForeignKey(
        'StatModel',
        verbose_name='Statistical model')
    stat_model_fitting_method = models.ForeignKey(
        'StatModelFittingMethod',
        verbose_name='Statistical model fitting method')
    model_fitting_method_assumptions = models.ForeignKey(
        'ModelFittingMethodAssumption')
    fit_assessment_goodness = models.ForeignKey(
        'FitAssessmentGoodness',
        verbose_name='Goodness of fit assessment (GLM/GAM)')
    proc_constr_conf_int = models.ForeignKey(
        'ProcConstrInt',
        verbose_name='Procedure for the construction of confidence intervals',
        related_name='+')  # avoid creating clashing back reference
    proc_constr_pred_int = models.ForeignKey(
        'ProcConstrInt',
        verbose_name='Procedure for the construction of prediction intervals',
        related_name='+')  # avoid creating clashing back reference


# D2
class EmpiricalModelInfo(models.Model):
    class Meta:
        verbose_name = "Empirical modelling information"
        verbose_name_plural = "Empirical modelling information"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='empirical_model_info',
        verbose_name="Fragility function")
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='empirical_model_info',
        verbose_name="Vulnerability function")
    damage_to_loss_func = models.OneToOneField(
        'DamageToLossFunc', null=True,
        blank=True, related_name='empirical_model_info',
        verbose_name="Damage to loss function")
    structural_unit = models.IntegerField(choices=(
        (1, 'Dwelling'), (2, 'Building')))
    building_x_class_num = models.IntegerField(
        'Number of buildings per class')
    empirical_data_src = models.CharField(
        'Source of empirical data', max_length=CHMAX)
    BA_BUILDING_BY_BUILDING = 1
    BA_GROUPED = 2
    building_aggr = models.IntegerField(
        'Building aggregation',
        choices=((BA_BUILDING_BY_BUILDING, 'Building-by-building'),
                 (BA_GROUPED, 'Grouped')))
    building_aggr_min_num = models.IntegerField(
        'Minimum number of grouped buildings', null=True, blank=True)
    AGGR_UNIT_DEFS = (
        (1, 'GADM admin 2 region'),
        (2, 'GADM admin 3 region'),
        (3, 'Other admin region'),
        (4, 'Bins of IM'),
    )
    aggr_unit_def = models.IntegerField(
        'Definitions of aggregated units',
        choices=AGGR_UNIT_DEFS, null=True, blank=True)

    def clean(self):
        if self.building_aggr == self.BA_BUILDING_BY_BUILDING:
            self.building_aggr_min_num = None
        elif (self.building_aggr == self.BA_GROUPED
              and self.building_aggr_min_num is None):
            raise ValidationError(
                'You must specify the min number of grouped buildings')
        return True


# D1-a
class AnalysisType(models.Model):
    # Initial values
    #ANALYSIS_TYPES = (
        #(1, 'Nonlinear dynamic analysis (NLD)'),
        #(2, 'Nonlinear static analysis (NLS) with dispersion'),
        #(3, 'NLS without dispersion'),
        #(4, 'Collapse mechanism-based methods'),
        #(5, 'Simplified Displacement-based methods'),
        #(6, 'Other simplified methods'),
    #)
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# D1
class AnalyticalModelInfo(models.Model):
    class Meta:
        verbose_name = "Analytical modelling information"
        verbose_name_plural = "Analytical modelling information"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='Fragility function')
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='Vulnerability function')
    damage_to_loss_func = models.OneToOneField(
        'DamageToLossFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='Damage to loss function')
    capacity_curve_func = models.OneToOneField(
        'CapacityCurveFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='Capacity curve function')
    analysis_type = models.ForeignKey('AnalysisType')
    MODEL_TYPES = (
        (1, '3D'),
        (2, '2D element-by-element'),
        (3, '2D story-by-story'),
        (4, '1D'),
    )
    model_type = models.IntegerField(
        choices=MODEL_TYPES, null=True, blank=True)
    METHODS_UNCERT_PROPAG = (
        (1, 'Random Monte-Carlo or Latin Hypercube sampling'),
        (2, 'Set of index buildings'),
        (3, 'Single index building'),
    )
    method_uncert_propag = models.IntegerField(
        'Method of uncertainty propagation',
        choices=METHODS_UNCERT_PROPAG, null=True, blank=True)
    models_num = models.IntegerField(
        'Number of distinct structural models analysed',
        null=True, blank=True)


# C TODO: Remove?
class ModellingInformation(models.Model):
    #analytical_hybrid_modelling
    #empirical_modelling
    #statistical_information
    pass


# B
class Applicability(models.Model):
    pass


MOE_ANALYTICAL = 1
MOE_EMPIRICAL = 2
METHODS_OF_ESTIMATION = (
    (MOE_ANALYTICAL, 'Analytical'),
    (MOE_EMPIRICAL, 'Empirical'),
)


FDT_DISCRETE = 1
FDT_CONTINUOUS = 2
FUNC_DISTR_TYPES = (
    (FDT_DISCRETE, 'Discrete'),
    (FDT_CONTINUOUS, 'Continuous'),
)


DAMAGE_SCALES = (
    (1, 'MSK-76'),
    (2, 'EMS98'),
    (3, 'EMS92'),
    (4, 'HAZUS'),
    (5, 'ATC-13'),
    (6, 'Custom'),
)


RESP_VARS = (
    (1, 'Damage factor'),
    (2, 'Fatality rate per occupant'),
    (3, 'Nonfatal injury rate per occupant'),
    (4, 'Fatality rate per exposed population'),
    (5, 'Direct economic factor'),
)


# A1
class TaxonomyType(models.Model):
    # Initial values: GEM, PAGER, ATC58
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# Ax-a
class FuncDistrShape(models.Model):
    class Meta:
        verbose_name = "Function distribution shape"
    # Initial values: Lognormal, Beta, Gamma
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# A4-b
class CC_EngineeringDemandPar(models.Model):
    class Meta:
        verbose_name = "Engineering demand parameter"
    # Initial data
    #ENGINEERING_DEMAND_PARAMETERS = (
        #(1, 'Interstorey drift'),
        #(2, 'Global drift'),
        #(3, 'Residual drift'),
        #(4, 'Lateral roof displacement'),
        #(5, 'Chord rotation'),
        #(6, 'Curvature'),
        #(7, 'Shear strain'),
        #(8, 'Spectral displacement'),
    #)
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# A4-a
class CC_PredictorVar(models.Model):
    class Meta:
        verbose_name = "Capacity curve predictor variable"
    capacity_curve_func = models.OneToOneField(
        'CapacityCurveFunc', related_name='cc_predictor_var',
        verbose_name="Capacity curve function")
    engineering_demand_param = models.ForeignKey(
        'CC_EngineeringDemandPar',
        verbose_name='Engineering demand parameter')
    data_pts_num = models.IntegerField('Number of data points')
    pred_var_units = models.CharField(
        'Predictor variable units', max_length=16)
    pred_var_val = SemicolonSeparatedFloatField(
        'Predictor variable values', max_length=1024)


# B4
class CapacityCurveFunc(models.Model):
    class Meta:
        verbose_name = "Capacity curve function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='capacity_curve_func',
        verbose_name='General information')
    # One2One with AnalyticalModelInfo
    # One2One with CC_PredictorVar
    RESP_VAR_PAR = (
        (1, 'Base shear'),
        (2, 'Base bending moment'),
        (3, 'Spectral acceleration'),
    )
    resp_var_par = models.IntegerField(
        'Response variable parameter', choices=RESP_VAR_PAR)
    resp_var_units = models.CharField(
        'Response variable units', max_length=16)
    resp_var_val = SemicolonSeparatedFloatField(
        'Response variable values', max_length=1024)


# B3-a
class FuncDistrDTLDiscr(models.Model):
    class Meta:
        verbose_name = 'Discrete function distribution'
    damage_to_loss_func = models.OneToOneField(
        'DamageToLossFunc', related_name='func_distr_dtl_discr',
        verbose_name="Damage to loss function")
    var_mean_val = SemicolonSeparatedFloatField(
        'Mean values', max_length=1024)
    var_val_coeff = SemicolonSeparatedFloatField(
        'Coefficient of variation values', max_length=1024)
    func_distr_shape = models.ForeignKey(
        'FuncDistrShape', null=True,
        verbose_name='Function distribution shape')


# B3
class DamageToLossFunc(models.Model):
    class Meta:
        verbose_name = "Damage to loss function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='damage_to_loss_func',
        verbose_name='General information')
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # One2One with FuncDistrDTLDiscr
    # begin group 'Predictor variable (damage state)'
    damage_scale = models.IntegerField(choices=DAMAGE_SCALES, null=True)
    limit_states_num = models.IntegerField(
        'Number of limit states')
    limit_states_desc = SemicolonSeparatedStringField(
        'Description of limit states', max_length=1024)
    # end group 'Predictor variable (damage state)'
    resp_var = models.IntegerField(
        'Response variable', choices=RESP_VARS)
    # NOTE: currently discrete only
    func_distr_type = models.IntegerField(
        # FIXME Choices must be a tuple with min 2 elements
        #'Function distribution type', choices=((FDT_DISCRETE, 'Discrete')))
        'Function distribution type', choices=FUNC_DISTR_TYPES)

    def clean(self):
        # TODO Check number of items in limit_state_desc depending on
        # limit_state_num
        return True


# B2-b
class FuncDistrVulnCont(models.Model):
    class Meta:
        verbose_name = "Continuous function distribution"
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', related_name='func_distr_vuln_cont',
        verbose_name="Vulnerability function")
    discretization_data_pts_num = models.IntegerField(
        'Number of discretization data points', null=True)
    mean = models.FloatField()
    std_dev = models.FloatField('Standard deviation')
    func_distr_shape = models.ForeignKey(
        'FuncDistrShape', verbose_name="Function distribution shape")


# B2-a
class FuncDistrVulnDiscr(models.Model):
    class Meta:
        verbose_name = "Discrete function distribution"
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', related_name='func_distr_vuln_discr',
        verbose_name="Vulnerability function")
    data_pts_num = models.IntegerField('Number of data points')
    predictor_var_im_val = SemicolonSeparatedFloatField(
        'Predictor variable (IM) values', max_length=1024)
    resp_var_mean_val = SemicolonSeparatedFloatField(
        'Response variable: mean values', max_length=1024)
    resp_var_val_coeff = SemicolonSeparatedFloatField(
        'Response variable: coefficient of variation values', max_length=1024)


# used by FragilityFunc and VulnerabilityFunc
# A.2.2
class PredictorVar(models.Model):
    class Meta:
        verbose_name = "Predictor variable (IM)"
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='predictor_var',
        verbose_name="Vulnerability function")
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='predictor_var',
        verbose_name="Fragility function")
    INTENSITY_MEASURE_TYPES = (
        (1, 'PGA'),
        (2, 'PGV'),
        (3, 'PGD'),
        (4, 'Sa(T)'),
        (5, 'IA'),
        (6, 'CAV'),
        (7, 'RSD'),
        (8, 'MMI'),
    )
    intensity_measure_type = models.IntegerField(
        choices=INTENSITY_MEASURE_TYPES)
    INTENSITY_MEASURE_UNITS = (
        (1, 'Acceleration (g)'),
        (2, 'Acceleration (cm/s^2)'),
        (3, 'Acceleration (m/s^2)'),
        (4, 'Velocity (cm/s)'),
        (5, 'Velocity (m/s)'),
        (6, 'Displacement (cm)'),
        (7, 'Displacement (m)'),
        (8, 'Time (s)'),
        (9, 'CAV (g-s)'),
        (10, 'MMI roman numbers'),
    )
    intensity_measure_unit = models.IntegerField(
        choices=INTENSITY_MEASURE_UNITS)
    minimum_im = models.FloatField('Minimum IM')
    maximum_im = models.FloatField('Maximum IM')
    EVALUATIONS_OF_IM = (
        (1, 'GMPE'),
        (2, 'ShakeMap'),
        (3, 'Natural Accelerograms'),
        (4, 'Artificial Accelerograms'),
        (5, 'Spectrum-compatible Accelerograms'),
        (6, 'Spectrum (code-based)'),
        (7, 'Spectrum (GMPE-based)'),
        (8, 'Spectrum (other)'),
    )
    evaluation_of_im = models.IntegerField(
        'Evaluation of IM', choices=EVALUATIONS_OF_IM)


# B2
class VulnerabilityFunc(models.Model):
    class Meta:
        verbose_name = "Vulnerability function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='vulnerability_func',
        verbose_name='General information')
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # One2One with PredictorVar
    # One2One with FuncDistrVulnDiscr
    # One2One with FuncDistrVulnCont
    resp_var = models.IntegerField('Response variable', choices=RESP_VARS)
    func_distr_type = models.IntegerField(
        'Function distribution type',
        choices=FUNC_DISTR_TYPES)


# B1-c
class FuncDistrFragCont(models.Model):
    class Meta:
        verbose_name = "Continous function distribution"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='func_distr_frag_cont',
        verbose_name='Fragility function')
    mean = SemicolonSeparatedFloatField(max_length=1024)
    std_dev = SemicolonSeparatedFloatField(
        'Standard deviation', max_length=1024)
    func_distr_shape = models.ForeignKey(
        'FuncDistrShape',
        verbose_name='Function distribution shape')
    coeff_variation_mean = SemicolonSeparatedFloatField(
        'Coefficient of variation of the mean',
        max_length=1024, null=True, blank=True)
    coeff_variation_std_dev = SemicolonSeparatedFloatField(
        'Coefficient of variation of the standard deviation',
        max_length=1024, null=True, blank=True)
    predictor_var_corr_matrix = BidimensionalFloatField(
        'Predictor variable correlation matrix',
        null=True, blank=True)


# B1-b
class FuncDistrFragDiscr(models.Model):
    class Meta:
        verbose_name = "Discrete function distribution"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='func_distr_frag_discr',
        verbose_name='Fragility function')
    data_pts_num = models.IntegerField('Number of data points')
    predictor_var_im_val = SemicolonSeparatedFloatField(
        'Predictor variable (IM) values', max_length=1024)
    limit_state_prob_exceed = BidimensionalFloatField(
        'Probability of limit state exceedance')
    limit_state_prob_exceed_05 = BidimensionalFloatField(
        'Probability of limit state exceedance values '
        '(5% prediction interval)',
        null=True, blank=True)
    limit_state_prob_exceed_95 = BidimensionalFloatField(
        'Probability of limit state exceedance values '
        '(95% prediction interval)',
        null=True, blank=True)


# A1-a
class EngineeringDemandPar(models.Model):
    class Meta:
        verbose_name = "Engineering demand parameter"
    # Initial data
    #ENGINEERING_DEMAND_PARAMETERS = (
        #(1, 'Interstorey drift'),
        #(2, 'Global drift'),
        #(3, 'Residual drift'),
        #(4, 'Rotation capacity'),
        #(5, 'Shear capacity'),
        #(6, 'Strain levels'),
        #(7, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# B1
class FragilityFunc(models.Model):
    class Meta:
        verbose_name = "Fragility function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='fragility_func',
        verbose_name='General information')
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # One2One with PredictorVar
    # One2One with FuncDistrFragDiscr
    # One2One with FuncDistrFragCont
    # TODO Grouping 'Damage characterization'
    damage_scale = models.IntegerField(choices=DAMAGE_SCALES)
    engineering_demand_par = models.ForeignKey(
        'EngineeringDemandPar', null=True,
        verbose_name='Engineering demand parameter')
    limit_states_num = models.PositiveIntegerField(
        'Number of limit states')
    # They require a vector with free text
    # (e.g. ['Slight', 'Moderate', 'Collapse']
    limit_states_desc = SemicolonSeparatedStringField(
        'Description of limit states', max_length=1024)
    func_distr_type = models.IntegerField(
        'Function distribution type',
        choices=FUNC_DISTR_TYPES)


# A
class GeneralInformation(models.Model):
    # one2one with FragilityFunc
    # one2one with VulnerabilityFunc
    # one2one with DamageToLossFunc
    # one2one with CapacityCurveFunc
    # A.1 Reference ID code/name: choose integer(code)/string(name)
    name = models.CharField(max_length=CHMAX)
    CATEGORIES = (
        (1, 'Structure specific'),
        (2, 'Structure class'),
        (3, 'Nonstructural component'),
        (4, 'Population'),
        (5, 'Capital stock'),
    )
    category = models.IntegerField(choices=CATEGORIES)
    # For Structure specific and Structure class it's possible to select among
    # Buildings, Bridges and other types of structures
    # For Nonstructural component you can use ATC58 and other
    taxonomy_type = models.ForeignKey('TaxonomyType')
    taxonomy_text = models.CharField(max_length=1023)
    TA_FRAGILITY = 1
    TA_VULNERABILITY = 2
    TA_DAMAGE_TO_LOSS = 3
    TA_CAPACITY_CURVE = 4
    TYPES_OF_ASSESSMENT = (
        (TA_FRAGILITY, 'Fragility'),
        (TA_VULNERABILITY, 'Vulnerability'),
        (TA_DAMAGE_TO_LOSS, 'Damage-to-loss'),
        (TA_CAPACITY_CURVE, 'Capacity curve'),
    )
    type_of_assessment = models.IntegerField(choices=TYPES_OF_ASSESSMENT)
    # A.3 Reference / documentation
    # TODO: Capire come raggruppare come nell'inline
    authors = models.CharField(max_length=CHMAX)
    article_title = models.CharField(max_length=CHMAX)
    publication_conference_name = models.CharField(
        max_length=CHMAX)
    year = models.IntegerField()
    web_link = models.URLField(null=True, blank=True, max_length=255)
    use_case_information = models.CharField(
        max_length=CHMAX, null=True, blank=True)
    general_comments = models.CharField(
        max_length=CHMAX, null=True, blank=True)

    #def clean(self):
        #if self.type_of_assessment == self.TA_FRAGILITY:
            #if self.fragility is None:
                #raise ValidationError(
                    #'The fragility function must be filled')
            #if any([self.vulnerability,
                    #self.damage_to_loss,
                    #self.capacity_curve]):
                #raise ValidationError(
                    #'Only the fragility function can be filled')
        #if self.type_of_assessment == self.TA_VULNERABILITY:
            #if self.vulnerability is None:
                #raise ValidationError(
                    #'The vulnerability function must be filled')
            #if any([self.fragility,
                    #self.damage_to_loss,
                    #self.capacity_curve]):
                #raise ValidationError(
                    #'Only the vulnerability function can be filled')
        #if self.type_of_assessment == self.TA_DAMAGE_TO_LOSS:
            #if self.damage_to_loss is None:
                #raise ValidationError(
                    #'The damage-to-loss function must be filled')
            #if any([self.fragility,
                    #self.vulnerability,
                    #self.capacity_curve]):
                #raise ValidationError(
                    #'Only the damage-to-loss function can be filled')
        #if self.type_of_assessment == self.TA_CAPACITY_CURVE:
            #if self.vulnerability is None:
                #raise ValidationError(
                    #'The capacity curve function must be filled')
            #if any([self.fragility,
                    #self.damage_to_loss,
                    #self.vulnerability]):
                #raise ValidationError(
                    #'Only the capacity curve function can be filled')
        #return True
