# Copyright (c) 2012-2015, GEM Foundation.
#
# This program is free software: you can redistribute it and/or modify
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#import re
from datetime import datetime
from django.contrib.gis.db import models
# from django.db import models
from django.core.exceptions import ValidationError
from django_extras.contrib.auth.models import SingleOwnerMixin
from commons import (SemicolonSeparatedFloatFormField,
                     #SemicolonSeparatedFloatRomanFormField,
                     SemicolonSeparatedStringFormField,
                     BidimensionalFloatFormField, )
#from django.core import validators
#from django.core.validators import RegexValidator
from django.contrib.auth.models import User
from django.forms.fields import MultiValueField, BooleanField, CharField
from django.core.validators import MinValueValidator, MaxValueValidator
from openquakeplatform.models import UnaccentCharField
from openquakeplatform.vulnerability.widgets import TaxonomyInput


class TaxonomyInputField(MultiValueField):
    widget = TaxonomyInput

    def __init__(self, max_length=31, attrs={}, *args, **kwargs):
        self.my_attrs = attrs
        list_fields = [BooleanField(),
                       CharField(max_length=max_length)]
        super(TaxonomyInputField, self).__init__(list_fields, *args, **kwargs)

    def compress(self, values):
        if values[0] == False and values[1] == "":
            return "__InvaliDValuE__"

        return values[1]


class SemicolonSeparatedFloatField(models.CharField):
    description = "Semicolon-separated floats"

    __metaclass__ = models.SubfieldBase

    def formfield(self, form_class=SemicolonSeparatedFloatFormField, **kwargs):
        help_text = 'Enter semicolon-separated floats (e.g. 4.5;3;2.2)'
        if self.help_text:
            help_text += '. ' + self.help_text
        defaults = {
            "label": self.verbose_name,
            # NOTE: we decided to check with respect to self.null instead of
            # using self.blank, because it seems to be more logically correct
            "required": not self.null,
            "help_text": help_text}
        defaults.update(kwargs)
        return form_class(**defaults)


#class SemicolonSeparatedFloatRomanField(models.CharField):
    #description = "Semicolon-separated floats or roman numerals"

    #__metaclass__ = models.SubfieldBase

    #def formfield(self,
                  #form_class=SemicolonSeparatedFloatRomanFormField,
                  #**kwargs):
        #defaults = {
            #"help_text": ("Enter semicolon-separated floats or roman numerals"
                          #" (e.g. 4.5;3;2.2 or IV;II;VII)")
        #}
        #defaults.update(kwargs)
        #return form_class(**defaults)


class SemicolonSeparatedStringField(models.CharField):
    description = "Semicolon-separated strings"

    __metaclass__ = models.SubfieldBase

    def formfield(self,
                  form_class=SemicolonSeparatedStringFormField, **kwargs):
        help_text = ('Enter semicolon-separated strings '
                     '(e.g. first;second;third)')
        if self.help_text:
            help_text += '. ' + self.help_text
        defaults = {
            "label": self.verbose_name,
            # NOTE: we decided to check with respect to self.null instead of
            # using self.blank, because it seems to be more logically correct
            "required": not self.null,
            "help_text": help_text}
        defaults.update(kwargs)
        return form_class(**defaults)


class BidimensionalFloatField(models.TextField):
    description = "Matrix containing rows of semicolon-separated floats"

    __metaclass__ = models.SubfieldBase

    def formfield(self, form_class=BidimensionalFloatFormField, **kwargs):
        help_text = ('Enter rows of semicolon-separated floats '
                     '(e.g. 4.5;3;2.2 <Enter> 3.1;1;4 <Enter> '
                     '6.2;5.3;1.1)')
        if self.help_text:
            help_text += '. ' + self.help_text
        defaults = {
            "label": self.verbose_name,
            # NOTE: we decided to check with respect to self.null instead of
            # using self.blank, because it seems to be more logically correct
            "required": not self.null,
            "help_text": help_text}
        defaults.update(kwargs)
        return form_class(**defaults)


CHMAX = 200
TFMAX = 1023

QRS_VALUES = (
    (1, 'Superior'),
    (2, 'Average'),
    (3, 'Marginal'),
    (4, 'NA'),
)


# E2
class QRSEmpirical(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "Q.R.S. for empirical function/curve"
        verbose_name_plural = ("Q.R.S. for empirical "
                               "functions/curves")
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='qrs_empirical',
        verbose_name="fragility function")
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='qrs_empirical',
        verbose_name="vulnerability function")
    # Group: Data quality
    data_quantity = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    constrained_categories = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    excitation_observation = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    damage_loss_observation = models.IntegerField(
        'Damage/loss observation', choices=QRS_VALUES, null=True, blank=True)
    # end group
    # Group: Rationality
    hindcasting = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    cross_validation = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    first_principles = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    uncertainties_treatment = models.IntegerField(
        'Treatment of uncertainties', choices=QRS_VALUES,
        null=True, blank=True)
    # end group
    documentation_quality = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    documentation_type = models.IntegerField(
        'Type of documentation', choices=QRS_VALUES, null=True, blank=True)
    representativeness = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)


# E1
class QRSAnalytical(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "Q.R.S. for analytical function/curve"
        verbose_name_plural = ("Q.R.S for analytical "
                               "functions/curves")
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='qrs_analytical',
        verbose_name="fragility function")
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='qrs_analytical',
        verbose_name="vulnerability function")
    # Group: Data quality
    structural_details = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    model_completeness = models.IntegerField(
        'Completeness of model', choices=QRS_VALUES, null=True, blank=True)
    seismic_demand = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    # end group
    # Group: Rationality
    analysis_type = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    limit_states_def = models.IntegerField(
        'Definition of Limit States', choices=QRS_VALUES,
        null=True, blank=True)
    sampling_method = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    cross_validation = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    uncertainties_treatment = models.IntegerField(
        'Treatment of uncertainties', choices=QRS_VALUES,
        null=True, blank=True)
    # end group
    # Group: Documentation quality
    documentation_quality = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    documentation_type = models.IntegerField(
        'Type of documentation', choices=QRS_VALUES, null=True, blank=True)
    # end group
    # Group: Representativeness
    typology_repr = models.IntegerField(
        'Representation of typology', choices=QRS_VALUES,
        null=True, blank=True)
    site_specific = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    hazard_model = models.IntegerField(
        choices=QRS_VALUES, null=True, blank=True)
    # end group


# D4-e
class StatModel(SingleOwnerMixin, models.Model):
    # Initial values
    #STATISTICAL_MODELS = (
        #(1, 'Generalised Linear Models'),
        #(2, 'Generalised Additive Models'),
        #(3, 'Kernel smoothing'),
        #(4, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D4-d
class StatModelFittingMethod(SingleOwnerMixin, models.Model):
    # Initial values
    #STAT_MODEL_FITTING_METHODS = (
        #(1, 'Least squares'),
        #(2, 'Maximum likelyhood'),
        #(3, 'Robust maximum likelyhood'),
        #(4, 'Bayesian'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D4-c
class ModelFittingMethodAssumption(SingleOwnerMixin, models.Model):
    # Initial values
    #MODEL_FITTING_METHOD_ASSUMPTIONS = (
        #(1, 'Independence of observations'),
        #(2, 'Measurement error in IM'),
        #(3, 'Measurement error in response'),
        #(4, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D4-b
class FitAssessmentGoodness(SingleOwnerMixin, models.Model):
    # Initial values
    #FIT_ASSESSMENT_GOODNESS_OPTIONS = (
        #(1, 'Acceptable mean function'),
        #(2, 'Acceptable variance function'),
        #(3, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D4-a
class ProcConstrInt(SingleOwnerMixin, models.Model):
    # Initial values
    #PROC_CONSTR_INT_CHOICES = (
        #(1, 'Asymptotic'),
        #(2, 'Bootstrap'),
        #(3, 'Bayesian'),
        #(4, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D4
class StatisticalInformation(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name_plural = "statistical information"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True, blank=True,
        related_name='stat_info',
        verbose_name='fragility function')
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True, blank=True,
        related_name='stat_info',
        verbose_name='vulnerability function')
    stat_model = models.ForeignKey(
        'StatModel', null=True, blank=True,
        verbose_name='statistical model')
    stat_model_fitting_method = models.ForeignKey(
        'StatModelFittingMethod', null=True, blank=True,
        verbose_name='statistical model fitting method')
    model_fitting_method_assumptions = models.ForeignKey(
        'ModelFittingMethodAssumption', null=True, blank=True)
    fit_assessment_goodness = models.ForeignKey(
        'FitAssessmentGoodness', null=True, blank=True,
        verbose_name='goodness of fit assessment (G.L.M./G.A.M.)')
    proc_constr_conf_int = models.ForeignKey(
        'ProcConstrInt', null=True, blank=True,
        verbose_name='proc. for constructing conf. intervals',
        related_name='stat_info_conf')
    proc_constr_pred_int = models.ForeignKey(
        'ProcConstrInt', null=True, blank=True,
        verbose_name='proc. for constructing pred. intervals',
        related_name='stat_info_pref')


# D2
class EmpiricalModelInfo(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "empirical modelling information"
        verbose_name_plural = "empirical modelling information"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='empirical_model_info',
        verbose_name="fragility function")
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='empirical_model_info',
        verbose_name="vulnerability function")
    structural_unit = models.IntegerField(null=True, blank=True, choices=(
        (1, 'Dwelling'), (2, 'Building')))
    building_x_class_num = models.IntegerField(
        'Number of buildings per class', null=True, blank=True)
    empirical_data_src = models.CharField(
        'Source of empirical data', max_length=CHMAX, null=True, blank=True)
    BA_BUILDING_BY_BUILDING = 1
    BA_GROUPED = 2
    building_aggr = models.IntegerField(
        'Building aggregation', null=True, blank=True,
        choices=((BA_BUILDING_BY_BUILDING, 'Building-by-building'),
                 (BA_GROUPED, 'Grouped')))
    building_aggr_min_num = models.IntegerField(
        'Minimum number of grouped buildings', null=True, blank=True,
        help_text='Mandatory if "Building aggregation" is "Grouped"')
    AGGR_UNIT_DEFS = (
        (1, 'GADM admin 2 region'),
        (2, 'GADM admin 3 region'),
        (3, 'Other admin region'),
        (4, 'Bins of IM'),
    )
    aggr_unit_def = models.IntegerField(
        'Definitions of aggregated units',
        choices=AGGR_UNIT_DEFS, null=True, blank=True)
    evaluation_of_im = models.ForeignKey(
        'EvaluationOfIM', null=True, blank=True,
        verbose_name='evaluation of I.M.')

    def clean(self):
        if self.building_aggr == self.BA_BUILDING_BY_BUILDING:
            self.building_aggr_min_num = None
        elif (self.building_aggr == self.BA_GROUPED
              and self.building_aggr_min_num is None):
            raise ValidationError(
                'You must specify the min number of grouped buildings')
        return True


class AMT(object):
    _3D = 1
    _2D_EL_BY_EL = 2
    _2D_ST_BY_ST = 3
    _1D = 4


ANALYTICAL_MODEL_TYPES = (
    (AMT._3D, '3D'),
    (AMT._2D_EL_BY_EL, '2D element-by-element'),
    (AMT._2D_ST_BY_ST, '2D story-by-story'),
    (AMT._1D, '1D'),
)


# D1-a
class AnalysisType(SingleOwnerMixin, models.Model):
    # Initial values
    #ANALYSIS_TYPES = (
        #(1, 'Nonlinear dynamic analysis (NLD)'),
        #(2, 'Nonlinear static analysis (NLS) with dispersion'),
        #(3, 'NLS without dispersion'),
        #(4, 'Collapse mechanism-based methods'),
        #(5, 'Simplified Displacement-based methods'),
        #(6, 'Other simplified methods'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D1
class AnalyticalModelInfo(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "analytical modelling information"
        verbose_name_plural = "analytical modelling information"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='fragility function')
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='vulnerability function')
    analysis_type = models.ForeignKey('AnalysisType', null=True, blank=True)
    model_type = models.IntegerField(
        choices=ANALYTICAL_MODEL_TYPES, null=True, blank=True)
    METHODS_UNCERT_PROPAG = (
        (1, 'Random Monte-Carlo or Latin Hypercube sampling'),
        (2, 'Set of index buildings'),
        (3, 'Single index building'),
    )
    method_uncert_propag = models.IntegerField(
        'Method of uncertainty propagation',
        choices=METHODS_UNCERT_PROPAG, null=True, blank=True)
    models_num = models.IntegerField(
        'Number of distinct structural models analysed',
        null=True, blank=True)
    evaluation_of_im = models.ForeignKey(
        'EvaluationOfIM', null=True, blank=True,
        verbose_name='evaluation of I.M.')


# D3-a
class CC_AnalysisType(SingleOwnerMixin, models.Model):
    # Initial values
    #ANALYSIS_TYPES = (
        #(1, 'Nonlinear static analysis (NLS) with dispersion'),
        #(2, 'NLS without dispersion'),
        #(3, 'Collapse mechanism-based methods'),
        #(4, 'Simplified Displacement-based methods'),
        #(5, 'Other simplified methods'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# D3
class CC_AnalyticalModelInfo(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "analytical modelling information"
        verbose_name_plural = "analytical modelling information"
    capacity_curve_func = models.OneToOneField(
        'CapacityCurveFunc',
        related_name='cc_analytical_model_info',
        verbose_name='capacity curve function')
    analysis_type = models.ForeignKey('CC_AnalysisType', null=True, blank=True)
    model_type = models.IntegerField(
        choices=ANALYTICAL_MODEL_TYPES, null=True, blank=True)
    models_num = models.IntegerField(
        'Number of distinct structural models analysed',
        null=True, blank=True)
    struct_fund_period = models.FloatField(
        'Fundamental period of the structure (s)', blank=True, null=True)
    modal_part_fact = models.FloatField(
        'Modal partecipation factor', blank=True, null=True)


REGIONS = (
    ('', '--------'),
    (1, 'Worldwide'),
    (2, 'Africa'),
    (3, 'North America'),
    (4, 'Central America & Caribbean'),
    (5, 'South America'),
    (6, 'Asia'),
    (7, 'Europe'),
    (8, 'Oceania'),
    (9, 'Antarctica'),
)


class Country(models.Model):
    class Meta:
        verbose_name_plural = "countries"

    name = models.CharField(max_length=CHMAX)
    region = models.IntegerField(choices=REGIONS)
    iso3 = models.CharField(max_length=3, primary_key=True)
    the_geom = models.GeometryField(srid=4326, dim=2, null=True, blank=True)
    is_visible = models.BooleanField(default=True)

    def __unicode__(self):
        return '%s (%s)' % (self.name, self.iso3)


# B
class GeoApplicability(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "geographical applicability"
        verbose_name_plural = "geographical applicability"

    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='geo_applicability',
        verbose_name='general information')
    countries = models.ManyToManyField(Country)
    # administrative_region =
    area = models.CharField(max_length=CHMAX, blank=True, null=True)
    # Unique location
    lat = models.FloatField(blank=True, null=True)
    lon = models.FloatField(blank=True, null=True)
    address = models.TextField(blank=True, null=True)


class MOE(object):
    ANALYTICAL = 1
    EMPIRICAL = 2
    EXPERT_OPINION = 3


METHODS_OF_ESTIMATION = (
    (MOE.ANALYTICAL, 'Analytical'),
    (MOE.EMPIRICAL, 'Empirical'),
    (MOE.EXPERT_OPINION, 'Expert Opinion'),
)

CC_METHODS_OF_ESTIMATION = (
    (MOE.ANALYTICAL, 'Analytical'),
    (MOE.EMPIRICAL, 'Empirical'),
)


class FDT(object):
    DISCRETE = 1
    CONTINUOUS = 2


FUNC_DISTR_TYPES = (
    (FDT.DISCRETE, 'Discrete'),
    (FDT.CONTINUOUS, 'Continuous'),
)


DAMAGE_SCALES = (
    (1, 'MSK-76'),
    (2, 'EMS-98'),
    (3, 'EMS-92'),
    (4, 'HAZUS'),
    (5, 'ATC-13'),
    (6, 'Custom'),
)


class RV(object):
    DF = 1
    FRPO = 2
    NFIRPO = 3
    FRPEP = 4
    DEF = 5

RESP_VARS = (
    (RV.DF, 'Damage factor'),
    (RV.FRPO, 'Fatality rate per occupant'),
    (RV.NFIRPO, 'Nonfatal injury rate per occupant'),
    (RV.FRPEP, 'Fatality rate per exposed population'),
    (RV.DEF, 'Direct economic factor'),
)


class RVP(object):
    BASE_SHEAR = 1
    BASE_BENDING_MOMENT = 2
    SPECTRAL_ACCELERATION = 3
    BASE_SHEAR_COEF = 4

RESP_VAR_PAR = (
    (str(RVP.BASE_SHEAR), 'Base shear'),
    (str(RVP.BASE_BENDING_MOMENT), 'Base bending moment'),
    (str(RVP.SPECTRAL_ACCELERATION), 'Spectral acceleration'),
    (str(RVP.BASE_SHEAR_COEF), 'Base shear coefficient (V/W)'),
)


class RVU(object):
    KN = 1
    KNM = 2
    G = 3
    CMS2 = 4
    MS2 = 5
    NO_DIM = 6

RESP_VAR_UNITS = (
    (str(RVU.KN), 'kN'),
    (str(RVU.KNM), 'kN.m'),
    (str(RVU.G), 'g'),
    (str(RVU.CMS2), 'cm/s^2'),
    (str(RVU.MS2), 'm/s^2'),
    (str(RVU.NO_DIM), 'Dimensionless'), )


class TA(object):
    FRAGILITY = 1
    VULNERABILITY = 2
    DAMAGE_TO_LOSS = 3
    CAPACITY_CURVE = 4

TYPES_OF_ASSESSMENT = (
    (TA.FRAGILITY, 'Fragility'),
    (TA.VULNERABILITY, 'Vulnerability'),
    (TA.DAMAGE_TO_LOSS, 'Damage-to-loss'),
    (TA.CAPACITY_CURVE, 'Capacity curve'),
)


class IMT(object):
    PGA = 1
    PGV = 2
    PGD = 3
    SAT = 4
    SDT = 5
    IA = 6
    CAV = 7
    RSD = 8
    MMI = 9

INTENSITY_MEASURE_TYPES = (
    ('', '--------'),
    (str(IMT.PGA), 'PGA'),
    (str(IMT.PGV), 'PGV'),
    (str(IMT.PGD), 'PGD'),
    (str(IMT.SAT), 'Sa(T)'),
    (str(IMT.SDT), 'Sd(T)'),
    (str(IMT.IA), 'IA'),
    (str(IMT.CAV), 'CAV'),
    (str(IMT.RSD), 'RSD'),
    (str(IMT.MMI), 'MMI'),
)


class IMU(object):
    G = 1
    CM_S2 = 2
    M_S2 = 3
    CM_S = 4
    M_S = 5
    CM = 6
    M = 7
    S = 8
    GS = 9
    ROMAN = 10


INTENSITY_MEASURE_UNITS = (
    (str(IMU.G), 'g'),
    (str(IMU.CM_S2), 'cm/s^2'),
    (str(IMU.M_S2), 'm/s^2'),
    (str(IMU.CM_S), 'cm/s'),
    (str(IMU.M_S), 'm/s'),
    (str(IMU.CM), 'cm'),
    (str(IMU.M), 'm'),
    (str(IMU.S), 's'),
    (str(IMU.GS), 'g-s'),
    (str(IMU.ROMAN), 'Roman numbers'),
)


class EDP(object):
    INTERSTOREY_DRIFT = 1
    GLOBAL_DRIFT = 2
    LATERAL_ROOF_DISPLACEMENT = 3
    CHORD_ROTATION = 4
    CURVATURE = 5
    SPECTRAL_DISPLACEMENT = 6

CC_ENGINEERING_DEMAND_PARAMETERS = (
    ('', '--------'),
    (str(EDP.INTERSTOREY_DRIFT), 'Interstorey drift'),
    (str(EDP.GLOBAL_DRIFT), 'Global drift'),
    (str(EDP.LATERAL_ROOF_DISPLACEMENT), 'Lateral roof displacement'),
    (str(EDP.CHORD_ROTATION), 'Chord rotation'),
    (str(EDP.CURVATURE), 'Curvature'),
    (str(EDP.SPECTRAL_DISPLACEMENT), 'Spectral displacement'),
)


class EDU(object):
    PURE = 1
    CM = 2
    M = 3
    RAD = 4
    RAD_KM = 5
    RAD_M = 6


class PVU(object):
    DIMLESS = 1
    CM = 2
    M = 3
    RAD = 4
    RADKM = 5
    RADM = 6

PRED_VAR_UNITS = (
    (str(PVU.DIMLESS), 'Dimensionless'),
    (str(PVU.CM), 'cm'),
    (str(PVU.M), 'm'),
    (str(PVU.RAD), 'rad'),
    (str(PVU.RADKM), 'rad/km'),
    (str(PVU.RADM), 'rad/m'),
)


class FDS(object):
    LOGNORMAL = 1
    BETA = 2


FUNC_DISTR_SHAPES_ALL = (
    (FDS.LOGNORMAL, 'Lognormal'),
    (FDS.BETA,      'Beta'),
)

FUNC_DISTR_SHAPES_LN = (
    (FDS.LOGNORMAL, 'Lognormal'),
)


# A1
class TaxonomyType(SingleOwnerMixin, models.Model):
    # Initial values: GEM, PAGER, ATC58
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# A4-a
class CC_PredictorVar(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "capacity curve predictor variable"
    capacity_curve_func = models.OneToOneField(
        'CapacityCurveFunc', related_name='cc_predictor_var',
        verbose_name="capacity curve function")
    engineering_demand_par = models.CharField(
        'Engineering demand parameter',
        max_length=CHMAX,
        choices=CC_ENGINEERING_DEMAND_PARAMETERS)
    data_pts_num = models.IntegerField(
        'Number of data points')
    # Validation:
    # if engineering_demand_par
    # in (Interstorey drift, Global drift):
    #     ==> Dimensionless
    # in (Lateral roof displacement, Spectral displacement):
    #     ==> {cm, m}
    # in (Chord rotation, )
    #     ==> Radians
    # in (Curvature, )
    #     ==> {rad/km, rad/m}
    pred_var_units = models.CharField(
        'Predictor variable units',
        max_length=CHMAX,
        choices=PRED_VAR_UNITS)
    #pred_var_units = models.IntegerField()
    #pred_var_units = models.CharField(
        #'Predictor variable units', max_length=16)
    pred_var_val = SemicolonSeparatedFloatField(
        'Predictor variable values', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of data points.'))
    # Validation:
    # if cc_predictor_var.engineering_demand_par
    # in (Interstorey drift, Global drift, Lateral roof displacement):
    #     resp_var_par = Base shear
    # in (Chord rotation, Curvature)
    #     resp_var_par = Base bending moment
    # in (Spectral displacement)
    #     resp_var_par = Spectral acceleration
    resp_var_par = models.CharField(
        'Response variable parameter',
        max_length=CHMAX,
        choices=RESP_VAR_PAR)
    # Validation:
    # if resp_var_par == Base shear ==> kN
    #                 == Base bending moment ==> kN.m
    #                 == Spectral acceleration ==> {g, cm/s^2, m/s^2}
    resp_var_units = models.CharField(
        'Response variable units',
        max_length=CHMAX,
        choices=RESP_VAR_UNITS)
    resp_var_val = SemicolonSeparatedFloatField(
        'Response variable values', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of data points.'))

    def clean(self):
        if len(self.pred_var_val.split(';')) != self.data_pts_num:
            raise ValidationError('The number of data points and the number '
                                  'of predictor variable values must '
                                  'be consistent')
        if len(self.resp_var_val.split(';')) != self.data_pts_num:
            raise ValidationError('The number of data points and the number '
                                  'of response variable values must '
                                  'be consistent')


# B4
class CapacityCurveFunc(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "capacity curve function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='capacity_curve_func',
        verbose_name='general information')
    # One2One with CC_AnalyticalModelInfo
    # One2One with CC_PredictorVar
    method_of_estimation = models.IntegerField(
        choices=CC_METHODS_OF_ESTIMATION)


# B3-a
class FuncDistrDTLDiscr(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = 'discrete function distribution'
    damage_to_loss_func = models.OneToOneField(
        'DamageToLossFunc', related_name='func_distr_dtl_discr',
        verbose_name="damage to loss function")
    var_mean_val = SemicolonSeparatedFloatField(
        'Mean values', max_length=1024)
    var_val_coeff = SemicolonSeparatedFloatField(
        'Coefficient of variation values', max_length=1024,
        null=True, blank=True)
    func_distr_shape = models.IntegerField(
        choices=FUNC_DISTR_SHAPES_ALL,
        null=True, blank=True,
        # FIXME:  at this moment use default force to try
        #         to save hidden field set with errors
        # default=FDS.LOGNORMAL,
        verbose_name='function distribution shape',
        help_text=('Mandatory field if coefficient of variation '
                   'values are specified'))

    def clean(self):
        if not self.damage_to_loss_func.limit_states_num:
            raise ValidationError('Please specify the limit states')
        if (len(self.var_mean_val.split(';')) !=
                self.damage_to_loss_func.limit_states_num):
            raise ValidationError('The number of limit states and the number '
                                  'of mean values must '
                                  'be consistent')
        if self.var_val_coeff:
            if (len(self.var_val_coeff.split(';')) !=
                    self.damage_to_loss_func.limit_states_num):
                raise ValidationError(
                    'The number of limit states and the number '
                    'of coefficient of variation values must '
                    'be consistent')
            if not self.func_distr_shape:
                raise ValidationError('Please specify the function '
                                      'distribution shape')


# B3
class DamageToLossFunc(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "damage to loss function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='damage_to_loss_func',
        verbose_name='general information')
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with FuncDistrDTLDiscr
    # begin group 'Predictor variable (damage state)'
    damage_scale = models.IntegerField(
        choices=DAMAGE_SCALES, null=True, blank=True)
    limit_states_desc = SemicolonSeparatedStringField(
        'Description of limit states', max_length=1024,
        help_text='Select damage scale to automatically populate this field')
    # end group 'Predictor variable (damage state)'
    resp_var = models.IntegerField(
        'Response variable', choices=RESP_VARS)

    @property
    def limit_states_num(self):
        return len(self.limit_states_desc.split(';'))


# B2-b
class FuncDistrVulnCont(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "continuous function distribution"
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', related_name='func_distr_vuln_cont',
        verbose_name="vulnerability function")
    discretization_data_pts_num = models.IntegerField(
        'Number of discretization data points', null=True, blank=True)
    mean = models.FloatField()
    std_dev = models.FloatField('Standard deviation')
    func_distr_shape = models.IntegerField(
        choices=FUNC_DISTR_SHAPES_LN,
        verbose_name='function distribution shape')
    mean_var_coef = models.FloatField(
        'Coefficient of variation of the mean', null=True, blank=True)
    sd_var_coef = models.FloatField(
        'Coefficient of variation of the standard deviation',
        null=True, blank=True)

    def clean(self):
        if (self.discretization_data_pts_num
                and self.discretization_data_pts_num <= 1):
            raise ValidationError(
                'The number of discretization points, if defined,'
                ' must be greater than 1')


# B2-a
class FuncDistrVulnDiscr(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "discrete function distribution"
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', related_name='func_distr_vuln_discr',
        verbose_name="vulnerability function")
    data_pts_num = models.IntegerField('Number of data points')
    #predictor_var_im_val = SemicolonSeparatedFloatRomanField(
    predictor_var_im_val = SemicolonSeparatedFloatField(
        'Predictor variable (IM) values', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of data points.'))
    resp_var_mean_val = SemicolonSeparatedFloatField(
        'Response variable: mean values', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of data points.'))
    resp_var_val_coeff = SemicolonSeparatedFloatField(
        'Response variable: coefficient of variation values', max_length=1024,
        null=True, blank=True,
        help_text=('The number of values must be '
                   'consistent with the number of data points.'))
    func_distr_shape = models.IntegerField(
        choices=FUNC_DISTR_SHAPES_ALL,
        null=True, blank=True,
        # FIXME:  at this moment use default force to try
        #         to save hidden field set with errors
        # default=FDS.LOGNORMAL,
        verbose_name='function distribution shape',
        help_text=('Mandatory field if coefficient of variation '
                   'values are specified'))

    def clean(self):
        if len(self.predictor_var_im_val.split(';')) != self.data_pts_num:
            raise ValidationError('The number of data points and the number '
                                  'of predictor variable (IM) values must '
                                  'be consistent')
        if len(self.resp_var_mean_val.split(';')) != self.data_pts_num:
            raise ValidationError(
                'The number of data points and the number of "Response '
                'variable: mean values" must be consistent')
        if self.resp_var_val_coeff:
            if len(self.resp_var_val_coeff.split(';')) != self.data_pts_num:
                raise ValidationError(
                    'The number of data points and the number of "Response '
                    'variable: coefficient of variation values" must be '
                    'consistent')
            if not self.func_distr_shape:
                raise ValidationError('Please specify the function '
                                      'distribution shape')


# A2.2.2.1
class EvaluationOfIM(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "evaluation of I.M."
        verbose_name_plural = "evaluations of I.M."
    # Initial values:
    #EVALUATIONS_OF_IM = (
        #(1, 'GMPE'),
        #(2, 'ShakeMap'),
        #(3, 'Natural Accelerograms'),
        #(4, 'Artificial Accelerograms'),
        #(5, 'Spectrum-compatible Accelerograms'),
        #(6, 'Spectrum (code-based)'),
        #(7, 'Spectrum (GMPE-based)'),
        #(8, 'Spectrum (other)'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# used by FragilityFunc and VulnerabilityFunc
# A.2.2
class PredictorVar(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = 'predictor variable (I.M.)'
        verbose_name_plural = 'predictor variables (I.M.)'
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='predictor_var',
        verbose_name="vulnerability function")
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='predictor_var',
        verbose_name="fragility function")
    intensity_measure_type = models.CharField(
        max_length=CHMAX, choices=INTENSITY_MEASURE_TYPES)
    intensity_measure_unit = models.CharField(
        max_length=CHMAX, choices=INTENSITY_MEASURE_UNITS,
        help_text='Please select intensity measure type first')
    TYPES_OF_PERIOD = (
        (1, 'Telastic (s)'),
        (2, 'Tyielding (s)'),
        (3, 'Tinelastic (s)'),
    )
    type_of_period = models.IntegerField(
        choices=TYPES_OF_PERIOD, null=True, blank=True,
        help_text='Mandatory if the "Intensity measure type" is '
                  'Sa(T) or Sd(T). Please leave this field empty otherwise.')
    period = models.FloatField(
        'Period (s)', null=True, blank=True,
        help_text='Mandatory if the "Intensity measure type" is '
                  'Sa(T) or Sd(T). Please leave this field empty otherwise.')
    minimum_im = models.FloatField('Minimum IM')
    maximum_im = models.FloatField('Maximum IM')

    def clean(self):
        if self.intensity_measure_type:
            if int(self.intensity_measure_type) in (IMT.SAT, IMT.SDT):
                if not self.type_of_period or not self.period:
                    raise ValidationError(
                        'For this intensity measure type you '
                        'must specify both the type of period '
                        'and the period')
            elif self.type_of_period or self.period:
                raise ValidationError(
                    'For this intensity measure type, the type of period '
                    'and the period must be blank')


# B2
class VulnerabilityFunc(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "vulnerability function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='vulnerability_func',
        verbose_name='general information')
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # One2One with StatisticalInformation
    # One2One with PredictorVar
    # One2One with FuncDistrVulnDiscr
    # One2One with FuncDistrVulnCont
    # One2One with QRSEmpirical
    # One2One with QRSAnalytical
    resp_var = models.IntegerField('Response variable', choices=RESP_VARS)
    func_distr_type = models.IntegerField(
        'Function distribution type',
        choices=FUNC_DISTR_TYPES)


# B1-c
class FuncDistrFragCont(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "continous function distribution"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='func_distr_frag_cont',
        verbose_name='fragility function')
    mean = SemicolonSeparatedFloatField(
        'Mean', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of limit states.'))
    std_dev = SemicolonSeparatedFloatField(
        'Standard deviation', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of limit states.'))
    func_distr_shape = models.IntegerField(
        choices=FUNC_DISTR_SHAPES_LN,
        verbose_name='function distribution shape')
    coeff_variation_mean = SemicolonSeparatedFloatField(
        'Coefficient of variation of the mean',
        max_length=1024, null=True, blank=True,
        help_text=('The number of values must be '
                   'consistent with the number of limit states.'))
    coeff_variation_std_dev = SemicolonSeparatedFloatField(
        'Coefficient of variation of the standard deviation',
        max_length=1024, null=True, blank=True,
        help_text=('The number of values must be '
                   'consistent with the number of limit states.'))
    predictor_var_corr_matrix = BidimensionalFloatField(
        'Predictor variable correlation matrix',
        null=True, blank=True, max_length=10240,
        help_text=('The number of both rows and columns '
                   'must be twice the number of limit states.'))

    def clean(self):
        if not self.fragility_func.limit_states_num:
            raise ValidationError('Please specify the limit states')
        else:
            limit_states_num = self.fragility_func.limit_states_num
            if (self.mean and
                    len(self.mean.split(';')) != limit_states_num):
                raise ValidationError(
                    'The number of items of "Mean" must be consistent with '
                    'the number of limit states (i.e. %d)' % limit_states_num)
            if (self.std_dev and
                    len(self.std_dev.split(';')) != limit_states_num):
                raise ValidationError(
                    'The number of items of "Standard deviation" must '
                    'be consistent with '
                    'the number of limit states (i.e. %d)' % limit_states_num)
            if (self.coeff_variation_mean and
                    len(self.coeff_variation_mean.split(';')) !=
                    limit_states_num):
                raise ValidationError(
                    'The number of items of "Coefficient of variation of '
                    'the mean" must be consistent with '
                    'the number of limit states (i.e. %d)' % limit_states_num)
            if (self.coeff_variation_std_dev and
                    len(self.coeff_variation_std_dev.split(';')) !=
                    limit_states_num):
                raise ValidationError(
                    'The number of items of "Coefficient of variation of '
                    'the standard deviation" must be consistent with '
                    'the number of limit states (i.e. %d)' % limit_states_num)
            if self.predictor_var_corr_matrix:
                rows = self.predictor_var_corr_matrix.split('\n')
                if len(rows) != (2 * limit_states_num):
                    raise ValidationError(
                        'The number of rows of "Predictor variable '
                        'correlation matrix" '
                        'must be twice the number of limit states '
                        '(i.e. %d)' % (2 * limit_states_num))
                if rows and len(rows[0].split(';')) != (2 * limit_states_num):
                    raise ValidationError(
                        'The number of columns of "Predictor variable '
                        'correlation matrix" '
                        'must be twice the number of limit states '
                        '(i.e. %d)' % (2 * limit_states_num))


# B1-b
class FuncDistrFragDiscr(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "discrete function distribution"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='func_distr_frag_discr',
        verbose_name='fragility function')
    data_pts_num = models.IntegerField('Number of data points')
    #predictor_var_im_val = SemicolonSeparatedFloatRomanField(
    predictor_var_im_val = SemicolonSeparatedFloatField(
        'Predictor variable (IM) values', max_length=1024,
        help_text=('The number of values must be '
                   'consistent with the number of data points.'))
    limit_state_prob_exceed = BidimensionalFloatField(
        'Probability of limit state exceedance', max_length=10240,
        help_text=('The number of rows must be '
                   'consistent with the specified number of limit states; '
                   'the number of columns '
                   'must consistent with the number of data points.'))
    limit_state_prob_exceed_05 = BidimensionalFloatField(
        'Probability of limit state exceedance values '
        '(5% prediction interval)',
        null=True, blank=True, max_length=10240,
        help_text=('The number of rows must be '
                   'consistent with the specified number of limit states; '
                   'the number of columns '
                   'must consistent with the number of data points.'))
    limit_state_prob_exceed_95 = BidimensionalFloatField(
        'Probability of limit state exceedance values '
        '(95% prediction interval)',
        null=True, blank=True, max_length=10240,
        help_text=('The number of rows must be '
                   'consistent with the specified number of limit states; '
                   'the number of columns '
                   'must consistent with the number of data points.'))

    def clean(self):
        if len(self.predictor_var_im_val.split(';')) != self.data_pts_num:
            raise ValidationError(
                'The number of data points and the number of predictor '
                'variable (IM) values must be consistent')
        # Get the rows of each matrix
        prob_exceed_rows = None
        prob_exceed_05_rows = None
        prob_exceed_95_rows = None
        if self.limit_state_prob_exceed:
            prob_exceed_rows = self.limit_state_prob_exceed.split('\n')
        if self.limit_state_prob_exceed_05:
            prob_exceed_05_rows = self.limit_state_prob_exceed_05.split('\n')
        if self.limit_state_prob_exceed_95:
            prob_exceed_95_rows = self.limit_state_prob_exceed_95.split('\n')
        if (prob_exceed_rows and
                len(prob_exceed_rows[0].split(';')) != self.data_pts_num):
            raise ValidationError('The number of data points and the number '
                                  'of columns of "Probability of limit state '
                                  'exceedance" must be consistent')
        if (prob_exceed_05_rows and
                len(prob_exceed_05_rows[0].split(';')) != self.data_pts_num):
            raise ValidationError('The number of data points and the number '
                                  'of columns of "Probability of limit state '
                                  'exceedance values (5% prediction '
                                  'interval)" must be consistent')
        if (prob_exceed_95_rows and
                len(prob_exceed_95_rows[0].split(';')) != self.data_pts_num):
            raise ValidationError('The number of data points and the number '
                                  'of columns of "Probability of limit state '
                                  'exceedance values (95% prediction '
                                  'interval)" must be consistent')
        if not self.fragility_func.limit_states_num:
            raise ValidationError('Please specify the limit states')
        elif (prob_exceed_rows and
                (len(prob_exceed_rows) !=
                    self.fragility_func.limit_states_num)):
            raise ValidationError(
                'The number of rows of "Probability of limit state '
                'exceedance" must be consistent with the number of '
                'limit states specified (i.e. %d)' % (
                    self.fragility_func.limit_states_num))
        elif (prob_exceed_05_rows and
                (len(prob_exceed_05_rows) !=
                    self.fragility_func.limit_states_num)):
            raise ValidationError(
                'The number of rows of "Probability of limit state '
                'exceedance values (5%% prediction interval)" must be '
                'consistent with the number of limit states specified '
                '(i.e. %d)' % self.fragility_func.limit_states_num)
        elif (prob_exceed_95_rows and
                (len(prob_exceed_95_rows) !=
                    self.fragility_func.limit_states_num)):
            raise ValidationError(
                'The number of rows of "Probability of limit state '
                'exceedance values (95%% prediction interval)" must be '
                'consistent with the number of limit states specified '
                '(i.e. %d)' % self.fragility_func.limit_states_num)


# A1-a
class EngineeringDemandPar(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "engineering demand parameter"
    # Initial data
    #ENGINEERING_DEMAND_PARAMETERS = (
        #(1, 'Interstorey drift'),
        #(2, 'Global drift'),
        #(3, 'Residual drift'),
        #(4, 'Rotation capacity'),
        #(5, 'Shear capacity'),
        #(6, 'Strain levels'),
        #(7, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)
    user_def = models.BooleanField(default=True, editable=False)

    def __unicode__(self):
        return self.name


# B1
class FragilityFunc(SingleOwnerMixin, models.Model):
    class Meta:
        verbose_name = "fragility function"
    general_information = models.OneToOneField(
        'GeneralInformation', null=True,
        blank=True, related_name='fragility_func',
        verbose_name='general information')
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # One2One with StatisticalInformation
    # One2One with PredictorVar
    # One2One with FuncDistrFragDiscr
    # One2One with FuncDistrFragCont
    # One2One with QRSEmpirical
    # One2One with QRSAnalytical
    # TODO Grouping 'Damage characterization'
    damage_scale = models.IntegerField(
        choices=DAMAGE_SCALES, null=True, blank=True)
    engineering_demand_par = models.ForeignKey(
        'EngineeringDemandPar', null=True, blank=True,
        verbose_name='engineering demand parameter')
    limit_states_desc = SemicolonSeparatedStringField(
        'Description of limit states', max_length=1024,
        help_text='Select damage scale to automatically populate this field')
    func_distr_type = models.IntegerField(
        'Function distribution type',
        choices=FUNC_DISTR_TYPES)

    @property
    def limit_states_num(self):
        if self.limit_states_desc:
            return len(self.limit_states_desc.split(';'))
        else:
            return 0


class CAT(object):
    STR_SPEC = 1
    STR_CLASS = 2
    NONSTR_COMP = 3
    POPULATION = 4
    CAPITAL_STOCK = 5


CATEGORIES = (
    (CAT.STR_SPEC, 'Structure specific'),
    (CAT.STR_CLASS, 'Structure class'),
    (CAT.NONSTR_COMP, 'Nonstructural component'),
    (CAT.POPULATION, 'Population'),
    (CAT.CAPITAL_STOCK, 'Capital stock'),
)


class STR_TYPE(object):
    BUILDING = 1
    BRIDGE = 2
    OTHER = 3


STRUCTURE_TYPES = (
    (STR_TYPE.BUILDING, 'Building'),
    # (STR_TYPE.BRIDGE, 'Bridge'),
    # (STR_TYPE.OTHER, 'Other'),
)


class GeneralInformationManager(models.Manager):
    def get_by_natural_key(self, name):
        return self.get(name=name)


# A
class GeneralInformation(SingleOwnerMixin, models.Model):
    # one2one with FragilityFunc
    # one2one with VulnerabilityFunc
    # one2one with DamageToLossFunc
    # one2one with CapacityCurveFunc
    # one2one with GeoApplicability

    class Meta:
        verbose_name = "function"
        ordering = ['name']

    # A.1 Reference ID code/name: choose integer(code)/string(name)
    name = models.CharField(max_length=CHMAX, unique=True)
    category = models.IntegerField(choices=CATEGORIES)
    # For category in (Structure specific, Structure class)
    # it's possible to select among
    # Buildings, Bridges and other types of structures
    # Bridge and Other will be available in the next release
    structure_type = models.IntegerField(
        choices=STRUCTURE_TYPES, blank=True, null=True,
        help_text='"Building" type is only applicable to "Structure specific"'
        ' or "Structure class"')
    # For Nonstructural component you can use ATC58 taxonomy and other
    # if the structure is a Building, specify the taxonomy
    taxonomy_type = models.ForeignKey(
        'TaxonomyType', blank=True, null=True,
        help_text='Mandatory if the structure type is "Building".')
    taxonomy_text = models.CharField(max_length=1023, blank=True, null=True)
    taxonomy_gem = models.CharField(
        max_length=1023, blank=True, null=True, editable=False)
    # if a structure is a Bridge, specify material and llrs
    # NOTE: we are creating these fields in the DB although they are going to
    # be available to the user in a future release
    material = models.CharField(
        max_length=CHMAX, blank=True, null=True, editable=False)
    llrs = models.CharField(
        max_length=CHMAX, blank=True, null=True, editable=False,
        verbose_name="lateral load resisting system (L.L.R.S.)")
    # else TODO: What then?? Add new item to STRUCTURE_TYPES, which therefore
    # needs to become a new table?

    type_of_assessment = models.IntegerField(choices=TYPES_OF_ASSESSMENT)
    # A.3 Reference / documentation
    # TODO: Capire come raggruppare come nell'inline
    authors = UnaccentCharField(max_length=CHMAX)
    article_title = models.CharField(max_length=CHMAX)
    publication_conference_name = models.CharField(
        max_length=CHMAX)
    year = models.IntegerField(
        validators=[MinValueValidator(1900),
                    MaxValueValidator(datetime.now().year)])
    web_link = models.URLField(null=True, blank=True, max_length=255)
    general_comments = models.TextField(
        max_length=TFMAX, null=True, blank=True)
    use_case_information = models.TextField(
        max_length=TFMAX, null=True, blank=True)

    cart = models.ManyToManyField(User)

    objects = GeneralInformationManager()

    def natural_key(self):
        return (self.name,)

    def clean(self):
        if int(self.category) not in (CAT.STR_SPEC, CAT.STR_CLASS):
            if self.structure_type:
                raise ValidationError(
                    'Structure type must be empty for '
                    'the selected category')
        elif not self.structure_type:
            raise ValidationError(
                'Please specify the structure type')

        taxonomy_text_invalid = False
        if self.taxonomy_text == "__InvaliDValuE__":
            taxonomy_text_invalid = True
            self.taxonomy_text = "";

        if self.taxonomy_text and not self.taxonomy_type:
            raise ValidationError(
                'To set taxonomy specify taxonomy type before')

        if self.type_of_assessment == TA.CAPACITY_CURVE:
            if int(self.category) not in (CAT.STR_SPEC,
                                          CAT.STR_CLASS,
                                          CAT.NONSTR_COMP):
                raise ValidationError(
                    'Capacity curves can only be assigned to structure'
                    ' specific, structure class or nonstructural components.')

        if (int(self.category) in (CAT.STR_SPEC, CAT.STR_CLASS, CAT.NONSTR_COMP)
            and self.structure_type == STR_TYPE.BUILDING):
            if not self.taxonomy_type:
                raise ValidationError(
                    'The structure type is "Building", so you must '
                    'specify both taxonomy type and taxonomy text')
            if self.taxonomy_type and self.taxonomy_type.name == 'ATC58':
                raise ValidationError(
                    'For buildings, the ATC58 taxonomy type is not applicable')
        # TODO: When Bridge structures will be included, check that material
        # and llrs are filled when Bridge is selected
        # TODO: Give the proper value to taxonomy_gem

        if self.taxonomy_type and taxonomy_text_invalid:
            raise ValidationError(
                'You must specify a taxonomy or check the "Any" taxonomy'
                ' checkbox.')

        self.taxonomy_gem = self.taxonomy_text
        return True

    def __unicode__(self):
        return self.name
