#import re
from django.db import models
#from django.core import validators
#from django.core.validators import RegexValidator

#comma_separated_float_list_re = re.compile('^([-+]?\d*\.?\d+[,\s]*)+$')
#validate_comma_separated_float_list = RegexValidator(
    #comma_separated_float_list_re,
    #u'Enter only floats separated by commas.', 'invalid')

METHODS_OF_ESTIMATION = (
    (1, 'Analytical'),
    #(2, 'Hybrid'),
    (3, 'Empirical'),
    #(4, 'Expert Opinion'),
)


class CommaSeparatedFloatField(models.CharField):
    pass
    #default_validators = [validate_comma_separated_float_list]
    #description = "Comma-separated floats"

    #def formfield(self, **kwargs):
        #defaults = {
            #'error_messages': {
                #'invalid': u'Enter only floats separated by commas.',
            #}
        #}
        #defaults.update(kwargs)
        #return super(CommaSeparatedFloatField, self).formfield(**defaults)


#semicolon_separated_string_list_re = re.compile('^([-+]?\d*\.?\d+[,\s]*)+$')
#validate_semicolon_separated_string_list = RegexValidator(
    #semicolon_separated_string_list_re,
    #u'Enter only strings separated by semicolons.', 'invalid')


class SemicolonSeparatedStringField(models.CharField):
    pass
    #default_validators = [validate_semicolon_separated_string_list]
    #description = "Semicolon-separated strings"

    #def formfield(self, **kwargs):
        #defaults = {
            #'error_messages': {
                #'invalid': u'Enter only floats separated by semicolons.',
            #}
        #}
        #defaults.update(kwargs)
        #return super(SemicolonSeparatedStringField, self).formfield(**defaults)


class BidimensionalFloatField(models.TextField):
    pass
    #TODO default_validators =
    #description = ("Semicolon separated float fields with newline"
                   #" as rows separator")

    #def formfield(self, **kwargs):
        #defaults = {
            #'error_messages': {
                #'invalid': u'Enter only floats separated by semicolons.',
            #}
        #}
        #defaults.update(kwargs)
        #return super(BidimensionalFloatField, self).formfield(**defaults)


class ExtendableDropDown(object):
    pass

CHMAX = 200


# A
class GeneralInformation(models.Model):
    # A.1 Reference ID code/name: choose integer(code)/string(name)
    reference_id = models.CharField(max_length=CHMAX, unique=True)
    TYPES_OF_ASSESSMENT = (
        (1, 'Fragility'),
        (2, 'Vulnerability'),
        (3, 'Damage-to-loss'),
        (4, 'Capacity curve'),
    )
    type_of_assessment = models.IntegerField(choices=TYPES_OF_ASSESSMENT)
    # A.3 Reference / documentation
    authors = models.CharField(max_length=CHMAX)
    article_title = models.CharField(max_length=CHMAX)
    publication_conference_name = models.CharField(
        max_length=CHMAX, null=True, blank=True)
    year = models.IntegerField()
    web_link = models.URLField(null=True, blank=True, max_length=255)
    use_case_information = models.CharField(
        max_length=CHMAX, null=True, blank=True)
    general_comments = models.CharField(
        max_length=CHMAX, null=True, blank=True)


# C1
class AnalyticalModelInfo(models.Model):
    ANALYSIS_TYPES = (
        (1, 'Nonlinear dynamic analysis (NLD)'),
        (2, 'Nonlinear static analysis (NLS) with dispersion'),
        (3, 'NLS without dispersion'),
        (4, 'Collapse mechanism-based methods'),
        (5, 'Simplified Displacement-based methods'),
        (6, 'Other simplified methods'),
    )
    analysis_type = models.IntegerField(choices=ANALYSIS_TYPES)
    analysis_type_other = models.CharField(
        max_length=CHMAX, null=True, blank=True)
    MODEL_TYPES = (
        (1, '3D'),
        (2, '2D element-by-element'),
        (3, '2D story-by-story'),
        (4, '1D'),
    )
    model_type = models.IntegerField(choices=MODEL_TYPES)
    METHODS_UNCERT_PROPAG = (
        (1, 'Random Monte-Carlo or Latin Hypercube sampling'),
        (2, 'Set of index buildings'),
        (3, 'Single index building'),
    )
    method_uncert_propag = models.IntegerField(choices=METHODS_UNCERT_PROPAG)
    # Number of dinstinct structural models analysed
    models_num = models.IntegerField(null=True, blank=True)


# C2
class EmpiricalModelInfo(models.Model):
    structural_unit = models.IntegerField(choices=(
        (1, 'Dwelling'), (2, 'Building')))
    building_x_class_num = models.IntegerField()
    empirical_data_src = models.CharField(max_length=CHMAX)
    building_aggr = models.IntegerField(choices=(
        (1, 'Building-by-building'), (2, 'Grouped')))
    building_aggr_min_num = models.IntegerField(null=True, blank=True)
    AGGR_UNIT_DEFS = (
        (1, 'GADM admin 2 region'),
        (2, 'GADM admin 3 region'),
        (3, 'Other admin region'),
        (4, 'Bins of IM'),
    )
    aggr_unit_def = models.IntegerField(choices=AGGR_UNIT_DEFS)


# A2-a
class FuncDistributionFragDiscrete(models.Model):
    data_pts_num = models.IntegerField()
    predictor_var_im_val = CommaSeparatedFloatField(max_length=1024)
    limit_state_prob_exceed = BidimensionalFloatField()
    limit_state_prob_exceed_05 = BidimensionalFloatField(null=True, blank=True)
    limit_state_prob_exceed_95 = BidimensionalFloatField(null=True, blank=True)


# A2-b
class FuncDistributionFragContinuous(models.Model):
    mean = CommaSeparatedFloatField(max_length=1024)
    std_dev = CommaSeparatedFloatField(max_length=1024)
    func_distr_shape = ExtendableDropDown()
    coeff_variation_mean = CommaSeparatedFloatField(max_length=1024)
    coeff_variation_std_dev = CommaSeparatedFloatField(max_length=1024)
    predictor_var_corr_matrix = BidimensionalFloatField(null=True, blank=True)


# used by FragilityFunc and VulnerabilityFunc
class PredictorVariable(models.Model):
    INTENSITY_MEASURE_TYPES = (
        (1, 'PGA'),
        (2, 'PGV'),
        (3, 'PGD'),
        (4, 'Sa(T)'),
        (5, 'IA'),
        (6, 'CAV'),
        (7, 'RSD'),
        (8, 'MMI'),
    )
    intensity_measure_type = models.IntegerField(
        choices=INTENSITY_MEASURE_TYPES)
    INTENSITY_MEASURE_UNITS = (
        (1, 'Acceleration (g)'),
        (2, 'Acceleration (cm/s^2)'),
        (3, 'Acceleration (m/s^2)'),
        (4, 'Velocity (cm/s)'),
        (5, 'Velocity (m/s)'),
        (6, 'Displacement (cm)'),
        (7, 'Displacement (m)'),
        (8, 'Time (s)'),
        (9, 'CAV (g-s)'),
        (10, 'MMI roman numbers'),
    )
    intensity_measure_unit = models.IntegerField(
        choices=INTENSITY_MEASURE_UNITS)
    minimum_im = models.FloatField()
    maximum_im = models.FloatField()
    EVALUATIONS_OF_IM = (
        (1, 'GMPE'),
        (2, 'ShakeMap'),
        (3, 'Natural Accelerograms'),
        (4, 'Artificial Accelerograms'),
        (5, 'Spectrum-compatible accelerograms'),
        (6, 'Spectrum (code-based)'),
        (7, 'Spectrum (GMPE-based)'),
        (8, 'Spectrum (other)'),
    )
    evaluation_of_im = models.IntegerField(choices=EVALUATIONS_OF_IM)


# A1
class FragilityFunc(models.Model):
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    analytical_model_info = models.ForeignKey('AnalyticalModelInfo')
    empirical_model_info = models.ForeignKey('EmpiricalModelInfo')
    DAMAGE_SCALES = (
        (1, 'MSK-76'),
        (2, 'EMS98'),
        (3, 'EMS92'),
        (4, 'HAZUS'),
        (5, 'ATC-13'),
        (6, 'Custom'),
    )
    damage_scale = models.IntegerField(choices=DAMAGE_SCALES)
    ENGINEERING_DEMAND_PARAMETERS = (
        (1, 'Interstorey drift'),
        (2, 'Global drift'),
        (3, 'Residual drift'),
        (4, 'Rotation capacity'),
        (5, 'Shear capacity'),
        (6, 'Strain levels'),
        (7, 'Other'),
    )
    engineering_demand_par = models.IntegerField(
        choices=ENGINEERING_DEMAND_PARAMETERS)
    engineering_demand_par_other = models.CharField(max_length=CHMAX,
                                                    null=True,
                                                    blank=True)
    limit_states_num = models.PositiveIntegerField()
    # They require a vector with free text
    # (e.g. ['Slight', 'Moderate', 'Collapse']
    limit_states_desc = SemicolonSeparatedStringField(max_length=1024)
    predictor_variable = models.ForeignKey('PredictorVariable')
    FUNCTION_DISTRIBUTION_TYPES = (
        (1, 'Discrete'),
        (2, 'Continuous')
    )
    function_distribution_type = models.IntegerField(
        choices=FUNCTION_DISTRIBUTION_TYPES)
    function_distribution_discrete = models.ForeignKey(
        'FuncDistributionFragDiscrete')
    function_distribution_continuous = models.ForeignKey(
        'FuncDistributionFragContinuous')


class FuncDistributionVulnDiscrete(models.Model):
    pass


class FuncDistributionVulnContinuous(models.Model):
    pass


# A2
class VulnerabilityFunc(models.Model):
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    predictor_variable = models.ForeignKey('PredictorVariable')
    RESPONSE_VARIABLES = (
        (1, 'Damage factor'),
        (2, 'Fatality rate per occupant'),
        (3, 'Nonfatal injury rate per occupant'),
        (4, 'Fatality rate per exposed population'),
        (5, 'Direct economic factor'),
    )
    response_variable = models.IntegerField(choices=RESPONSE_VARIABLES)
    FUNCTION_DISTRIBUTION_TYPES = (
        (1, 'Discrete'),
        (2, 'Continuous'),
    )
    function_distribution_type = models.IntegerField(
        choices=FUNCTION_DISTRIBUTION_TYPES)
    func_distr_discrete = models.ForeignKey('FuncDistributionVulnDiscrete')
    func_distr_continuous = models.ForeignKey('FuncDistributionVulnContinuous')


## HERE


# A3
class DamageToLossFunc(models.Model):
    pass


# A4
class CapacityCurve(models.Model):
    #modelling_information
    #predictor_variable
    #response_variable
    pass


# B
class Applicability(models.Model):
    pass


# B1
class RegionAsGeographicalApplicability(models.Model):
    pass


# B2.1
class TaxonomyClassifForBuildings(models.Model):
    gem = models.TextField()
    pager = models.TextField()
    # I suppose we should specify both the textfield and the name of the
    # taxonomy
    other_taxonomy_name = models.CharField(max_length=CHMAX)
    other_taxonomy_text = models.TextField()


# C
class ModellingInformation(models.Model):
    #analytical_hybrid_modelling
    #empirical_modelling
    #statistical_information
    pass


# C3
class StatisticalInformation(models.Model):
    STATISTICAL_MODELS = (
        (1, 'Generalised Linear Models'),
        (2, 'Generalised Additive Models'),
        (3, 'Kernel smoothing'),
        (4, 'Other'),
    )
    stat_model = models.IntegerField(choices=STATISTICAL_MODELS)
    #stat_model_fitting_method
    #model_fitting_method_assumptions
    #fit_assessment_goodness
    PROC_CONSTR_INT_CHOICES = (
        (1, 'Asymptotic'),
        (2, 'Bootstrap'),
        (3, 'Bayesian'),
        (4, 'Other'),
    )
    proc_constr_conf_int = models.IntegerField(choices=PROC_CONSTR_INT_CHOICES)
    proc_constr_pred_int = models.IntegerField(choices=PROC_CONSTR_INT_CHOICES)


# D
class QualityRatingSystem(models.Model):
    DATA_QUALITY_CHOICES = (
        (1, 'Data quantity'),
        (2, 'Constrained categories'),
        (3, 'Excitation observation'),
        (4, 'Damage/loss observation'),
    )
    data_quality = models.IntegerField(choices=DATA_QUALITY_CHOICES)
    RATIONALITY_CHOICES = (
        (1, 'Hindcasting'),
        (2, 'Cross validation'),
        (3, 'First principles'),
        (4, 'Treatment of uncertainties'),
    )
    rationality = models.IntegerField(choices=RATIONALITY_CHOICES)
    #documentation_quality =
    #representativeness =
    #overall_rating =
