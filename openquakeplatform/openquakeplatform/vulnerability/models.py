#import re
from django.db import models
#from django.core import validators
#from django.core.validators import RegexValidator

#comma_separated_float_list_re = re.compile('^([-+]?\d*\.?\d+[,\s]*)+$')
#validate_comma_separated_float_list = RegexValidator(
    #comma_separated_float_list_re,
    #u'Enter only floats separated by commas.', 'invalid')


class CommaSeparatedFloatField(models.CharField):
    pass
    #default_validators = [validate_comma_separated_float_list]
    #description = "Comma-separated floats"

    #def formfield(self, **kwargs):
        #defaults = {
            #'error_messages': {
                #'invalid': u'Enter only floats separated by commas.',
            #}
        #}
        #defaults.update(kwargs)
        #return super(CommaSeparatedFloatField, self).formfield(**defaults)


#semicolon_separated_string_list_re = re.compile('^([-+]?\d*\.?\d+[,\s]*)+$')
#validate_semicolon_separated_string_list = RegexValidator(
    #semicolon_separated_string_list_re,
    #u'Enter only strings separated by semicolons.', 'invalid')


class SemicolonSeparatedStringField(models.CharField):
    pass
    #default_validators = [validate_semicolon_separated_string_list]
    #description = "Semicolon-separated strings"

    #def formfield(self, **kwargs):
        #defaults = {
            #'error_messages': {
                #'invalid': u'Enter only floats separated by semicolons.',
            #}
        #}
        #defaults.update(kwargs)
        #return super(SemicolonSeparatedStringField, self).formfield(
            #**defaults)


class BidimensionalFloatField(models.TextField):
    pass
    #TODO default_validators =
    #description = ("Semicolon separated float fields with newline"
                   #" as rows separator")

    #def formfield(self, **kwargs):
        #defaults = {
            #'error_messages': {
                #'invalid': u'Enter only floats separated by semicolons.',
            #}
        #}
        #defaults.update(kwargs)
        #return super(BidimensionalFloatField, self).formfield(**defaults)


CHMAX = 200


# D
class QualityRatingSystem(models.Model):
    DATA_QUALITY_CHOICES = (
        (1, 'Data quantity'),
        (2, 'Constrained categories'),
        (3, 'Excitation observation'),
        (4, 'Damage/loss observation'),
    )
    data_quality = models.IntegerField(choices=DATA_QUALITY_CHOICES)
    DATA_QUALITY_ESTIMATIONS = (
        (1, 'Superior'),
        (2, 'Average'),
        (3, 'Marginal'),
        (4, 'Not applicable'),
    )
    data_quality_estimation = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)
    RATIONALITY_CHOICES = (
        (1, 'Hindcasting'),
        (2, 'Cross validation'),
        (3, 'First principles'),
        (4, 'Treatment of uncertainties'),
    )
    rationality = models.IntegerField(choices=RATIONALITY_CHOICES)
    rationality_estimation = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)
    documentation_quality = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)
    representativeness = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)
    overall_rating = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)


# C3
class StatisticalInformation(models.Model):
    class Meta:
        verbose_name_plural = "Statistical information"
    STATISTICAL_MODELS = (
        (1, 'Generalised Linear Models'),
        (2, 'Generalised Additive Models'),
        (3, 'Kernel smoothing'),
        (4, 'Other'),
    )
    stat_model = models.IntegerField('Statistical model',
                                     choices=STATISTICAL_MODELS)
    STAT_MODEL_FITTING_METHODS = (
        (1, 'Least squares'),
        (2, 'Maximum likelyhood'),
        (3, 'Robust maximum likelyhood'),
        (4, 'Bayesian'),
    )
    stat_model_fitting_method = models.IntegerField(
        'Statistical model fitting method',
        choices=STAT_MODEL_FITTING_METHODS)
    MODEL_FITTING_METHOD_ASSUMPTIONS = (
        (1, 'Independence of observations'),
        (2, 'Measurement error in IM'),
        (3, 'Measurement error in response'),
        (4, 'Other'),
    )
    model_fitting_method_assumptions = models.IntegerField(
        choices=MODEL_FITTING_METHOD_ASSUMPTIONS)
    FIT_ASSESSMENT_GOODNESS_OPTIONS = (
        (1, 'Acceptable mean function'),
        (2, 'Acceptable variance function'),
        (3, 'Other'),
    )
    fit_assessment_goodness = models.IntegerField(
        'Goodness of fit assessment (GLM/GAM)',
        choices=FIT_ASSESSMENT_GOODNESS_OPTIONS)
    PROC_CONSTR_INT_CHOICES = (
        (1, 'Asymptotic'),
        (2, 'Bootstrap'),
        (3, 'Bayesian'),
        (4, 'Other'),
    )
    proc_constr_conf_int = models.IntegerField(
        'Procedure for the construction of confidence intervals',
        choices=PROC_CONSTR_INT_CHOICES)
    proc_constr_pred_int = models.IntegerField(
        'Procedure for the construction of prediction intervals',
        choices=PROC_CONSTR_INT_CHOICES)


# C2
class EmpiricalModelInfo(models.Model):
    class Meta:
        verbose_name = "Empirical modelling information"
        verbose_name_plural = "Empirical modelling information"
    damage_to_loss_func = models.OneToOneField(
        'DamageToLossFunc', null=True,
        blank=True, related_name='empirical_model_info',
        verbose_name="Damage to loss function")
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='empirical_model_info',
        verbose_name="Vulnerability function")
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='empirical_model_info',
        verbose_name="Fragility function")
    structural_unit = models.IntegerField(choices=(
        (1, 'Dwelling'), (2, 'Building')))
    building_x_class_num = models.IntegerField(
        'Number of buildings per class')
    empirical_data_src = models.CharField(
        'Source of empirical data', max_length=CHMAX)
    building_aggr = models.IntegerField(
        'Building aggregation',
        choices=((1, 'Building-by-building'), (2, 'Grouped')))
    # TODO: Validation: editable only if 'Grouped' was chosen
    building_aggr_min_num = models.IntegerField(
        'Minimum number of grouped buildings', null=True, blank=True)
    AGGR_UNIT_DEFS = (
        (1, 'GADM admin 2 region'),
        (2, 'GADM admin 3 region'),
        (3, 'Other admin region'),
        (4, 'Bins of IM'),
    )
    aggr_unit_def = models.IntegerField(
        'Definitions of aggregated units',
        choices=AGGR_UNIT_DEFS)


# C1-a
class AnalysisType(models.Model):
    # Initial values
    #ANALYSIS_TYPES = (
        #(1, 'Nonlinear dynamic analysis (NLD)'),
        #(2, 'Nonlinear static analysis (NLS) with dispersion'),
        #(3, 'NLS without dispersion'),
        #(4, 'Collapse mechanism-based methods'),
        #(5, 'Simplified Displacement-based methods'),
        #(6, 'Other simplified methods'),
    #)
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# C1
class AnalyticalModelInfo(models.Model):
    class Meta:
        verbose_name = "Analytical modelling information"
        verbose_name_plural = "Analytical modelling information"
    capacity_curve_func = models.OneToOneField(
        'CapacityCurveFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='Capacity curve function')
    damage_to_loss_func = models.OneToOneField(
        'DamageToLossFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='Damage to loss function')
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='Vulnerability function')
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True, blank=True,
        related_name='analytical_model_info',
        verbose_name='Fragility function')
    analysis_type = models.ForeignKey('AnalysisType')
    MODEL_TYPES = (
        (1, '3D'),
        (2, '2D element-by-element'),
        (3, '2D story-by-story'),
        (4, '1D'),
    )
    model_type = models.IntegerField(choices=MODEL_TYPES)
    METHODS_UNCERT_PROPAG = (
        (1, 'Random Monte-Carlo or Latin Hypercube sampling'),
        (2, 'Set of index buildings'),
        (3, 'Single index building'),
    )
    method_uncert_propag = models.IntegerField(
        'Method of uncertainty propagation',
        choices=METHODS_UNCERT_PROPAG)
    models_num = models.IntegerField(
        'Number of distinct structural models analysed',
        null=True, blank=True)


# C
class ModellingInformation(models.Model):
    #analytical_hybrid_modelling
    #empirical_modelling
    #statistical_information
    pass


# B1
class RegionAsGeographicalApplicability(models.Model):
    pass


# B
class Applicability(models.Model):
    pass


MOE_ANALYTICAL = 1
MOE_EMPIRICAL = 2
METHODS_OF_ESTIMATION = (
    (MOE_ANALYTICAL, 'Analytical'),
    (MOE_EMPIRICAL, 'Empirical'),
)


DAMAGE_SCALES = (
    (1, 'MSK-76'),
    (2, 'EMS98'),
    (3, 'EMS92'),
    (4, 'HAZUS'),
    (5, 'ATC-13'),
    (6, 'Custom'),
)


RESPONSE_VARS = (
    (1, 'Damage factor'),
    (2, 'Fatality rate per occupant'),
    (3, 'Nonfatal injury rate per occupant'),
    (4, 'Fatality rate per exposed population'),
    (5, 'Direct economic factor'),
)


# A5
class TaxonomyType(models.Model):
    # Initial values: GEM, PAGER, ATC58
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# Ax-a
class FuncDistrShape(models.Model):
    class Meta:
        verbose_name = "Function distribution shape"
    # Initial values: Lognormal, Beta, Gamma
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# A4-b
class CC_EngineeringDemandPar(models.Model):
    class Meta:
        verbose_name = "Engineering demand parameter"
    # Initial data
    #ENGINEERING_DEMAND_PARAMETERS = (
        #(1, 'Interstorey drift'),
        #(2, 'Global drift'),
        #(3, 'Residual drift'),
        #(4, 'Lateral roof displacement'),
        #(5, 'Chord rotation'),
        #(6, 'Curvature'),
        #(7, 'Shear strain'),
        #(8, 'Spectral displacement'),
    #)
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# A4-a
class CC_PredictorVar(models.Model):
    class Meta:
        verbose_name = "Predictor variable"
    capacity_curve_func = models.OneToOneField(
        'CapacityCurveFunc', null=True,
        blank=True, related_name='cc_predictor_var',
        verbose_name="Capacity curve function")
    engineering_demand_param = models.ForeignKey(
        'CC_EngineeringDemandPar',
        verbose_name='Engineering demand parameter')
    data_pts_num = models.IntegerField('Number of data points')
    pred_var_units = models.CharField(
        'Predictor variable units', max_length=16)
    pred_var_val = CommaSeparatedFloatField(
        'Predictor variable values', max_length=1024)


# A4
class CapacityCurveFunc(models.Model):
    class Meta:
        verbose_name = "Capacity curve function"
    # One2One with AnalyticalModelInfo
    # One2One with CC_PredictorVar
    RESPONSE_VAR_PAR = (
        (1, 'Base shear'),
        (2, 'Base bending moment'),
        (3, 'Spectral acceleration'),
    )
    response_var = models.IntegerField(
        'Response variable', choices=RESPONSE_VAR_PAR)
    res_var_units = models.CharField(
        'Response variable units', max_length=16)
    res_var_val = CommaSeparatedFloatField(
        'Response variable values', max_length=1024)


# A3
class DamageToLossFunc(models.Model):
    class Meta:
        verbose_name = "Damage to loss function"
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # begin group 'Predictor variable (damage state)'
    damage_scale = models.IntegerField(choices=DAMAGE_SCALES, null=True)
    limit_states_num = models.IntegerField(
        'Number of limit states')
    limit_states_desc = SemicolonSeparatedStringField(
        'Description of limit states', max_length=1024)
    # end group 'Predictor variable (damage state)'
    response_var = models.IntegerField(
        'Response variable', choices=RESPONSE_VARS)
    # NOTE: currently discrete only
    # func_distr_type =
    var_mean_val = CommaSeparatedFloatField(
        'Mean values', max_length=1024)
    var_val_coeff = CommaSeparatedFloatField(
        'Coefficient of variation values', max_length=1024)
    func_distr_shape = models.ForeignKey(
        'FuncDistrShape', null=True,
        verbose_name='Function distribution shape')


# A2-b
class FuncDistrVulnCont(models.Model):
    class Meta:
        verbose_name = "Continuos function distribution"
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='func_distr_vuln_cont',
        verbose_name="Vulnerability function")
    discretization_data_pts_num = models.IntegerField(
        'Number of discretization data points', null=True)
    mean = models.FloatField()
    std_dev = models.FloatField('Standard deviation')
    func_distr_shape = models.ForeignKey(
        'FuncDistrShape', verbose_name="Function distribution shape")


# A2-a
class FuncDistrVulnDiscr(models.Model):
    class Meta:
        verbose_name = "Discrete function distribution"
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='func_distr_vuln_discr',
        verbose_name="Vulnerability function")
    data_pts_num = models.IntegerField('Number of data points')
    predictor_var_im_val = CommaSeparatedFloatField(
        'Predictor variable (IM) values', max_length=1024)
    response_var_mean_val = CommaSeparatedFloatField(
        'Response variable: mean values', max_length=1024)
    response_var_val_coeff = CommaSeparatedFloatField(
        'Response variable: coefficient of variation values', max_length=1024)


# used by FragilityFunc and VulnerabilityFunc
# A.2.2
class PredictorVar(models.Model):
    class Meta:
        verbose_name = "Predictor variable"
    vulnerability_func = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='predictor_var',
        verbose_name="Vulnerability function")
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='predictor_var',
        verbose_name="Fragility function")
    INTENSITY_MEASURE_TYPES = (
        (1, 'PGA'),
        (2, 'PGV'),
        (3, 'PGD'),
        (4, 'Sa(T)'),
        (5, 'IA'),
        (6, 'CAV'),
        (7, 'RSD'),
        (8, 'MMI'),
    )
    intensity_measure_type = models.IntegerField(
        choices=INTENSITY_MEASURE_TYPES)
    INTENSITY_MEASURE_UNITS = (
        (1, 'Acceleration (g)'),
        (2, 'Acceleration (cm/s^2)'),
        (3, 'Acceleration (m/s^2)'),
        (4, 'Velocity (cm/s)'),
        (5, 'Velocity (m/s)'),
        (6, 'Displacement (cm)'),
        (7, 'Displacement (m)'),
        (8, 'Time (s)'),
        (9, 'CAV (g-s)'),
        (10, 'MMI roman numbers'),
    )
    intensity_measure_unit = models.IntegerField(
        choices=INTENSITY_MEASURE_UNITS)
    minimum_im = models.FloatField('Minimum IM')
    maximum_im = models.FloatField('Maximum IM')
    EVALUATIONS_OF_IM = (
        (1, 'GMPE'),
        (2, 'ShakeMap'),
        (3, 'Natural Accelerograms'),
        (4, 'Artificial Accelerograms'),
        (5, 'Spectrum-compatible Accelerograms'),
        (6, 'Spectrum (code-based)'),
        (7, 'Spectrum (GMPE-based)'),
        (8, 'Spectrum (other)'),
    )
    evaluation_of_im = models.IntegerField(
        'Evaluation of IM', choices=EVALUATIONS_OF_IM)


# A2
class VulnerabilityFunc(models.Model):
    class Meta:
        verbose_name = "Vulnerability function"
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # One2One with PredictorVar
    # One2One with FuncDistrVulnDiscr
    # One2One with FuncDistrVulnCont
    response_var = models.IntegerField(
        'Response variable', choices=RESPONSE_VARS)
    func_distr_type = models.IntegerField(
        'Function distribution type',
        choices=((1, 'Discrete'), (2, 'Continuous')))


# A1-c
class FuncDistrFragCont(models.Model):
    class Meta:
        verbose_name = "Continous function distribution"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='func_distr_frag_cont',
        verbose_name='Fragility function')
    mean = CommaSeparatedFloatField(max_length=1024)
    std_dev = CommaSeparatedFloatField(
        'Standard deviation', max_length=1024)
    func_distr_shape = models.ForeignKey(
        'FuncDistrShape',
        verbose_name='Function distribution shape')
    coeff_variation_mean = CommaSeparatedFloatField(
        'Coefficient of variation of the mean',
        max_length=1024, null=True, blank=True)
    coeff_variation_std_dev = CommaSeparatedFloatField(
        'Coefficient of variation of the standard deviation',
        max_length=1024, null=True, blank=True)
    predictor_var_corr_matrix = BidimensionalFloatField(
        'Predictor variable correlation matrix',
        null=True, blank=True)


# A1-b
class FuncDistrFragDiscr(models.Model):
    class Meta:
        verbose_name = "Discrete function distribution"
    fragility_func = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='func_distr_frag_discr',
        verbose_name='Fragility function')
    data_pts_num = models.IntegerField('Number of data points')
    predictor_var_im_val = CommaSeparatedFloatField(
        'Predictor variable (IM) values', max_length=1024)
    limit_state_prob_exceed = BidimensionalFloatField(
        'Probability of limit state exceedance')
    limit_state_prob_exceed_05 = BidimensionalFloatField(
        'Probability of limit state exceedance values '
        '(5% prediction interval)',
        null=True, blank=True)
    limit_state_prob_exceed_95 = BidimensionalFloatField(
        'Probability of limit state exceedance values '
        '(95% prediction interval)',
        null=True, blank=True)


# A1-a
class EngineeringDemandPar(models.Model):
    class Meta:
        verbose_name = "Engineering demand parameter"
    # Initial data
    #ENGINEERING_DEMAND_PARAMETERS = (
        #(1, 'Interstorey drift'),
        #(2, 'Global drift'),
        #(3, 'Residual drift'),
        #(4, 'Rotation capacity'),
        #(5, 'Shear capacity'),
        #(6, 'Strain levels'),
        #(7, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)

    def __unicode__(self):
        return self.name


# A1
class FragilityFunc(models.Model):
    class Meta:
        verbose_name = "Fragility function"
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # One2One with PredictorVar
    # One2One with FuncDistrFragDiscr
    # One2One with FuncDistrFragCont
    # TODO Grouping 'Damage characterization'
    damage_scale = models.IntegerField(choices=DAMAGE_SCALES)
    engineering_demand_par = models.ForeignKey(
        'EngineeringDemandPar', null=True,
        verbose_name='Engineering demand parameter')
    limit_states_num = models.PositiveIntegerField(
        'Number of limit states')
    # They require a vector with free text
    # (e.g. ['Slight', 'Moderate', 'Collapse']
    limit_states_desc = SemicolonSeparatedStringField(
        'Description of limit states', max_length=1024)
    #FUNCTION_DISTRIBUTION_TYPES = (
        #(1, 'Discrete'),
        #(2, 'Continuous')
    #)
    #func_distr_type = models.IntegerField(
        #'Function distribution type',
        #choices=FUNCTION_DISTRIBUTION_TYPES)


# A
class GeneralInformation(models.Model):
    # A.1 Reference ID code/name: choose integer(code)/string(name)
    name = models.CharField(max_length=CHMAX)
    CATEGORIES = (
        (1, 'Structure specific'),
        (2, 'Structure class'),
        (3, 'Nonstructural component'),
        (4, 'Population'),
        (5, 'Capital stock'),
    )
    category = models.IntegerField(choices=CATEGORIES)
    # For Structure specific and Structure class it's possible to select among
    # Buildings, Bridges and other types of structures
    # For Nonstructural component you can use ATC58 and other
    taxonomy_type = models.ForeignKey('TaxonomyType')
    taxonomy_text = models.CharField(max_length=1023)
    TYPES_OF_ASSESSMENT = (
        (1, 'Fragility'),
        (2, 'Vulnerability'),
        (3, 'Damage-to-loss'),
        (4, 'Capacity curve'),
    )
    type_of_assessment = models.IntegerField(choices=TYPES_OF_ASSESSMENT)
    # TODO inline
    fragility = models.OneToOneField(
        'FragilityFunc', null=True,
        blank=True, related_name='general_information')
    vulnerability = models.OneToOneField(
        'VulnerabilityFunc', null=True,
        blank=True, related_name='general_information')
    damage_to_loss = models.OneToOneField(
        'DamageToLossFunc', null=True,
        blank=True, related_name='general_information')
    capacity_curve = models.OneToOneField(
        'CapacityCurveFunc', null=True,
        blank=True, related_name='general_information')
    # A.3 Reference / documentation
    # TODO: Capire come raggruppare come nell'inline
    authors = models.CharField(max_length=CHMAX)
    article_title = models.CharField(max_length=CHMAX)
    publication_conference_name = models.CharField(
        max_length=CHMAX)
    year = models.IntegerField()
    web_link = models.URLField(null=True, blank=True, max_length=255)
    use_case_information = models.CharField(
        max_length=CHMAX, null=True, blank=True)
    general_comments = models.CharField(
        max_length=CHMAX, null=True, blank=True)
