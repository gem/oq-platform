#import re
from django.db import models
#from django.core import validators
#from django.core.validators import RegexValidator

#comma_separated_float_list_re = re.compile('^([-+]?\d*\.?\d+[,\s]*)+$')
#validate_comma_separated_float_list = RegexValidator(
    #comma_separated_float_list_re,
    #u'Enter only floats separated by commas.', 'invalid')


class CommaSeparatedFloatField(models.CharField):
    pass
    #default_validators = [validate_comma_separated_float_list]
    #description = "Comma-separated floats"

    #def formfield(self, **kwargs):
        #defaults = {
            #'error_messages': {
                #'invalid': u'Enter only floats separated by commas.',
            #}
        #}
        #defaults.update(kwargs)
        #return super(CommaSeparatedFloatField, self).formfield(**defaults)


#semicolon_separated_string_list_re = re.compile('^([-+]?\d*\.?\d+[,\s]*)+$')
#validate_semicolon_separated_string_list = RegexValidator(
    #semicolon_separated_string_list_re,
    #u'Enter only strings separated by semicolons.', 'invalid')


class SemicolonSeparatedStringField(models.CharField):
    pass
    #default_validators = [validate_semicolon_separated_string_list]
    #description = "Semicolon-separated strings"

    #def formfield(self, **kwargs):
        #defaults = {
            #'error_messages': {
                #'invalid': u'Enter only floats separated by semicolons.',
            #}
        #}
        #defaults.update(kwargs)
        #return super(SemicolonSeparatedStringField, self).formfield(**defaults)


class BidimensionalFloatField(models.TextField):
    pass
    #TODO default_validators =
    #description = ("Semicolon separated float fields with newline"
                   #" as rows separator")

    #def formfield(self, **kwargs):
        #defaults = {
            #'error_messages': {
                #'invalid': u'Enter only floats separated by semicolons.',
            #}
        #}
        #defaults.update(kwargs)
        #return super(BidimensionalFloatField, self).formfield(**defaults)


CHMAX = 200


# D
class QualityRatingSystem(models.Model):
    DATA_QUALITY_CHOICES = (
        (1, 'Data quantity'),
        (2, 'Constrained categories'),
        (3, 'Excitation observation'),
        (4, 'Damage/loss observation'),
    )
    data_quality = models.IntegerField(choices=DATA_QUALITY_CHOICES)
    DATA_QUALITY_ESTIMATIONS = (
        (1, 'Superior'),
        (2, 'Average'),
        (3, 'Marginal'),
        (4, 'Not applicable'),
    )
    data_quality_estimation = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)
    RATIONALITY_CHOICES = (
        (1, 'Hindcasting'),
        (2, 'Cross validation'),
        (3, 'First principles'),
        (4, 'Treatment of uncertainties'),
    )
    rationality = models.IntegerField(choices=RATIONALITY_CHOICES)
    rationality_estimation = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)
    documentation_quality = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)
    representativeness = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)
    overall_rating = models.IntegerField(
        choices=DATA_QUALITY_ESTIMATIONS)


# C3
class StatisticalInformation(models.Model):
    STATISTICAL_MODELS = (
        (1, 'Generalised Linear Models'),
        (2, 'Generalised Additive Models'),
        (3, 'Kernel smoothing'),
        (4, 'Other'),
    )
    stat_model = models.IntegerField(choices=STATISTICAL_MODELS)
    #stat_model_fitting_method
    #model_fitting_method_assumptions
    #fit_assessment_goodness
    PROC_CONSTR_INT_CHOICES = (
        (1, 'Asymptotic'),
        (2, 'Bootstrap'),
        (3, 'Bayesian'),
        (4, 'Other'),
    )
    proc_constr_conf_int = models.IntegerField(choices=PROC_CONSTR_INT_CHOICES)
    proc_constr_pred_int = models.IntegerField(choices=PROC_CONSTR_INT_CHOICES)


# C2
class EmpiricalModelInfo(models.Model):
    damage_to_loss_func = models.OneToOneField('DamageToLossFunc', null=True)
    vulnerability_func = models.OneToOneField('VulnerabilityFunc', null=True)
    fragility_func = models.OneToOneField('FragilityFunc', null=True)
    structural_unit = models.IntegerField(choices=(
        (1, 'Dwelling'), (2, 'Building')))
    building_x_class_num = models.IntegerField()
    empirical_data_src = models.CharField(max_length=CHMAX)
    building_aggr = models.IntegerField(choices=(
        (1, 'Building-by-building'), (2, 'Grouped')))
    building_aggr_min_num = models.IntegerField(null=True, blank=True)
    AGGR_UNIT_DEFS = (
        (1, 'GADM admin 2 region'),
        (2, 'GADM admin 3 region'),
        (3, 'Other admin region'),
        (4, 'Bins of IM'),
    )
    aggr_unit_def = models.IntegerField(choices=AGGR_UNIT_DEFS)


# C1-a
class AnalysisType(models.Model):
    # Initial values
    #ANALYSIS_TYPES = (
        #(1, 'Nonlinear dynamic analysis (NLD)'),
        #(2, 'Nonlinear static analysis (NLS) with dispersion'),
        #(3, 'NLS without dispersion'),
        #(4, 'Collapse mechanism-based methods'),
        #(5, 'Simplified Displacement-based methods'),
        #(6, 'Other simplified methods'),
    #)
    name = models.CharField(max_length=CHMAX)


# C1
class AnalyticalModelInfo(models.Model):
    capacity_curve_func = models.OneToOneField('CapacityCurveFunc', null=True)
    damage_to_loss_func = models.OneToOneField('DamageToLossFunc', null=True)
    vulnerability_func = models.OneToOneField('VulnerabilityFunc', null=True)
    fragility_func = models.OneToOneField('FragilityFunc', null=True)
    analysis_type = models.ForeignKey('AnalysisType')
    MODEL_TYPES = (
        (1, '3D'),
        (2, '2D element-by-element'),
        (3, '2D story-by-story'),
        (4, '1D'),
    )
    model_type = models.IntegerField(choices=MODEL_TYPES)
    METHODS_UNCERT_PROPAG = (
        (1, 'Random Monte-Carlo or Latin Hypercube sampling'),
        (2, 'Set of index buildings'),
        (3, 'Single index building'),
    )
    method_uncert_propag = models.IntegerField(choices=METHODS_UNCERT_PROPAG)
    # Number of dinstinct structural models analysed
    models_num = models.IntegerField(null=True, blank=True)


# C
class ModellingInformation(models.Model):
    #analytical_hybrid_modelling
    #empirical_modelling
    #statistical_information
    pass


# B2.1
class TaxonomyClassifForBuildings(models.Model):
    gem = models.TextField()
    pager = models.TextField()
    # I suppose we should specify both the textfield and the name of the
    # taxonomy
    other_taxonomy_name = models.CharField(max_length=CHMAX)
    other_taxonomy_text = models.TextField()


# B1
class RegionAsGeographicalApplicability(models.Model):
    pass


# B
class Applicability(models.Model):
    pass


METHODS_OF_ESTIMATION = (
    (1, 'Analytical'),
    (2, 'Empirical'),
)


DAMAGE_SCALES = (
    (1, 'MSK-76'),
    (2, 'EMS98'),
    (3, 'EMS92'),
    (4, 'HAZUS'),
    (5, 'ATC-13'),
    (6, 'Custom'),
)


RESPONSE_VARS = (
    (1, 'Damage factor'),
    (2, 'Fatality rate per occupant'),
    (3, 'Nonfatal injury rate per occupant'),
    (4, 'Fatality rate per exposed population'),
    (5, 'Direct economic factor'),
)


# Ax-a
class FuncDistributionShape(models.Model):
    # Initial values: Lognormal, Beta, Gamma
    name = models.CharField(max_length=CHMAX)


# A4-b
class CC_EngineeringDemandPar(models.Model):
    # Initial data
    #ENGINEERING_DEMAND_PARAMETERS = (
        #(1, 'Interstorey drift'),
        #(2, 'Global drift'),
        #(3, 'Residual drift'),
        #(4, 'Lateral roof displacement'),
        #(5, 'Chord rotation'),
        #(6, 'Curvature'),
        #(7, 'Shear strain'),
        #(8, 'Spectral displacement'),
    #)
    name = models.CharField(max_length=CHMAX)


# A4-a
class CC_PredictorVar(models.Model):
    capacity_curve_func = models.OneToOneField('CapacityCurveFunc')
    engineering_demand_param = models.ForeignKey('CC_EngineeringDemandPar')
    data_pts_num = models.IntegerField()
    pred_var_units = models.CharField(max_length=16)
    pred_var_val = CommaSeparatedFloatField(max_length=1024)


# A4
class CapacityCurveFunc(models.Model):
    # One2One with AnalyticalModelInfo
    # One2One with CC_PredictorVar
    RESPONSE_VAR_PAR = (
        (1, 'Base shear'),
        (2, 'Base bending moment'),
        (3, 'Spectral acceleration'),
    )
    response_var = models.IntegerField(choices=RESPONSE_VAR_PAR)
    res_var_units = models.CharField(max_length=16)
    res_var_val = CommaSeparatedFloatField(max_length=1024)


# A3
class DamageToLossFunc(models.Model):
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    damage_scale = models.IntegerField(choices=DAMAGE_SCALES, null=True)
    limit_states_num = models.IntegerField()
    limit_states_desc = SemicolonSeparatedStringField(max_length=1024)
    response_var = models.IntegerField(choices=RESPONSE_VARS)
    # NOTE: currently discrete only
    # func_distr_type =
    var_mean_val = CommaSeparatedFloatField(max_length=1024)
    var_val_coeff = CommaSeparatedFloatField(max_length=1024)
    func_distr_shape = models.ForeignKey('FuncDistributionShape', null=True)


# A2-b
class FuncDistributionVulnContinuous(models.Model):
    discretization_data_pts_num = models.IntegerField(null=True)
    mean = models.FloatField()
    std_dev = models.FloatField()
    func_distr_shape = models.ForeignKey('FuncDistributionShape')


# A2-a
class FuncDistributionVulnDiscrete(models.Model):
    data_pts_num = models.IntegerField()
    predictor_var_im_val = CommaSeparatedFloatField(max_length=1024)
    response_var_mean_val = CommaSeparatedFloatField(max_length=1024)
    response_var_val_coeff = CommaSeparatedFloatField(max_length=1024)


# used by FragilityFunc and VulnerabilityFunc
# A.2.2
class PredictorVar(models.Model):
    vulnerability_func = models.OneToOneField('VulnerabilityFunc', null=True)
    fragility_func = models.OneToOneField('FragilityFunc', null=True)
    INTENSITY_MEASURE_TYPES = (
        (1, 'PGA'),
        (2, 'PGV'),
        (3, 'PGD'),
        (4, 'Sa(T)'),
        (5, 'IA'),
        (6, 'CAV'),
        (7, 'RSD'),
        (8, 'MMI'),
    )
    intensity_measure_type = models.IntegerField(
        choices=INTENSITY_MEASURE_TYPES)
    INTENSITY_MEASURE_UNITS = (
        (1, 'Acceleration (g)'),
        (2, 'Acceleration (cm/s^2)'),
        (3, 'Acceleration (m/s^2)'),
        (4, 'Velocity (cm/s)'),
        (5, 'Velocity (m/s)'),
        (6, 'Displacement (cm)'),
        (7, 'Displacement (m)'),
        (8, 'Time (s)'),
        (9, 'CAV (g-s)'),
        (10, 'MMI roman numbers'),
    )
    intensity_measure_unit = models.IntegerField(
        choices=INTENSITY_MEASURE_UNITS)
    minimum_im = models.FloatField()
    maximum_im = models.FloatField()
    EVALUATIONS_OF_IM = (
        (1, 'GMPE'),
        (2, 'ShakeMap'),
        (3, 'Natural Accelerograms'),
        (4, 'Artificial Accelerograms'),
        (5, 'Spectrum-compatible Accelerograms'),
        (6, 'Spectrum (code-based)'),
        (7, 'Spectrum (GMPE-based)'),
        (8, 'Spectrum (other)'),
    )
    evaluation_of_im = models.IntegerField(choices=EVALUATIONS_OF_IM)


# A2
class VulnerabilityFunc(models.Model):
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # One2One with PredictorVar
    response_var = models.IntegerField(choices=RESPONSE_VARS)
    function_distribution_type = models.IntegerField(
        choices=((1, 'Discrete'), (2, 'Continuous')))
    func_distr_discrete = models.OneToOneField(
        'FuncDistributionVulnDiscrete', null=True)
    func_distr_continuous = models.OneToOneField(
        'FuncDistributionVulnContinuous', null=True)


# A1-c
class FuncDistributionFragContinuous(models.Model):
    fragility_func = models.OneToOneField('FragilityFunc')
    mean = CommaSeparatedFloatField(max_length=1024)
    std_dev = CommaSeparatedFloatField(max_length=1024)
    func_distr_shape = models.ForeignKey('FuncDistributionShape')
    coeff_variation_mean = CommaSeparatedFloatField(
        max_length=1024, null=True, blank=True)
    coeff_variation_std_dev = CommaSeparatedFloatField(
        max_length=1024, null=True, blank=True)
    predictor_var_corr_matrix = BidimensionalFloatField(null=True, blank=True)


# A1-b
class FuncDistributionFragDiscrete(models.Model):
    fragility_func = models.OneToOneField('FragilityFunc')
    data_pts_num = models.IntegerField()
    predictor_var_im_val = CommaSeparatedFloatField(max_length=1024)
    limit_state_prob_exceed = BidimensionalFloatField()
    limit_state_prob_exceed_05 = BidimensionalFloatField(null=True, blank=True)
    limit_state_prob_exceed_95 = BidimensionalFloatField(null=True, blank=True)


# A1-a
class EngineeringDemandPar(models.Model):
    # Initial data
    #ENGINEERING_DEMAND_PARAMETERS = (
        #(1, 'Interstorey drift'),
        #(2, 'Global drift'),
        #(3, 'Residual drift'),
        #(4, 'Rotation capacity'),
        #(5, 'Shear capacity'),
        #(6, 'Strain levels'),
        #(7, 'Other'),
    #)
    name = models.CharField(max_length=CHMAX)


# A1
class FragilityFunc(models.Model):
    method_of_estimation = models.IntegerField(choices=METHODS_OF_ESTIMATION)
    # One2One with AnalyticalModelInfo
    # One2One with EmpiricalModelInfo
    # One2One with PredictorVar
    # One2One with FuncDistributionFragDiscrete
    # One2One with FuncDistributionFragContinuous
    damage_scale = models.IntegerField(choices=DAMAGE_SCALES)
    engineering_demand_par = models.ForeignKey('EngineeringDemandPar',
                                               null=True)
    limit_states_num = models.PositiveIntegerField()
    # They require a vector with free text
    # (e.g. ['Slight', 'Moderate', 'Collapse']
    limit_states_desc = SemicolonSeparatedStringField(max_length=1024)
    FUNCTION_DISTRIBUTION_TYPES = (
        (1, 'Discrete'),
        (2, 'Continuous')
    )
    function_distribution_type = models.IntegerField(
        choices=FUNCTION_DISTRIBUTION_TYPES)


# A
class GeneralInformation(models.Model):
    # A.1 Reference ID code/name: choose integer(code)/string(name)
    name = models.CharField(max_length=CHMAX)
    TYPES_OF_ASSESSMENT = (
        (1, 'Fragility'),
        (2, 'Vulnerability'),
        (3, 'Damage-to-loss'),
        (4, 'Capacity curve'),
    )
    type_of_assessment = models.IntegerField(choices=TYPES_OF_ASSESSMENT)
    fragility = models.OneToOneField('FragilityFunc', null=True)
    vulnerability = models.OneToOneField('VulnerabilityFunc', null=True)
    damage_to_loss = models.OneToOneField('DamageToLossFunc', null=True)
    capacity_curve = models.OneToOneField('CapacityCurveFunc', null=True)
    # A.3 Reference / documentation
    authors = models.CharField(max_length=CHMAX)
    article_title = models.CharField(max_length=CHMAX)
    publication_conference_name = models.CharField(
        max_length=CHMAX, null=True, blank=True)
    year = models.IntegerField()
    web_link = models.URLField(null=True, blank=True, max_length=255)
    use_case_information = models.CharField(
        max_length=CHMAX, null=True, blank=True)
    general_comments = models.CharField(
        max_length=CHMAX, null=True, blank=True)
